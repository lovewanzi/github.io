---
layout: post
title: "数据结构"
date: 2024-07-25 12:00
categories: leetcode
background_image: "/assets/images/background.jpg"
tags: [leetcode, 数据结构]
toc: true
author: 麻辣烫
---

## 并查集（Union-Find）

### 定义

> 1. 一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。不交集指的是一系列**没有重复**元素的集合。主要是解决图论中**动态连通性**问题。
>
>    + **合并（Union）**：将两个集合合并成一个集合。
>    + **查找（Find）**：确定某个元素属于哪个集合。通常是返回集合内的一个代表元素（一般来讲是返回`root`）。
>
> 2. 用树来表示连通性：
>
>    + **初始化：**设定树的每个节点有⼀个指针指向其⽗节点，如果是根节点的话，这个指针指向⾃⼰。即初始化时，每个节点之间互不连通（即互不相干的集合），如下图
>
>      <img src="/assets/images/union_init.png" alt="并查集初始化" style="zoom:67%;" />
>
>    + **合并：**如果两个集合`A、B`之间因为某种判断条件被认为是一种集合，那么需要将`A、B`集合合并。而根据集合的定义，认为相同集合都有共同的`root`，因此让集合`A/B`中的（任意）⼀个节点的根节点接到`B/A`的根节点上。如下图：
>
>      <img src="/assets/images/union_merge.png" alt="union_merge" style="zoom:67%;" />
>
> 3. 核心功能：
>
>    + 初始化：将指向父节点的指针指向自己
>    + 寻根：将指针不停的往父节点遍历，直到节点的父节点为自己时，返回当前节点为集合的`root`
>    + 合并：将其中一个集合的`root`指向另外一个集合的`root`，完成合并。

### 代码实现

1. 初步实现并查集代码

~~~python
class UnionFind:
    def __init__(self, n):                          # 初始化：将每个元素的集合编号初始化为数组 fa 的下标索引
        self.fa = [i for i in range(n)]
        self.rank = [1 for i in range(n)]

    def find(self, x):                              # 查找元素根节点的集合编号内部实现方法
        while self.fa[x] != x:                      # 递归查找元素的父节点，直到根节点
            x = self.fa[x]
        return x                                    # 返回元素根节点的集合编号

    def union(self, x, y):                          # 合并操作：令其中一个集合的树根节点指向另一个集合的树根节点
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:                        # x 和 y 的根节点集合编号相同，说明 x 和 y 已经同属于一个集合
            return False
        self.fa[root_x] = root_y                    # x 的根节点连接到 y 的根节点上，成为 y 的根节点的子节点
        return True

    def is_connected(self, x, y):                   # 查询操作：判断 x 和 y 是否同属于一个集合
        return self.find(x) == self.find(y)
~~~

2. 复杂度分析：

   + `is_connected `和 `union `中的复杂度都是 `find `函数造成的，所以说它们的复杂度和 `find `⼀样。

   + `find `主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的⾼度。我们可能习惯性地认为树的⾼度就是` logN`，但这并不⼀定。`logN `的⾼度只存在于平衡⼆叉树，对于⼀般的树可能出现极端不平衡的情况，使得树⼏乎退化成链表，树的⾼度最坏情况下可能变成`N`。比如下图，如果`find`传入值为节点`5`，那么会从根部开始遍历，这样遍历高度为`N`

     <img src="/assets/images/union_list.png" alt="union_list" style="zoom:67%;" />

3. 路径压缩：

   > 在从底向上查找根节点过程中，如果此时访问的节点不是根节点，则我们可以把这个节点尽量向上移动一下，从而减少树的层树。这个过程就叫做路径压缩。

   + 隔代压缩：在查询时，两步一压缩，一直循环执行「把当前节点指向它的父亲节点的父亲节点」这样的操作，从而减小树的深度。

     <img src="/assets/images/gedaiyasuo.png" alt="隔代压缩" style="zoom:67%;" />

     + 隔代压缩代码如下：

       ~~~python
       def find(self, x):                              # 查找元素根节点的集合编号内部实现方法
           while self.fa[x] != x:                      # 递归查找元素的父节点，直到根节点
               self.fa[x] = self.fa[self.fa[x]]        # 隔代压缩
               x = self.fa[x]
           return x                                    # 返回元素根节点的集合编号
       ~~~

   + 完全压缩：在查询时，把被查询的节点到根节点的路径上的所有节点的父节点设置为根节点，从而减小树的深度。也就是说，在向上查询的同时，把在路径上的每个节点都直接连接到根上，以后查询时就能直接查询到根节点。

     <img src="/assets/images/wanquanyasuo.png" alt="wanquanyasuo" style="zoom:67%;" />

     + 完全压缩代码如下：

       ~~~python
       def find(self, x):                              # 查找元素根节点的集合编号内部实现方法
           if self.fa[x] != x:                         # 递归查找元素的父节点，直到根节点
               self.fa[x] = self.find(self.fa[x])      # 完全压缩优化
           return self.fa[x]
       
       # 解释上面的代码在干什么
       def find(self, x):
           # 先找到根节点
           root = x
           while self.fa[root] != root:
               root = self.fa[root]
           
           # 然后把 x 到根节点之间的所有节点直接接到根节点下⾯
           old_parent = self.fa[x]
           while x != root:
               self.fa[x] = root
               x = old_parent
               old_parent = self.fa[old_parent]
           
           return root
       ~~~
       
     + **注意：**当并查集结束时，树的深度并不一定为`2`。因为当两棵树合并后，被合并那棵树上面的节点在后续的操作中没被`find`过。那么，最终形成的树深度肯定是大于`2`的

4. 按秩合并：因为路径压缩只在查询时进行，并且**只压缩一棵树上的路径**，所以并查集最终的结构仍然可能是比较复杂的。为了避免这种情况，另一个优化方式是「按秩合并」。

   > 1. 指的是在每次合并操作时，都把「秩」较小的树根节点指向「秩」较大的树根节点。
   >
   > 2. 「秩」有两种定义，一种定义指的是树的深度；另一种定义指的是树的大小（即集合节点个数）。无论采用哪种定义，集合的秩都记录在树的根节点上。
   >
   > 3. 按秩合并也有两种方式：一种叫做「按深度合并」；另一种叫做「按大小合并」。
   >
   >    + **按深度合并（Unoin By Rank）**：在每次合并操作时，都把「深度」较小的树根节点指向「深度」较大的树根节点。
   >
   >      <img src="/assets/images/union_deep.png" alt="union_deep" style="zoom:80%;" />
   >
   >      ~~~python
   >      def union(self, x, y):                          # 合并操作：令其中一个集合的树根节点指向另一个集合的树根节点
   >          root_x = self.find(x)
   >          root_y = self.find(y)
   >          if root_x == root_y:                        # x和y的根节点集合编号相同，说明x和y已经同属于一个集合
   >              return False
   >          if self.rank[root_x] < self.rank[root_y]:   # x 的根节点对应的树的深度小于y的根节点对应的树的深度
   >              self.fa[root_x] = root_y                # x 的根节点连接到y的根节点上，成为y的根节点的子节点
   >          elif self.rank[root_y] > self.rank[root_y]: # x 的根节点对应的树的深度 大于 y 的根节点对应的树的深度
   >              self.fa[root_y] = root_x                # y 的根节点连接到 x 的根节点上，成为 x 的根节点的子节点
   >          else:                                       # x 的根节点对应的树的深度 等于 y 的根节点对应的树的深度
   >              self.fa[root_x] = root_y                # 向任意一方合并即可
   >              self.rank[root_y] += 1                  # 因为层数相同，被合并的树必然层数会 +1
   >          return True
   >      ~~~
   >
   >    + **按大小合并（Unoin By Size）**：这里的大小指的是集合节点个数。在每次合并操作时，都把「集合节点个数」较少的树根节点指向「集合节点个数」较大的树根节点。
   >
   >      <img src="/assets/images/union_size.png" alt="size" style="zoom:80%;" />
   >
   >      ~~~python
   >      def union(self, x, y):                          # 合并操作：令其中一个集合的树根节点指向另一个集合的树根节点
   >          root_x = self.find(x)
   >          root_y = self.find(y)
   >          if root_x == root_y:                        #x和y的根节点集合编号相同，说明 x 和 y 已经同属于一个集合
   >              return False
   >                
   >          if self.rank[root_x] < self.rank[root_y]:   # x 对应的集合元素个数 小于 y 对应的集合元素个数
   >              self.fa[root_x] = root_y                # x 的根节点连接到 y 的根节点上，成为 y 的根节点的子节点
   >              self.rank[root_y] += self.rank[root_x]  #y的根节点对应的集合元素个数累加上x的根节点对应的集合元素个数
   >          elif self.rank[root_x] > self.rank[root_y]: # x 对应的集合元素个数 大于 y 对应的集合元素个数
   >              self.fa[root_y] = root_x                # y 的根节点连接到 x 的根节点上，成为 x 的根节点的子节点
   >              self.rank[root_x] += self.rank[root_y]  #x的根节点对应的集合元素个数累加上y的根节点对应的集合元素个数
   >          else:                                       # x 对应的集合元素个数 小于 y 对应的集合元素个数
   >              self.fa[root_x] = root_y                # 向任意一方合并即可
   >              self.rank[root_y] += self.rank[root_x]
   >                
   >          return True
   >      ~~~
   >
   > 4. 如果对于单课树使用了完全压缩，那么按秩合并其实并不是必须的，因为节点到子节点的查询都为`O(1)`

## 位运算

### 运算符种类

| 运算符 | 描述           | 规则                                                         |
| ------ | -------------- | ------------------------------------------------------------ |
| `|`    | 按位或运算符   | 只要对应的两个二进位有一个为 1 时，结果位就为 1。            |
| `&`    | 按位与运算符   | 只有对应的两个二进位都为 1 时，结果位才为 1。                |
| `<<`   | 左移运算符     | 将二进制数的各个二进位全部左移若干位。`<<` 右侧数字指定了移动位数，高位丢弃，低位补 0。 |
| `>>`   | 右移运算符     | 对二进制数的各个二进位全部右移若干位。`>>` 右侧数字指定了移动位数，低位丢弃，高位补 0。 |
| `^`    | 按位异或运算符 | 对应的两个二进位相异时，结果位为 1，二进位相同时则结果位为 0。 |
| `~`    | 取反运算符     | 对二进制数的每个二进位取反，使数字 1 变为 0，0变为 1。       |

### 位运算的应用

#### 1 位运算的常用操作

##### 1.1 判断整数奇偶

一个整数，只要是偶数，其对应二进制数的末尾一定为 0；只要是奇数，其对应二进制数的末尾一定为 1。所以，我们通过与 1 进行按位与运算，即可判断某个数是奇数还是偶数。

1. `(x & 1) == 0` 为偶数。
2. `(x & 1) == 1` 为奇数。

##### 1.2 二进制数选取指定位

如果我们想要从一个二进制数 $X$ 中取出某几位，使取出位置上的二进位保留原值，其余位置为 0，则可以使用另一个二进制数 $Y$，使该二进制数上对应取出位置为 1，其余位置为 0。然后令两个数进行按位与运算（`X & Y`），即可得到想要的数。

举个例子，比如我们要取二进制数 $X$=01101010~(2)~ 的末尾 4 位，则只需将 $X$=01101010~(2)~与 $Y$=00001111~(2)~ (末尾 4 位为 1，其余位为 0) 进行按位与运算，即 `01101010 & 00001111 == 00001010`。其结果 00001010就是我们想要的数（即二进制数 01101010~(2)~的末尾 4 位）。

##### 1.3 将指定位设置为 1

如果我们想要把一个二进制数 $X$ 中的某几位设置为 1，其余位置保留原值，则可以使用另一个二进制数$Y$，使得该二进制上对应选取位置为 1，其余位置为 0。然后令两个数进行按位或运算（`X | Y`），即可得到想要的数。

举个例子，比如我们想要将二进制数$X$=01101010~(2)~ 的末尾 4 位设置为 1，其余位置保留原值，则只需将$X$*=01101010~(2)~ 与 $Y$=00001111~(2)~（末尾 4 位为 1，其余位为0）进行按位或运算，即 `01101010 | 00001111 = 01101111`。其结果` 01101111` 就是我们想要的数（即将二进制数 01101010的末尾 4 位设置为 1，其余位置保留原值）。

##### 1.4 反转指定位

如果我们想要把一个二进制数$X$ 的某几位进行反转，则可以使用另一个二进制数 $Y$，使得该二进制上对应选取位置为 1，其余位置为 0。然后令两个数进行按位异或运算（`X ^ Y`），即可得到想要的数。

举个例子，比如想要将二进制数$X$=01101010~(2)~的末尾4位进行反转，则只需将 $X$=01101010~(2)~ 与 $Y$=00001111~(2)~（末尾 4 位为 1，其余位为 0）进行按位异或运算，即 `01101010 ^ 00001111 = 01100101`。其结果 01100101 就是我们想要的数（即将二进制数 $X$=01101010~(2)~ 的末尾 4 位进行反转）。

##### 1.5 交换两个数

通过按位异或运算可以实现交换两个数的目的（只能用于交换两个整数）。

```python
a, b = 10, 20
a ^= b
b ^= a
a ^= b
print(a, b)
```

##### 1.6 将二进制最右侧为 1 的二进位改为 0

如果我们想要将一个二进制数 $X$最右侧为 1 的二进制位改为 0，则只需通过 `X & (X - 1)` 的操作即可完成。

比如$X$=01101100~(2)~，$X−1$=01101011~(2)~，则 `X & (X - 1) == 01101100 & 01101011 == 01101000`，结果为01101000~(2)~（即将$X$最右侧为 1 的二进制为改为 0）。

##### 1.7 计算二进制中二进位为 1 的个数

从 1.6 中得知，通过 `X & (X - 1)` 我们可以将二进制 $X$ 最右侧为 1 的二进制位改为 0，那么如果我们不断通过 `X & (X - 1)` 操作，最终将二进制$X$变为 0，并统计执行次数，则可以得到二进制中二进位为 1 的个数。

具体代码如下：

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        cnt = 0
        while n:
            n = n & (n - 1)
            cnt += 1
        return cnt
```

##### 1.8 判断某数是否为 2 的幂次方

通过判断 `X & (X - 1) == 0` 是否成立，即可判断$X$是否为 2 的幂次方。

这是因为：

1. 凡是 2 的幂次方，其二进制数的某一高位为 1，并且仅此高位为 1，其余位都为 0。
2. 不是 2 的幂次方，其二进制数存在多个值为 1 的位。 

#### 2 位运算的常用操作总结

| 功能                                 | 位运算                            | 示例                      |
| ------------------------------------ | --------------------------------- | ------------------------- |
| **从右边开始，把最后一个 1改写成 0** | `x & (x - 1)`                     | `100101000 -> 100100000`  |
| **去掉右边起第一个 1 的左边**        | `x & (x ^ (x - 1))` 或 `x & (-x)` | `100101000 -> 1000`       |
| **去掉最后一位**                     | `x >> 1`                          | `101101 -> 10110`         |
| **取右数第 k 位**                    | `x >> (k - 1) & 1`                | `1101101 -> 1, k = 4`     |
| **取末尾 3 位**                      | `x & 7`                           | `1101101 -> 101`          |
| **取末尾 k 位**                      | `x & 15`                          | `1101101 -> 1101, k = 4`  |
| **只保留右边连续的 1**               | `(x ^ (x + 1)) >> 1`              | `100101111 -> 1111`       |
| **右数第 k 位取反**                  | `x ^ (1 << (k - 1))`              | `101001 -> 101101, k = 3` |
| **在最后加一个 0**                   | `x << 1`                          | `101101 -> 1011010`       |
| **在最后加一个 1**                   | `(x << 1) + 1`                    | `101101 -> 1011011`       |
| **把右数第 k 位变成 0**              | `x & ~(1 << (k - 1))`             | `101101 -> 101001, k = 3` |
| **把右数第 k 位变成 1**              | `x | (1 << (k - 1))`              | `101001 -> 101101, k = 3` |
| **把右边起第一个 0 变成 1**          | `x | (x + 1)`                     | `100101111 -> 100111111`  |
| **把右边连续的 0 变成 1**            | `x | (x - 1)`                     | `11011000 -> 11011111`    |
| **把右边连续的 1 变成 0**            | `x & (x + 1)`                     | `100101111 -> 100100000`  |
| **把最后一位变成 0**                 | `x | 1 - 1`                       | `101101 -> 101100`        |
| **把最后一位变成 11**                | `x | 1`                           | `101100 -> 101101`        |
| **把末尾 k 位变成 1**                | `x | (1 << k - 1)`                | `101001 -> 101111, k = 4` |
| **最后一位取反**                     | `x ^ 1`                           | `101101 -> 101100`        |
| **末尾 k 位取反**                    | `x ^ (1 << k - 1)`                | `101001 -> 100110, k = 4` |

#### 3 枚举子集

对于一个元素个数为 $n$ 的集合$S$来说，每一个位置上的元素都有选取和未选取两种状态。我们可以用数字 1 来表示选取该元素，用数字 0 来表示不选取该元素。

那么我们就可以用一个长度为$n$的二进制数来表示集合$S$ 或者表示 $S$ 的子集。其中二进制的每一个二进位都对应了集合中某一个元素的选取状态。对于集合中第 $i$ 个元素来说，二进制对应位置上的 1 代表该元素被选取，0代表该元素未被选取。

举个例子，比如长度为 5 的集合 $S$={5,4,3,2,1}，我们可以用一个长度为 5 的二进制数来表示该集合。

比如二进制数 11111~(2)~就表示选取集合的第 1 位、第 2 位、第 3 位、第 4 位、第 5 位元素，也就是集合 `{5,4,3,2,1}`，即集合 $S$ 本身。如下表所示：

| 集合 S 中元素位置 |  5   |  4   |  3   |  2   |  1   |
| :---------------- | :--: | :--: | :--: | :--: | :--: |
| 二进位对应值      |  1   |  1   |  1   |  1   |  1   |
| 对应选取状态      | 选取 | 选取 | 选取 | 选取 | 选取 |

再比如二进制数 10101~(2)~ 就表示选取集合的第 1 位、第 3 位、第 5 位元素，也就是集合`{5,3,1}`。如下表所示：

| 集合 S 中元素位置 |  5   |   4    |  3   |   2    |  1   |
| :---------------- | :--: | :----: | :--: | :----: | :--: |
| 二进位对应值      |  1   |   0    |  1   |   0    |  1   |
| 对应选取状态      | 选取 | 未选取 | 选取 | 未选取 | 选取 |

对于长度为$n$的集合 $S$ 来说，只需要枚举 0∼2^n^−1（共 2^n^ 种情况），即可得到集合 $S$ 的所有子集。

~~~python
class Solution:
    def subsets(self, S):                   # 返回集合 S 的所有子集
        n = len(S)                          # n 为集合 S 的元素个数
        sub_sets = []                       # sub_sets 用于保存所有子集
        for i in range(1 << n):             # 枚举 0 ~ 2^n - 1
            sub_set = []                    # sub_set 用于保存当前子集
            for j in range(n):              # 枚举第 i 位元素
                if i >> j & 1:              # 如果第 i 为元素对应二进位删改为 1，则表示选取该元素
                    sub_set.append(S[j])    # 将选取的元素加入到子集 sub_set 中
            sub_sets.append(sub_set)        # 将子集 sub_set 加入到所有子集数组 sub_sets 中
        return sub_sets                     # 返回所有子集
~~~

## 二分查找

### 二分查找左右边界

#### 左边界

> 循环结束后，`num[right + 1] == target`

~~~python
while left <= right:
    mid = left + (right - left) // 2
    if nums[mid] >= target:  # 因为是 >= 所以right会一直逼近左边界，因为当找到nums[mid] == target时，right是一直减小的
        right = mid - 1
    else:  
        left = mid + 1
~~~

#### 右边界

> 循环结束后，`nums[left - 1] == target`

~~~python 
while left <= right:
    mid = left + (right - left) // 2
    if nums[mid] > target:
        right = mid - 1
    else:  # 因为是 <= 所以left会一直逼近右边界，因为当找到nums[mid] == target时，left是一直增大的
        left = mid + 1
~~~

### 最大化最小值或最小化最大值

> 分析上边寻找`target`边界的代码：
>
> 1. 随着`left`和`right`的不断更新，`left`和`right`总是逼近使`nums[mid] ~= target`的位置
> 2. 而最后一次循环的条件是`left == right`，则有两种情况：
>    + 如果数组`nums`不包含`target`：
>      + 假设`nums[left == right]`落在`target`左边，那么对于上边左右边界的代码，最后一次更新的肯定是左边界`left`。因此`left`表示第一个大于`target`的数，`right`表示第一个小于`target`的数
>      + 反之，如果落在右边，最后一次更新的为右边界`right`。因此`right`表示第一次小于`target`的数字，`left`表示第一个大于`target`的数
>      + 因此`right + 1`表示第一个大于`target`的数字，`left - 1`表示第一个小于`target`的数字
>    + 如果数组`nums`包含`target`:
>      + 就跟上面寻找`target`的左右边界一样，`left`和`right`更新完毕后。`right + 1`表示`target`的左边界，即第一个大于等于`target`的位置。`left - 1`表示`target`的右边界，即第一个小于等于`target`的位置
> 3. 总结：
>    + 因此，为了综合`2`种讨论的几种情况。直接用`left - 1`表示第一个小于等于`target`的位置，`right + 1`表示第一个大于等于`target`的位置

## 背包问题

背包问题 (Knapsack problem) 是一种组合优化的 NP (NP-Complete) 完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。

### 一般背包问题

 我们有 `n`件物品和一个容量为 `C` 的背包，记第 `i` 件物品的重量为 $w_i$，价值为 $v_i$，求将哪些物品装入背包可使价值总和最大。

> **0-1背包：** 如果限定每件物品最多只能选取 `1` 次（即 `0` 或 `1` 次），则问题称为 `0-1`背包问题。
>
> **完全背包：** 如果每件物品最多可以选取无限次，则问题称为**完全背包问题**

假设放入背包中的物品`i`的数目为 $k_i$，则上述背包问题在数学上可表达为：
$$
\begin{aligned} \max \sum _{i= 0}^{n- 1}k_i\cdot v_i \end{aligned}
$$

$$
\begin{aligned} \left.\sum_{i=0}^{n-1}k_i\cdot w_i\leqslant C,\quad\left\{\begin{array}{ll}k_i\in\{0,1\}&\longleftarrow \quad \text{01背包问题} \\k_i\in\{0,1,2,\ldots,+\infty\}&\longleftarrow \quad \text{完全背包问题}\end{array}\right.\right. \end{aligned}
$$

### 「0−1 背包问题」

一般地，我们定义：`dp[i][j]`表示前 `i` 件物品放入一个容量为 `j` 的背包可以获得的最大价值（每件物品最多放一次），则状态转移过程可表示为：

> 1. 不选择第 `i` 件物品，则问题转化为了前 `i − 1` 件物品放入容量为 `j` 的背包中所获得的价值：`dp[i][j]=dp[i−1][j]` 
>
> 2. 选择第 `i` 件物品，则问题转化为了前 `i − 1` 件物品放入容量为$j − w_i$的背包中所获得的价值$ dp[i−1][j−w_i] $加上要放入的第 `i` 件物品的价值$v_i$
>    + $dp[i][j]=dp[i−1][j−w_i]+v_i$。注意，能放入第 `i` 件物品的前提为：$w_i ≤ j$ 。


两种情况取较大者即可得到「状态转移方程」为：

$dp[i][j]=max\{dp[i−1][j], dp[i−1][j−w_i]+v_i\} $

### 「完全背包问题」

类似于「`0−1` 背包」，但不同的是每件物品有无限个供应：从每件物品的数量来考虑，相关方案已并非取（取 `1` 件）或不取（取 `0` 件）两种情况，而是有取 `0` 件、取 `1` 件、取 `2` 件......取 `k` 件等很多种。

一般地，我们定义：`dp[i][j]` 表示前 `i` 件物品放入一个容量为 `j` 的背包可以获得的最大价值（每件物品有无限个）。每件物品可以被选择多次，因此`dp[i][j] `应为以下所有可能方案中的最大值：

+ 第` i `件物品选 `0` 个的最大价值 `dp[i−1][j]` 

+ 第`i` 件物品选 `1` 个的最大价值 $dp[i−1][j−w_i]+v_i$ 

+ 第`i` 件物品选 `2` 个的最大价值 $dp[i−1][j−2w_i]+2v_i$ 

  $......$

+ 第`i` 件物品选 `k`个的最大价值 $dp[i−1][j−kw_i]+kv_i$

**注意**: 第 `i` 件物品能放入 `k` 件的前提为：$kw_i ≤ j$

由状态方程可知，我们可以借鉴「0−1 背包」问题的求解方式来解决「完全背包问题」，但对于每件物品而言每次都需要枚举所有可行的物品数目 `k`，这无疑会大大增加系统的开销。

#### 完全背包问题的状态空间优化

将上述状态转移方程展开可得：
$$
\begin{aligned} dp[i][j]=\max\{ dp[i-1][j],\quad dp[i-1][j-w_i]+v_i, dp[i-1][j-2\cdot w_i]+2\cdot v_i,\\..., \textcolor{Red}{dp[i-1][j-k\cdot w_i]+k\cdot v_i} \},\quad0<=k\cdot w_i<=j \end{aligned}
$$
对于 $dp[i][j−w_i]$ 我们有:
$$
\begin{aligned} dp[i][j-w_i]&=\max\{ dp[i-1][j-w_i],\quad dp[i-1][j-2\cdot w_i]+v_i,\\&..., \textcolor{Blue}{dp[i-1][j-k\cdot w_i]+(k-1)\cdot v_i} \},\quad w_i<=k\cdot w_i<=j \end{aligned}
$$
观察发现，式中的后 `k` 项刚好相差了一个 $v_i$，可得简化后的「完全背包问题」的「状态转移方程」为：
$$
\begin{aligned} dp[i][j]=\max\{ dp[i-1][j],\quad dp[i][j-w_i]+v_i \},\quad0<=w_i<=j \end{aligned}
$$

> 为什么式`(4)`中的最后一项是  $dp[i-1][j-k\cdot w_i]+(k-1)\cdot v_i$  ？
>
> 1. 因为式`(3)`中  $dp[i][j]$  能扩展到  $k$ 项，即  $dp[i-1][j-k\cdot w_i]+k\cdot v_i$   ，那么显然 $dp[i][j - w_i]$ 只能扩展到第  $k - 1$项。
>
> 2. 由`1`中的分析，因此  $dp[i][j - w_i]$  的最后一项为：$dp[i - 1][j - w_i - (k - 1)\cdot w_i] + (k - 1)\cdot v_i$  ，那么化简为：  $dp[i-1][j-k\cdot w_i]+(k-1)\cdot v_i$
>
> 为什么式`(4)`和式`(3)`可以直接合并？
>
> 1. 因为  $dp[i][j - w_i]$   在选取第`i`件物品的情况下只能扩展到`k - 1`项，再加上首项  $dp[i - 1][j - w_i]$，正好  $k$  项。那么给每一项加上一个  $v_i$  正好和  $dp[i][j]$ 的除了  $dp[i - 1][j]$  项的后 $k$ 项相等。

### 对比总结

将两种背包问题做如下对比：

+ `0-1`背包问题：$dp[i][j] = max\{dp[i - 1][j],\quad dp[i - 1][j - w_i] + v_i\}$
+ 完全背包问题：$dp[i][j] = max\{dp[i - 1][j],\quad dp[i][j - w_i] + v_i\}$

### 满背包和最大背包

求最优解的背包问题中，有的题目要求恰好装满背包时的最优解，有的题目则要求不超过背包容量时的最优解。一种区别这两种问法的实现方法是在状态初始化的时候有所不同。

> 初始化的 `dp `数组事实上就是在背包中没有放入任何物品时的合法状态：
>
> 1. 如果要求恰好装满背包，那么在初始化时 `dp[i][0]=0`，其它 `dp[i][1,2,...,∗]` 均设为 $− ∞$。这是因为此时只有容量为 `0` 的背包可能被价值为 `0` 的 `nothing `“恰好装满”，而其它容量的背包均没有合法的解，属于未定义的状态。
> 2. 如果只是要求不超过背包容量而使得背包中的物品价值尽量大，初始化时应将` dp[∗][∗] `全部设为 `0`。这是因为对应于任何一个背包，都有一个合法解为 “什么都不装”，价值为 `0`。
