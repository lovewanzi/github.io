---
layout: post
title: "数据结构"
date: 2024-07-25 12:00
categories: leetcode
background_image: "/assets/images/background.jpg"
tags: [leetcode, 数据结构]
toc: true
author: 麻辣烫
---

## 并查集（Union-Find）

### 定义

> 1. 一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。不交集指的是一系列**没有重复**元素的集合。主要是解决图论中**动态连通性**问题。
>
>    + **合并（Union）**：将两个集合合并成一个集合。
>    + **查找（Find）**：确定某个元素属于哪个集合。通常是返回集合内的一个代表元素（一般来讲是返回`root`）。
>
> 2. 用树来表示连通性：
>
>    + **初始化：**设定树的每个节点有⼀个指针指向其⽗节点，如果是根节点的话，这个指针指向⾃⼰。即初始化时，每个节点之间互不连通（即互不相干的集合），如下图
>
>      <img src="/assets/images/union_init.png" alt="并查集初始化" style="zoom:67%;" />
>
>    + **合并：**如果两个集合`A、B`之间因为某种判断条件被认为是一种集合，那么需要将`A、B`集合合并。而根据集合的定义，认为相同集合都有共同的`root`，因此让集合`A/B`中的（任意）⼀个节点的根节点接到`B/A`的根节点上。如下图：
>
>      <img src="/assets/images/union_merge.png" alt="union_merge" style="zoom:67%;" />
>
> 3. 核心功能：
>
>    + 初始化：将指向父节点的指针指向自己
>    + 寻根：将指针不停的往父节点遍历，直到节点的父节点为自己时，返回当前节点为集合的`root`
>    + 合并：将其中一个集合的`root`指向另外一个集合的`root`，完成合并。

### 代码实现

1. 初步实现并查集代码

~~~python
class UnionFind:
    def __init__(self, n):                          # 初始化：将每个元素的集合编号初始化为数组 fa 的下标索引
        self.fa = [i for i in range(n)]
        self.rank = [1 for i in range(n)]

    def find(self, x):                              # 查找元素根节点的集合编号内部实现方法
        while self.fa[x] != x:                      # 递归查找元素的父节点，直到根节点
            x = self.fa[x]
        return x                                    # 返回元素根节点的集合编号

    def union(self, x, y):                          # 合并操作：令其中一个集合的树根节点指向另一个集合的树根节点
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:                        # x 和 y 的根节点集合编号相同，说明 x 和 y 已经同属于一个集合
            return False
        self.fa[root_x] = root_y                    # x 的根节点连接到 y 的根节点上，成为 y 的根节点的子节点
        return True

    def is_connected(self, x, y):                   # 查询操作：判断 x 和 y 是否同属于一个集合
        return self.find(x) == self.find(y)
~~~

2. 复杂度分析：

   + `is_connected `和 `union `中的复杂度都是 `find `函数造成的，所以说它们的复杂度和 `find `⼀样。

   + `find `主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的⾼度。我们可能习惯性地认为树的⾼度就是` logN`，但这并不⼀定。`logN `的⾼度只存在于平衡⼆叉树，对于⼀般的树可能出现极端不平衡的情况，使得树⼏乎退化成链表，树的⾼度最坏情况下可能变成`N`。比如下图，如果`find`传入值为节点`5`，那么会从根部开始遍历，这样遍历高度为`N`

     <img src="/assets/images/union_list.png" alt="union_list" style="zoom:67%;" />

3. 路径压缩：

   > 在从底向上查找根节点过程中，如果此时访问的节点不是根节点，则我们可以把这个节点尽量向上移动一下，从而减少树的层树。这个过程就叫做路径压缩。

   + 隔代压缩：在查询时，两步一压缩，一直循环执行「把当前节点指向它的父亲节点的父亲节点」这样的操作，从而减小树的深度。

     <img src="/assets/images/gedaiyasuo.png" alt="隔代压缩" style="zoom:67%;" />

     + 隔代压缩代码如下：

       ~~~python
       def find(self, x):                              # 查找元素根节点的集合编号内部实现方法
           while self.fa[x] != x:                      # 递归查找元素的父节点，直到根节点
               self.fa[x] = self.fa[self.fa[x]]        # 隔代压缩
               x = self.fa[x]
           return x                                    # 返回元素根节点的集合编号
       ~~~

   + 完全压缩：在查询时，把被查询的节点到根节点的路径上的所有节点的父节点设置为根节点，从而减小树的深度。也就是说，在向上查询的同时，把在路径上的每个节点都直接连接到根上，以后查询时就能直接查询到根节点。

     <img src="/assets/images/wanquanyasuo.png" alt="wanquanyasuo" style="zoom:67%;" />

     + 完全压缩代码如下：

       ~~~python
       def find(self, x):                              # 查找元素根节点的集合编号内部实现方法
           if self.fa[x] != x:                         # 递归查找元素的父节点，直到根节点
               self.fa[x] = self.find(self.fa[x])      # 完全压缩优化
           return self.fa[x]
       
       # 解释上面的代码在干什么
       def find(self, x):
           # 先找到根节点
           root = x
           while self.fa[root] != root:
               root = self.fa[root]
           
           # 然后把 x 到根节点之间的所有节点直接接到根节点下⾯
           old_parent = self.fa[x]
           while x != root:
               self.fa[x] = root
               x = old_parent
               old_parent = self.fa[old_parent]
           
           return root
       ~~~

4. 按秩合并：因为路径压缩只在查询时进行，并且**只压缩一棵树上的路径**，所以并查集最终的结构仍然可能是比较复杂的。为了避免这种情况，另一个优化方式是「按秩合并」。

   > 1. 指的是在每次合并操作时，都把「秩」较小的树根节点指向「秩」较大的树根节点。
   >
   > 2. 「秩」有两种定义，一种定义指的是树的深度；另一种定义指的是树的大小（即集合节点个数）。无论采用哪种定义，集合的秩都记录在树的根节点上。
   >
   > 3. 按秩合并也有两种方式：一种叫做「按深度合并」；另一种叫做「按大小合并」。
   >
   >    + **按深度合并（Unoin By Rank）**：在每次合并操作时，都把「深度」较小的树根节点指向「深度」较大的树根节点。
   >
   >      <img src="/assets/images/union_deep.png" alt="union_deep" style="zoom:80%;" />
   >
   >      ~~~python
   >      def union(self, x, y):                          # 合并操作：令其中一个集合的树根节点指向另一个集合的树根节点
   >          root_x = self.find(x)
   >          root_y = self.find(y)
   >          if root_x == root_y:                        # x和y的根节点集合编号相同，说明x和y已经同属于一个集合
   >              return False
   >          if self.rank[root_x] < self.rank[root_y]:   # x 的根节点对应的树的深度小于y的根节点对应的树的深度
   >              self.fa[root_x] = root_y                # x 的根节点连接到y的根节点上，成为y的根节点的子节点
   >          elif self.rank[root_y] > self.rank[root_y]: # x 的根节点对应的树的深度 大于 y 的根节点对应的树的深度
   >              self.fa[root_y] = root_x                # y 的根节点连接到 x 的根节点上，成为 x 的根节点的子节点
   >          else:                                       # x 的根节点对应的树的深度 等于 y 的根节点对应的树的深度
   >              self.fa[root_x] = root_y                # 向任意一方合并即可
   >              self.rank[root_y] += 1                  # 因为层数相同，被合并的树必然层数会 +1
   >          return True
   >      ~~~
   >
   >    + **按大小合并（Unoin By Size）**：这里的大小指的是集合节点个数。在每次合并操作时，都把「集合节点个数」较少的树根节点指向「集合节点个数」较大的树根节点。
   >
   >      <img src="/assets/images/union_size.png" alt="size" style="zoom:80%;" />
   >
   >      ~~~python
   >      def union(self, x, y):                          # 合并操作：令其中一个集合的树根节点指向另一个集合的树根节点
   >          root_x = self.find(x)
   >          root_y = self.find(y)
   >          if root_x == root_y:                        #x和y的根节点集合编号相同，说明 x 和 y 已经同属于一个集合
   >              return False
   >          
   >          if self.rank[root_x] < self.rank[root_y]:   # x 对应的集合元素个数 小于 y 对应的集合元素个数
   >              self.fa[root_x] = root_y                # x 的根节点连接到 y 的根节点上，成为 y 的根节点的子节点
   >              self.rank[root_y] += self.rank[root_x]  #y的根节点对应的集合元素个数累加上x的根节点对应的集合元素个数
   >          elif self.rank[root_x] > self.rank[root_y]: # x 对应的集合元素个数 大于 y 对应的集合元素个数
   >              self.fa[root_y] = root_x                # y 的根节点连接到 x 的根节点上，成为 x 的根节点的子节点
   >              self.rank[root_x] += self.rank[root_y]  #x的根节点对应的集合元素个数累加上y的根节点对应的集合元素个数
   >          else:                                       # x 对应的集合元素个数 小于 y 对应的集合元素个数
   >              self.fa[root_x] = root_y                # 向任意一方合并即可
   >              self.rank[root_y] += self.rank[root_x]
   >          
   >          return True
   >      ~~~
   >
   > 4. 如果对于单课树使用了完全压缩，那么按秩合并其实并不是必须的，因为节点到子节点的查询都为`O(1)`

## 位运算

### 运算符种类

| 运算符 | 描述           | 规则                                                         |
| ------ | -------------- | ------------------------------------------------------------ |
| `|`    | 按位或运算符   | 只要对应的两个二进位有一个为 1 时，结果位就为 1。            |
| `&`    | 按位与运算符   | 只有对应的两个二进位都为 1 时，结果位才为 1。                |
| `<<`   | 左移运算符     | 将二进制数的各个二进位全部左移若干位。`<<` 右侧数字指定了移动位数，高位丢弃，低位补 0。 |
| `>>`   | 右移运算符     | 对二进制数的各个二进位全部右移若干位。`>>` 右侧数字指定了移动位数，低位丢弃，高位补 0。 |
| `^`    | 按位异或运算符 | 对应的两个二进位相异时，结果位为 1，二进位相同时则结果位为 0。 |
| `~`    | 取反运算符     | 对二进制数的每个二进位取反，使数字 1 变为 0，0变为 1。       |

### 位运算的应用

#### 1 位运算的常用操作

##### 1.1 判断整数奇偶

一个整数，只要是偶数，其对应二进制数的末尾一定为 0；只要是奇数，其对应二进制数的末尾一定为 1。所以，我们通过与 1 进行按位与运算，即可判断某个数是奇数还是偶数。

1. `(x & 1) == 0` 为偶数。
2. `(x & 1) == 1` 为奇数。

##### 1.2 二进制数选取指定位

如果我们想要从一个二进制数 $X$ 中取出某几位，使取出位置上的二进位保留原值，其余位置为 0，则可以使用另一个二进制数 $Y$，使该二进制数上对应取出位置为 1，其余位置为 0。然后令两个数进行按位与运算（`X & Y`），即可得到想要的数。

举个例子，比如我们要取二进制数 $X$=01101010~(2)~ 的末尾 4 位，则只需将 $X$=01101010~(2)~与 $Y$=00001111~(2)~ (末尾 4 位为 1，其余位为 0) 进行按位与运算，即 `01101010 & 00001111 == 00001010`。其结果 00001010就是我们想要的数（即二进制数 01101010~(2)~的末尾 4 位）。

##### 1.3 将指定位设置为 1

如果我们想要把一个二进制数 $X$ 中的某几位设置为 1，其余位置保留原值，则可以使用另一个二进制数$Y$，使得该二进制上对应选取位置为 1，其余位置为 0。然后令两个数进行按位或运算（`X | Y`），即可得到想要的数。

举个例子，比如我们想要将二进制数$X$=01101010~(2)~ 的末尾 4 位设置为 1，其余位置保留原值，则只需将$X$*=01101010~(2)~ 与 $Y$=00001111~(2)~（末尾 4 位为 1，其余位为0）进行按位或运算，即 `01101010 | 00001111 = 01101111`。其结果` 01101111` 就是我们想要的数（即将二进制数 01101010的末尾 4 位设置为 1，其余位置保留原值）。

##### 1.4 反转指定位

如果我们想要把一个二进制数$X$ 的某几位进行反转，则可以使用另一个二进制数 $Y$，使得该二进制上对应选取位置为 1，其余位置为 0。然后令两个数进行按位异或运算（`X ^ Y`），即可得到想要的数。

举个例子，比如想要将二进制数$X$=01101010~(2)~的末尾4位进行反转，则只需将 $X$=01101010~(2)~ 与 $Y$=00001111~(2)~（末尾 4 位为 1，其余位为 0）进行按位异或运算，即 `01101010 ^ 00001111 = 01100101`。其结果 01100101 就是我们想要的数（即将二进制数 $X$=01101010~(2)~ 的末尾 4 位进行反转）。

##### 1.5 交换两个数

通过按位异或运算可以实现交换两个数的目的（只能用于交换两个整数）。

```python
a, b = 10, 20
a ^= b
b ^= a
a ^= b
print(a, b)
```

##### 1.6 将二进制最右侧为 1 的二进位改为 0

如果我们想要将一个二进制数 $X$最右侧为 1 的二进制位改为 0，则只需通过 `X & (X - 1)` 的操作即可完成。

比如$X$=01101100~(2)~，$X−1$=01101011~(2)~，则 `X & (X - 1) == 01101100 & 01101011 == 01101000`，结果为01101000~(2)~（即将$X$最右侧为 1 的二进制为改为 0）。

##### 1.7 计算二进制中二进位为 1 的个数

从 1.6 中得知，通过 `X & (X - 1)` 我们可以将二进制 $X$ 最右侧为 1 的二进制位改为 0，那么如果我们不断通过 `X & (X - 1)` 操作，最终将二进制$X$变为 0，并统计执行次数，则可以得到二进制中二进位为 1 的个数。

具体代码如下：

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        cnt = 0
        while n:
            n = n & (n - 1)
            cnt += 1
        return cnt
```

##### 1.8 判断某数是否为 2 的幂次方

通过判断 `X & (X - 1) == 0` 是否成立，即可判断$X$是否为 2 的幂次方。

这是因为：

1. 凡是 2 的幂次方，其二进制数的某一高位为 1，并且仅此高位为 1，其余位都为 0。
2. 不是 2 的幂次方，其二进制数存在多个值为 1 的位。 

#### 2 位运算的常用操作总结

| 功能                                 | 位运算                            | 示例                      |
| ------------------------------------ | --------------------------------- | ------------------------- |
| **从右边开始，把最后一个 1改写成 0** | `x & (x - 1)`                     | `100101000 -> 100100000`  |
| **去掉右边起第一个 1 的左边**        | `x & (x ^ (x - 1))` 或 `x & (-x)` | `100101000 -> 1000`       |
| **去掉最后一位**                     | `x >> 1`                          | `101101 -> 10110`         |
| **取右数第 k 位**                    | `x >> (k - 1) & 1`                | `1101101 -> 1, k = 4`     |
| **取末尾 3 位**                      | `x & 7`                           | `1101101 -> 101`          |
| **取末尾 k 位**                      | `x & 15`                          | `1101101 -> 1101, k = 4`  |
| **只保留右边连续的 1**               | `(x ^ (x + 1)) >> 1`              | `100101111 -> 1111`       |
| **右数第 k 位取反**                  | `x ^ (1 << (k - 1))`              | `101001 -> 101101, k = 3` |
| **在最后加一个 0**                   | `x << 1`                          | `101101 -> 1011010`       |
| **在最后加一个 1**                   | `(x << 1) + 1`                    | `101101 -> 1011011`       |
| **把右数第 k 位变成 0**              | `x & ~(1 << (k - 1))`             | `101101 -> 101001, k = 3` |
| **把右数第 k 位变成 1**              | `x | (1 << (k - 1))`              | `101001 -> 101101, k = 3` |
| **把右边起第一个 0 变成 1**          | `x | (x + 1)`                     | `100101111 -> 100111111`  |
| **把右边连续的 0 变成 1**            | `x | (x - 1)`                     | `11011000 -> 11011111`    |
| **把右边连续的 1 变成 0**            | `x & (x + 1)`                     | `100101111 -> 100100000`  |
| **把最后一位变成 0**                 | `x | 1 - 1`                       | `101101 -> 101100`        |
| **把最后一位变成 11**                | `x | 1`                           | `101100 -> 101101`        |
| **把末尾 k 位变成 1**                | `x | (1 << k - 1)`                | `101001 -> 101111, k = 4` |
| **最后一位取反**                     | `x ^ 1`                           | `101101 -> 101100`        |
| **末尾 k 位取反**                    | `x ^ (1 << k - 1)`                | `101001 -> 100110, k = 4` |

#### 3 枚举子集

对于一个元素个数为 $n$ 的集合$S$来说，每一个位置上的元素都有选取和未选取两种状态。我们可以用数字 1 来表示选取该元素，用数字 0 来表示不选取该元素。

那么我们就可以用一个长度为$n$的二进制数来表示集合$S$ 或者表示 $S$ 的子集。其中二进制的每一个二进位都对应了集合中某一个元素的选取状态。对于集合中第 $i$ 个元素来说，二进制对应位置上的 1 代表该元素被选取，0代表该元素未被选取。

举个例子，比如长度为 5 的集合 $S$={5,4,3,2,1}，我们可以用一个长度为 5 的二进制数来表示该集合。

比如二进制数 11111~(2)~就表示选取集合的第 1 位、第 2 位、第 3 位、第 4 位、第 5 位元素，也就是集合 `{5,4,3,2,1}`，即集合 $S$ 本身。如下表所示：

| 集合 S 中元素位置 |  5   |  4   |  3   |  2   |  1   |
| :---------------- | :--: | :--: | :--: | :--: | :--: |
| 二进位对应值      |  1   |  1   |  1   |  1   |  1   |
| 对应选取状态      | 选取 | 选取 | 选取 | 选取 | 选取 |

再比如二进制数 10101~(2)~ 就表示选取集合的第 1 位、第 3 位、第 5 位元素，也就是集合`{5,3,1}`。如下表所示：

| 集合 S 中元素位置 |  5   |   4    |  3   |   2    |  1   |
| :---------------- | :--: | :----: | :--: | :----: | :--: |
| 二进位对应值      |  1   |   0    |  1   |   0    |  1   |
| 对应选取状态      | 选取 | 未选取 | 选取 | 未选取 | 选取 |

对于长度为$n$的集合 $S$ 来说，只需要枚举 0∼2^n^−1（共 2^n^ 种情况），即可得到集合 $S$ 的所有子集。

~~~python
class Solution:
    def subsets(self, S):                   # 返回集合 S 的所有子集
        n = len(S)                          # n 为集合 S 的元素个数
        sub_sets = []                       # sub_sets 用于保存所有子集
        for i in range(1 << n):             # 枚举 0 ~ 2^n - 1
            sub_set = []                    # sub_set 用于保存当前子集
            for j in range(n):              # 枚举第 i 位元素
                if i >> j & 1:              # 如果第 i 为元素对应二进位删改为 1，则表示选取该元素
                    sub_set.append(S[j])    # 将选取的元素加入到子集 sub_set 中
            sub_sets.append(sub_set)        # 将子集 sub_set 加入到所有子集数组 sub_sets 中
        return sub_sets                     # 返回所有子集
~~~

## 二分查找

### 二分查找左右边界

#### 左边界

> 循环结束后，`num[right + 1] == target`

~~~python
while left <= right:
    mid = left + (right - left) // 2
    if nums[mid] >= target:  # 因为是 >= 所以right会一直逼近左边界，因为当找到nums[mid] == target时，right是一直减小的
        right = mid - 1
    else:  
        left = mid + 1
~~~

#### 右边界

> 循环结束后，`nums[left - 1] == target`

~~~python 
while left <= right:
    mid = left + (right - left) // 2
    if nums[mid] > target:
        right = mid - 1
    else:  # 因为是 <= 所以left会一直逼近右边界，因为当找到nums[mid] == target时，left是一直增大的
        left = mid + 1
~~~

## 最大化最小值或最小化最大值

> 分析上边寻找`target`边界的代码：
>
> 1. 随着`left`和`right`的不断更新，`left`和`right`总是逼近使`nums[mid] ~= target`的位置
> 2. 而最后一次循环的条件是`left == right`，则有三种情况：
>    + 如果数组`nums`不包含`target`：
>      + 假设`nums[left == right]`落在`target`左边，那么对于上边左右边界的代码，最后一次更新的肯定是左边界`left`。因此`left`表示第一个大于`target`的数
>      + 反之，如果落在右边，最后一次更新的为右边界`right`。因此`right`表示第一次小于`target`的数字
>      + 因此`right + 1`表示第一个大于等于`target`的数字，`left - 1`表示第一个小于等于`target`的数字
>    + 如果数组`nums`包含`target`:
>      + 就跟上面寻找`target`的左右边界一样，`left`和`right`更新完毕后。`right + 1`表示`target`的左边界，即第一个大于等于`target`的位置。`left - 1`表示`target`的右边界，即第一个小于等于`target`的位置
> 3. 总结：
>    + 因此，为了综合`2`种讨论的几种情况。直接用`left - 1`表示第一个小于等于`target`的位置，`right + 1`表示第一个大于等于`target`的位置
