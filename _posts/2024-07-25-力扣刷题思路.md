---
layout: post
title: "力扣刷题思路"
date: 2024-07-25 12:00
categories: leetcode
background_image: "/assets/images/background.jpg"
tags: [leetcode, 刷题思路]
toc: true
author: 麻辣烫
---

##  31.下一个排列

题目链接[**力扣-31.下一个排列**](https://leetcode.cn/problems/next-permutation/description/)

```python
# 整体思路：
# 1、倒序寻找第一个升序所在的位置 i
# 2、然后从倒序遍历过的数字中，找出刚好大于位置 i 的数字，位置记为 j
# 3、交换i, j位置上的数字，因为原数组nums[i] > nums[j + 1]，那么交换位置后，数组nums[i+1:size]，也为降序
# 4、因为交换位置后，数组组成的数字高位已经变大很多，为了寻找下一个排列，则需要将交换后，i 位置往后的数字降序排列
```

## 32.最长有效括号

题目链接[力扣-32.最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

思路: 值得注意的是，在子问题3中，已经讨论了`s[i]`连续为`n`个`)`的问题，当为连续`n`个`)`时，遍历过的`dp[i - 1]，dp[i - 2] ... dp[i - n`]都已经在遍历时讨论过了

```python
# 1 初始化状态：
#   dp[i]表示以 i 为结尾的有效括号个数
# 1.1 子问题1，当s[i]为 ( 时，dp[i] = 0
# 1.2 子问题2，当s[i]为 ) 时，s[i - 1]为 ( ，那么dp[i]状态与dp[i - 2]有关
# 1.3 子问题3，当s[i]为 ( 时，s[i - 1]为 ) ，那么dp[i]状态与dp[i - 1] 和 s[i - dp[i - 1] - 1] 及 dp[i - dp[i - 1] - 2]有关
# 2、状态转移方程：
#   dp[i] = dp[i - 2] + 2   当s[i]为 ) 时，s[i - 1]为 (
#   dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2   当s[i] = ) 且 s[i - 1] = ) 且 s[i - dp[i - 1] -1] = ( 时
# 3、初始化：
#   当s[i] 为 (，dp[i] = 0
#               dp[0] = 0
# 4、运行顺序：
#   从左到右
```

## 33.搜索螺旋排序数组

题目链接[力扣-33.搜索螺旋排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)

思路：

````python
# 1、使用二分查找
# 2、在二分查找时，无论mid落在哪个位置，mid一定是处于某个有序的序列中的
# 3、那么先确定left 到 mid是否是有序序列，如果是的话，再在这个序列中搜索target
# 4、如果left 到 mid不是有序序列，那么mid 到 right肯定是有序序列，在mid到right的区间去搜索target和更新left和mid
````

## 34.在排序数组中查找元素的第一个和最后一个位置

题目链接[力扣-34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

思路：因为更新`right`时，右边界`right`总是在减小，所以合并`nums[mid] == target`这个条件，会逐渐逼近左边界。同理`left`逼近右边界

```python
# 思路：直接二分
# 1、当nums[mid] == target时，与搜索条件nums[mid] < target合并。那么左边界left会不停的逼近nums中等于target值的右边界
# 2、当nums[mid] == target时，与搜索条件nums[mid] > target合并。那么右边界right会不停的逼近nums中等于target值的左边界
```

## 39.组合总和

题目链接[力扣-39.组合总和](https://leetcode.cn/problems/combination-sum/)

```python
# 回溯
# 1、返回值：因为时组合问题，不需要返回值。使用path收集遍历过的nums[i]，等满足终止条件时，将path加入res
# 2、终止条件：终止条件为target == 0。
# 3、单层递归逻辑：遍历数组nums，同时target -= nums[i]。如果小于0，直接continue到下一个nums[j]，大于0则进入下一层递归。为了避免重复值，下层的 #    startIndex需要从i开始。从零开始会造成重复答案
```

## 42.接雨水

题目链接[力扣-42.接雨水](https://leetcode.cn/problems/trapping-rain-water/)

思路：双指针法是纵向直接一步到位求出`index`对应的水位有多深。单调栈是横向求出一个池塘不同水位能装多少水，然后累加起来求总和

```python
# 思路1：双指针法。
# 1）记录index位置左右两边的最大值，那么与左右两边最大值中的较小值的差，为该index位置的水位。
# 2）将水位求和，那么就是蓄水大小
# 3）因为水池中，可能会有砖头，石块。意思就是相邻比index位置大的位置，可能就是水池的砖头和石块，并不是池子的边界。所以需要index左右两边的最大值
# 思路2：单调栈。
# 1、维护一个单调递减栈，这样能保证index左边水位比index水位高。
# 2、在右边遇到一个比栈顶大的值，那么可以求出这层水位的含水量，(min(height[left], [right]) - height[index]) * (right - left)
```

## 46.全排列

题目链接[力扣-46.全排列](https://leetcode.cn/problems/permutations/description/)

思路：回溯

```python
# 核心是res怎么去掉重复的数字
# 1、如果不考虑数组遍历范围，那么res里面相同的数字会出现多次
# 2、如果使用index自增，那么小于index的数组值无法被取到
# 3、综上，只能改变nums，在下一次迭代之前将已加入path的nums值直接剔除
```

## 48.旋转图像

### 1.旋转矩阵的基本方法

1. **90° 顺时针旋转**：
   - **步骤1**：将矩阵转置（行列互换）。
   - **步骤2**：反转每一行。
2. **90° 逆时针旋转**：
   - **步骤1**：将矩阵转置。
   - **步骤2**：反转每一列。
3. **180° 旋转**：
   - 直接将矩阵中的元素对称交换。
4. **270° 顺时针旋转**（即90° 逆时针旋转）：
   - 可以通过90°顺时针旋转三次实现，或者按逆时针旋转的步骤进行。

### 2.旋转算法实现

以下是Python代码实现不同角度的矩阵旋转。

#### 2.1 90° 顺时针旋转

```python
def rotate_90_clockwise(matrix):
    n = len(matrix)
    # 矩阵转置
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # 每行反转
    for i in range(n):
        matrix[i].reverse()
    return matrix
```

#### 2.2 90° 逆时针旋转

```python
def rotate_90_counterclockwise(matrix):
    n = len(matrix)
    # 矩阵转置
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # 每列反转
    for j in range(n):
        for i in range(n // 2):
            matrix[i][j], matrix[n - 1 - i][j] = matrix[n - 1 - i][j], matrix[i][j]
    return matrix
```

#### 2.3 180° 旋转

```python
def rotate_180(matrix):
    n = len(matrix)
    for i in range(n):
        for j in range(n):
            if i < n // 2 or (i == n // 2 and j < n // 2):
                matrix[i][j], matrix[n - 1 - i][n - 1 - j] = matrix[n - 1 - i][n - 1 - j], matrix[i][j]
    return matrix
```

### 3.示例

假设我们有一个3x3的矩阵：

```
python复制代码matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# 顺时针旋转90°
print(rotate_90_clockwise(matrix))

# 逆时针旋转90°
print(rotate_90_counterclockwise(matrix))

# 旋转180°
print(rotate_180(matrix))
```

### 4.旋转角度依据

- **90° 顺时针**：元素 `(i,j)` 移动到 `(j,n−1−i)`。

  ① 转置：`(i, j) → (j, i)`

  ② 反转：`(j, i) → (j, n - 1 - i)`

  综上，从`(i, j)`移动到`(j, n - 1 -i)`，只需转置和反转两步

- **90° 逆时针**：元素 `(i,j)` 移动到 `(n−1−j,i)`。

- **180°**：元素 `(i,j)`移动到`(n−1−i,n−1−j)`。

## 49.字母异位词分组

```python
# 思路1：将数组中的每个字符串排序，然后作为字典的key。value为一个接收相同key值的字符串数组，遇到相同key就append
# 思路2：计数字符串，然后将字符串中每个字符和其计数组合成新字符串，例如a1b2c3，作为key
```

## 53.最大子数组和

题目链接[力扣-53.最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

```python
# 1、初始化状态：
#   dp[i]表示以nums[i]结束的连续序列的最大值
# 1.1 子问题：那么题目要求连续，那么状态只有两种，一种是nums[i]和index小于i的序列组合成和更大的序列，另一种是不和之前的序列组合，nums[i]单独成一个序列
# 2、状态转移方程
#   dp[i] = max(dp[i - 1] + nums[i], nums[i])
# 3、初始化状态：
#   dp[0] = nums[0]
# 4、运行顺序：
#   从左到右
```

## 55.跳跃游戏

题目链接[力扣-55.跳跃游戏](https://leetcode.cn/problems/jump-game/description/)

~~~python
# 思路1：
# 1、初始化状态
#   dp[i]表示能否跳跃到当前位置
# 1.1 子问题1：dp[i]状态与dp[0:i-1]有关
# 2、状态转移方程：
#   dp[i] = dp[j] and nums[j] >= (i - j)  j=0,1,...,i-1
# 3、初始值：
#   dp[0] = True
# 4、运行顺序：
#   从左到右。补充：如果j遍历从左到右，那么会出现超时的情况。因此将j从右到左遍历，增大找到使dp[i] = true的j的概率，提交通过
# 思路2：使用贪心算法
#   1、设置一个变量，记录遍历过的位置所能达到的最远位置。
#   2、如果最远位置小于当前位置i，那么表示最远也不可能达到当前位置i，直接返回false
~~~

## 56.合并区间

题目链接[力扣-56.合并区间](https://leetcode.cn/problems/merge-intervals/description/)

~~~python
# 思路：
# 1、按照左边界进行排序。
# 2、设立两个变量left, right分别记录合并后的左右边界，遍历intervals，更新右边界
# 3、当intervals[i]的左边界大于right时，记录下left, right。并更新intervals[i]记录的值为left和right
~~~

## 62.不同路径

题目链接[力扣-62.不同路径](https://leetcode.cn/problems/unique-paths/description/)

~~~python
# 1、初始化状态：
#   dp[i][j] 表示从左上角到当前格子有多少条路径
# 1.1 子问题1：
#   dp[i][j]来源只能来自左边和上边，且 i == 0 时，只能来自左边
# 2、状态转移方程：
#   dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
# 3、状态初始化：
#   dp[0][j] = 1, dp[i][0] = 1
# 4、运行顺序：
#   先m，后n
~~~

## 75.颜色分类

题目链接[力扣-75.颜色分类](https://leetcode.cn/problems/sort-colors/description/)

~~~python
# 双指针，数字0的指针index0，指向1序列的第一个位置，
# 数字1的指针index1指向1序列结束的下一个位置（即遍历到的最新的nums[i])
# 值得注意的是，判断nums[i]为0、1、2时，要用if elif，单独用if时，会造成二次交换
~~~

## 76.最小覆盖子串

题目链接[力扣-76.最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/)

~~~python
# 思路：滑动窗口
# 1、两个字典，一个字典A记录目标字符串t的字符计数情况。另一个字典B记录遍历过的字符的计数情况
# 2、设置变量match,left，假如字典B中某个字符subs计数B[subs] == A[subs]，那么match加一。
# 3、如果match == len(A)，那么表示完全匹配，计算i - left + 1的值与已记录符合题意子串长度作比较，记录较小子串
# 4、更新left
# 值得注意的是，当match == len(A)，更新left时，要注意B[subs] > A[subs]的情况。所以更新结束条件为while match == len(A)
~~~

## 78.子集

题目链接[力扣-78.子集](https://leetcode.cn/problems/subsets/description/)

~~~python
# 思路：回溯
# 注意下一层回溯起始位置为当前层遍历的位置 i + 1
~~~

## 79.单词搜索

题目链接[力扣-79.单词搜索](https://leetcode.cn/problems/word-search/description/)

~~~python
# 这是一道典型的深度优先搜索题
# 1、定义四个方向，和一个记录搜索路径的状态数组record。注意record记录的是当前层某一个方向A向下dfs时被搜索过的记录，当这个方向A搜索完成时，需要恢复record的状态。因为在该层换方向B向下搜索时，该位置只要不是上一层被搜索过且设置为True，在方向B向下搜索时是可以被搜索的。
# 2、不能直接返回递归调用的状态，因为这项相当于直接中断每一层的遍历
# 3、带返回值的递归，可以在当前层遍历完成后，再决定返回什么样的状态
class Solution:
    def exist(self, board, word):
        m, n = len(board), len(board[0])
        to = [[-1, 0], [1, 0], [0, 1], [0, -1]]
        size = len(word)
        for i in range(m):
            for j in range(n):
                if board[i][j] == word[0]:
                    index = 1
                    record = [[False] * n for _ in range(m)]
                    record[i][j] = True
                    if self.dfs(record, to, size, index, board, word, m, n, i, j):
                        return True
        return False

    def dfs(self, record, to, size, index, board, word, m, n, i, j):
        if index == size:
            return True
        for direction in to:  # 每一层遍历的方向
            x = i + direction[0]
            y = j + direction[1]
            if x < m and x > -1 and y > -1 and y < n and not record[x][y] and board[x][y] == word[index]:
                record[x][y] = True  # 表示当前方向往下dfs时，这个位置不能被检索了
                if self.dfs(record, to, size, index + 1, board, word, m, n, x, y):  # 这里不能直接return，不然中断方向的遍历
                    return True
                record[x][y] = False  # 记得恢复状态，因为换个方向往下搜索是可以搜这个格子的
        return False  # 每一层方向遍历完成后，决定返回什么状态
~~~

## 84.柱状图中的最大矩形

题目链接[力扣-84.柱状图中的最大矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

~~~python
# 思路1：暴力搜索，将每一个nums[i]向两边遍历，直到遇到比自己小的nums[left]和nums[right]才停止。w = right - left + 1, h = nums[i]
# 思路2：单调栈，定义一个单调递增栈。思路和思路1差不多，只不过单调栈会把遍历过的数字存储起来，不需要遍历第二遍
# 	1、碰到比stack[-1]小的数字开始出栈，index = stack.pop()，h = height[index], w = i - stack[-1] - 1
#	2、值得注意的是，w = i - index是不正确的，因为假如index和stack[-1]不为相邻元素，那么w会被减小
#	3、单调递增栈的出栈条件是遇到比栈顶更小的元素，如果数组为单调递增数组，那么无法出栈，所以可以在原数组末端nums.append(0)，保证出栈。
#	4、当栈中只剩下一个元素时，stack.pop()后，w = i - stack[-1] - 1 无法执行，所以可以在头位置加一个元素0，或者做一个else判断，为空则 w = i。因为pop之前stack中是有值的，而且这个值一定是数组中目前遍历到i位置的最小值，所以其宽度能直接扩展到i。
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights.append(0)
        size = len(heights)
        stack = []
        res = 0
        for i in range(size):
            while stack and heights[stack[-1]] > heights[i]:
                index = stack.pop()
                h = heights[index]
                if stack:
                    # 这里不能写w = i - index，因为index和stack[-1]可能不是连在一起的
                    w = i - stack[-1] - 1
                else:
                    # stack为空，那么肯定栈中元素都是大于零的，因为最后一个元素为0，如果前面有0元素，那么不会出栈
                    w = i
                res = max(res, w * h)
            stack.append(i)
        return res
~~~

## 85.最大矩形

题目链接[力扣-85.最大矩形](https://leetcode.cn/problems/maximal-rectangle/description/)

~~~python
# 思路：将matrix前i行都看做一个柱状图，沿用84题的思路。遍历每一行，将前i行的每一列值累加起来，就是84题中的高度。
# 1、当某一个matrix[i][j] == 0时，这一行的高度重置为0
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        m, n = len(matrix), len(matrix[0])
        heights = [0] * n
        res = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    heights[j] += 1
                else:
                    heights[j] = 0
            res = max(res, self.max_rec(copy.deepcopy(heights)))
        return res

    def max_rec(self, heights):
        max_res = 0
        stack = []
        heights.append(0)
        size = len(heights)
        for i in range(size):
            while stack and heights[stack[-1]] > heights[i]:
                index = stack.pop()
                h = heights[index]
                if stack:
                    w = i - stack[-1] - 1
                else:
                    w = i
                max_res = max(max_res, w * h)
            stack.append(i)
        return max_res
~~~

## 94.二叉树的种类

### 1. 普通二叉树 (Binary Tree)

**图示**：

```markdown
     1
    / \
   2   3
  / \   \
 4   5   6
```

**注意事项**：

- 每个节点最多有两个子节点。
- 节点的子节点可以是空的。

------

### 2. 满二叉树 (Full Binary Tree)

**图示**：

```markdown
     1
    / \
   2   3
  / \ / \
 4  5 6  7
```

**注意事项**：

- 每个节点要么没有子节点，要么有两个子节点。
- 完全填满每一层。

------

### 3. 完全二叉树 (Complete Binary Tree)

**图示**：

```markdown
     1
    / \
   2   3
  / \ / 
 4  5 6  
```

**注意事项**：

- 除了最后一层外，所有层上的节点都达到最大数目。
- 最后一层的节点尽可能地靠左排列。

------

### 4. 平衡二叉树 (Balanced Binary Tree)

**图示**：

```markdown
     3
    / \
   2   4
  /     \
 1       5
```

**注意事项**：

- 任意节点的左右子树高度差不超过1。
- 需要平衡操作来保持树的平衡。

------

### 5. 二叉搜索树 (Binary Search Tree, BST)

**图示**：

```markdown
     4
    / \
   2   6
  / \ / \
 1  3 5  7
```

**注意事项**：

- 对于树中的任意节点，其左子树上所有节点的值都小于该节点的值，其右子树上所有节点的值都大于该节点的值。
- 插入和删除操作需要保持这个性质。

------

### 6. 平衡二叉搜索树 (Balanced Binary Search Tree)

**图示**：

```markdown
     4
    / \
   2   6
  / \ / \
 1  3 5  7
```

**注意事项**：

- 同时满足平衡二叉树和二叉搜索树的性质。
- 常见的平衡二叉搜索树有AVL树和红黑树。

------

### 7. AVL树 (AVL Tree)

**图示**：

```markdown
     3
    / \
   2   4
  /     \
 1       5
```

**注意事项**：

- 任意节点的左右子树高度差不超过1。
- 插入和删除操作后可能需要进行旋转操作来保持平衡。

------

### 8. 红黑树 (Red-Black Tree)

**图示**：

```markdown
     4(B)
    /   \
   2(R)  6(R)
  / \   / \
 1(B) 3(B) 5(B) 7(B)
```

**注意事项**：

- 每个节点要么是红色，要么是黑色。
- 根节点是黑色。
- 红色节点不能有红色子节点（即红色节点的两个子节点必须是黑色）。
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
- 插入和删除操作后可能需要进行旋转和重新着色操作来保持红黑树性质。

------

### 9. 伸展树 (Splay Tree)

**图示**：

```markdown
     4
    / \
   2   5
  / \
 1   3
```

**注意事项**：

- 最近访问的节点会被旋转到根部。
- 伸展操作通过旋转将节点移动到根部，以加速后续访问。

------

### 10. Treap

**图示**：

```markdown
     5
    / \
   2   6
  / \
 1   3
```

**注意事项**：

- 同时满足二叉搜索树和堆的性质。
- 每个节点有一个优先级，优先级满足堆的性质（即父节点的优先级大于子节点的优先级）。

------

### 11. 堆 (Heap)

**图示**：

```markdown
    1
   / \
  2   3
 / \ / \
4  5 6  7
```

**注意事项**：

- 堆分为最大堆和最小堆。
- 最大堆：每个节点的值都大于或等于其子节点的值。
- 最小堆：每个节点的值都小于或等于其子节点的值。

------

### 12. 二叉堆 (Binary Heap)

**图示**：

```markdown
    1
   / \
  3   2
 / \ / \
7  6 5  4
```

**注意事项**：

- 一种堆结构，常用于实现优先队列。
- 满足完全二叉树的性质，节点按堆的性质排列。

------

### 13. 霍夫曼树 (Huffman Tree)

**图示**：

```markdown
      *
     / \
    *   E
   / \
  A   *
     / \
    B   C
```

**注意事项**：

- 用于霍夫曼编码，生成最优二叉树以实现数据压缩。
- 权重较小的节点离根较远。

------

### 14. 线段树 (Segment Tree)

**图示**：

```markdown
      18
    /   \
   7    11
  / \   / \
 3   4 5   6
```

**注意事项**：

- 用于解决区间查询问题。
- 可以高效地进行区间更新和区间查询。

------

### 15. 范例树 (Fenwick Tree/Binary Indexed Tree)

**图示**：

```markdown
       15
      / \
     7   8
    / \
   3   4
```

**注意事项**：

- 用于快速更新和查询前缀和。
- 通过维护部分和来实现高效查询和更新。

这些图示和注意事项涵盖了各类二叉树的基本概念和用途。具体应用中，选择合适的二叉树结构对于实现高效算法和数据处理非常重要。

## 96.不同的二叉搜索树

题目链接[力扣-96.不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)

~~~python
class Solution:
    def numTrees(self, n: int) -> int:
        """
        :param n:
        :return:
        思路：动态规划
        1、初始化状态：dp[n]表示n个节点能组成多少个搜素二叉树
        1.1、子问题1：当有n个节点时，从1 -> n 的每个节点分别当做根节点，
             肯定是不同的二叉树（节点值为1 -> n，所以根节点值肯定不同）
        1.2、子问题2：令F(i)表示以数字 i 为根节点的不同二叉搜索树的个数，则有G(n) = F(1) + F(2) + ... + F(n)
        1.3、子问题3：令 i 表示根节点，则F(i) = G(i - 1) * G(n - i)。G(i - 1)表示根节点为i的
             左子树有i - 1个节点，右子树有n - i个节点，那么左子树的种类肯定有G(i - 1)个，而树的个数
             与节点值无关，只与节点个数有关，所以右子树种类有G(n - i)个。那么两边子树组合种类为G(n - i) * G(i - 1)
        1.4、子问题4：结合1.3,1.2有G(n) = G(0)*G(n - 1) + G(1)*G(n - 2) + ... + G(n - 1)*G(0)
        2、状态转移方程：dp[i] = dp[0]*dp[i - 1] + dp[1]*dp[i - 2] + ... + dp[i - 1]*dp[0]
        2.1、据上式可以看出:
            1、当i - 1为偶数
            dp[i] = 2(dp[0]*dp[i - 1] + dp[1]*dp[i - 2] + ... + dp[(i - 1) // 2][(i - 1) // 2])
            2、当i - 1为奇数
            dp[i] = 2(dp[0]*dp[i - 1] + dp[1]*dp[i - 2] + ... + dp[(i - 2) // 2][(i - 2) // 2]) + dp[(i - 2) // 2 + 1][(i - 2) // 2 + 1]
        3、边界条件：当i为0表示无节点，1表示只有一个节点，那么这两种情况自然只有一种组合
            dp[0] = 1, dp[1] = 1
        4、运行顺序：0 -> n
        """
        dp = [0] * (n + 1)  # 不能预设为1，如果为1，每个dp[i]自加的时候都会多加1
        dp[0] = dp[1] = 1
        for i in range(2, n + 1):
            k = i // 2
            for j in range(1, k + 1):
                dp[i] += 2 * dp[j - 1] * dp[i - j]
            if i % 2 == 1:
                dp[i] += dp[i - k - 1] * dp[i - k - 1]

        return dp[-1]
~~~

## 98.验证二叉搜索树

题目链接[力扣-96.验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/solutions/)

中序遍历

~~~python
# 思路1：设置变量val，记录上一个节点的值，比较当前节点root.val和val的值，如果出现root.val <= val 那么返回False
# 思路2：设置前驱节点pre，用pre记录前一个节点的地址，比较前一个节点pre.val和当前节点root.val的值，如果出现root.val <= pre.val，那么返回False
# 思路1
class Solution:
    val = float('-inf')

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        left = self.isValidBST(root.left)
        if root.val > self.val:
            self.val = root.val
        else:
            return False
        right = self.isValidBST(root.right)
        return left and right
# 思路2   
class Solution:
    pre = None

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        left = self.isValidBST(root.left)
        if self.pre:
            if self.pre.val >= root.val:
                return False
        self.pre = root
        right = self.isValidBST(root.right)
        return left and right
~~~

## 101.对称二叉树

题目链接[力扣-101.对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)

~~~python
# 思路1：递归
# 	1、两棵相同的树一起遍历，第一棵树向左第二棵树向右
#	2、在前序的位置比较树的节点值情况
#	3、当两棵树节点值相等时，不能直接返回True，应该继续向下递归，比较子节点的值情况
# 思路2：层序遍历，层序判断是否为对称数组
~~~

~~~python
# 思路1：
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        return self.traverse(root, root)

    def traverse(self, root1, root2):
        if not root1 and not root2:
            return True
        elif not root1 or not root2:
            return False
        else:
            if root1.val != root2.val:
                return False
            left = self.traverse(root1.left, root2.right)
            right = self.traverse(root1.right, root2.left)
            return True if left and right else False

# 思路2
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        stack = [root]
        while stack:
            level = []
            temp_stack = []
            size = len(stack)
            for i in range(size):
                if stack[i]:
                    level.append(stack[i].val)
                    if stack[i].left:
                        temp_stack.append(stack[i].left)
                    else:
                        temp_stack.append(None)
                    if stack[i].right:
                        temp_stack.append(stack[i].right)
                    else:
                        temp_stack.append(None)
                else:
                    level.append(None)
            left, right = 0, size - 1
            while left <= right:
                if level[left] != level[right]:
                    return False
                left += 1
                right -= 1
            stack = temp_stack
        return True
# 思路2的写法2：画个二叉树的图就好理解。
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

            # Initialize a deque with the left and right children of the root
        queue = deque([(root.left, root.right)])

        while queue:
            left, right = queue.popleft()

            # If both are None, continue to the next pair
            if not left and not right:
                continue

            # If one is None and the other is not, it's not symmetric
            if not left or not right:
                return False

            # If the values are different, it's not symmetric
            if left.val != right.val:
                return False

            # Enqueue the children in the order that they should be compared
            queue.append((left.left, right.right))
            queue.append((left.right, right.left))

        return True
~~~

## 102.二叉树的遍历

### 二叉树的层序遍历

题目链接[力扣-102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

~~~python
# 思路：借助栈
# 1、节点入栈stack
# 2、遍历栈stack，建立一个临时栈temp，判断栈中的左子节点和右子节点分别存不存在，存在则入栈temp。
# 3、收集节点值，将临时栈赋值给stack
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        res = []
        stack = [root]
        while stack:
            sub_res = []
            temp_stack = []
            size = len(stack)
            for i in range(size):
                node = stack[i]
                if node.left:
                    temp_stack.append(node.left)
                if node.right:
                    temp_stack.append(node.right)
                sub_res.append(node.val)
            res.append(sub_res)
            stack = temp_stack
        return res
~~~

### 前中后遍历，非递归写法

#### 借助栈

> 1. 使用辅助栈，模拟递归调用的过程。
> 2. 特别注意的是终止循环条件，栈和节点有一个不为空就可以。因为在遍历到前驱节点的后一个节点时，栈肯定为空，但是树还有一半是没有遍历完的

> **前序遍历**

~~~python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []
        while stack or root:
            if root:
                res.append(root.val)
                stack.append(root)
                root = root.left
            else:
                temp = stack.pop()
                root = temp.right
        return res
~~~

> **中序遍历**

~~~python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                temp = stack.pop()
                res.append(temp.val)
                root = temp.right
        return res
~~~

> **后续遍历**
>
> 1. 特殊之处在于需要确认右子节点被访问过后，再访问根节点。
> 2. 设定一个变量跟踪访问过的节点（从stack里pop出来的，表示已经访问过了）

~~~python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []
        last_visit = None
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                if stack[-1].right and stack[-1].right != last_visit:
                    root = stack[-1].right
                else:
                    last_visit = stack.pop()
                    res.append(last_visit.val)
        return res
~~~

#### morris算法

> 1. morris算法其实是将二叉树变为单链表的一个过程，按照前中后遍历的顺序，将左子树整体移动到父节点的左边或者右边。
> 2. 对每个节点重复这个过程。
> 3. 下图就是一个中序遍历时，右子树整体挪到前驱节点 `5` 的一个过程

<img src="/assets/images/Snipaste_2024-08-09_16-57-08.png" alt="morris中序" style="zoom:80%;" />

> **前序遍历**
>
> 1. 顺序 root -> left -> right
> 2. 那么先取根节点，然后将左子树移动到右子树，再将右子树赋值给前驱节点`5`

~~~python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        while root:
            res.append(root.val)
            pre = root
            if root.left:
                temp = root.right
                root.right = root.left
                while pre.right:
                    pre = pre.right
                pre.right = temp
            root.left = None
            root = root.right
        return res
~~~

> **中序遍历**
>
> 1. 顺序 root -> left -> right
> 2. 将包含根节点在内的右边节点移动到前驱节点 `5`
> 3. 接着节点持续左移，直到遇到无左子节点，然后开始收集结果，并开始遍历右节点。其实当无左子节点时，左子树已经形成单链表了。
> 4. 接着开始收集左子树的单链表
> 5. 直到遇到右子树中具有左孩子的节点，又开始1、2、3、4，最终完成遍历

~~~python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        while root:
            pre = root
            if pre.left:
                pre = pre.left
                temp = pre
                while pre.right:
                    pre = pre.right
                pre.right = root
                root.left = None
                root = temp
            else:
                res.append(root.val)
                root = root.right
        return res
~~~

> **后续遍历**：太复杂了，仅作参考。一般Morris算法只做前中序遍历
>
> [Morris后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/solutions/431066/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/)

## 105.从前序遍历和中序遍历构造二叉树

> 题目链接[力扣-105.从前序和中序序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

~~~python
# 思路1：递归 + 分治
# 	1、对于前序遍历而言，当前节点A后一个值一定是当前节点A的左子节点值或者右子节点值。因为前序遍历顺序为 root -> left -> right
#	2、对于中序遍历而言，以前序遍历中节点值A做切割点，那么切割点A左边的序列形成A节点的左子树，右边的序列形成右子树
#	3、通过以上两点，可以用中序遍历做辅助，判断节点A是否有左右节点即可。如果以节点A做切割的中序遍历左边序列为空，那么A.left = None，如果不为空则将前序遍历A节点值的后一个值赋值给A.left
class Solution:
    index = 0

    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not inorder:
            return None
        res = TreeNode(preorder[self.index])
        root_val = preorder[self.index]
        clip = inorder.index(root_val)
        self.index += 1
        res.left = self.buildTree(preorder, inorder[0:clip])
        res.right = self.buildTree(preorder, inorder[clip + 1:])
        return res
# 思路二：做辅助栈
# 1、遍历preorder序列，将prorder[0]入栈
# 2、栈中入栈未添加右子节点的父节点，设置变量index记录中序遍历序列里节点的位置
# 3、判断栈顶节点值是否和中序遍历序列inorder[index]相等
# 	3.1 如果不相等，证明该前序遍历的节点值preorder[stack[-1]]左子节点为inorder[index]
#	3.2 如果相等，那证明stack[-1]对应的节点已经无左子节点了，因为如果有左子节点，其子节点组成的序列一定在inorder[stack[-1]]节点的左边。
# 	3.3 当相等后，开始出栈stack.pop()，直到preorder[stack[-1]] != inorder[index]。那么表示找到了最后一个pop出的节点的右子节点node
#	3.4 对于3.3，因为如果遍历到的node为出栈的 preorder[stack[-1]] == inorder[index] 除最后一个出栈节点之外的其他节点的右子节点，那么表示最后一个出栈的右子节点还有左孙子节点（左子树）没有遍历构建完成。但是在中序遍历中，从preorder[stack[-1]] == inorder[index]开始pop，直到最后一个pop出的节点，都能看出来已经没有左子孙节点能够构建了。所以node一定是最后一个pop出节点的右子节点。
# 4、将node入栈，继续构建右边子树，从node开始重复1、2、3步骤
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        root = TreeNode(preorder[0])
        stack = [root]
        inorder_index = 0
        for i in range(1, len(preorder)):
            node = TreeNode(preorder[i])
            if stack[-1].val != inorder[inorder_index]:
                stack[-1].left = node
            else:
                temp = None
                while stack and stack[-1].val == inorder[inorder_index]:
                    temp = stack.pop()
                    inorder_index += 1
                temp.right = node
            stack.append(node)
        return root
~~~

## 106.从中序遍历和后续遍历构造二叉树

题目链接：[力扣-106.从中序遍历和后续遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

~~~python
# 思路1：递归
# 	1、跟105不同点在于，后续遍历根节点放在了序列末端，那么我们需要倒序遍历后序序列。
#	2、寻找倒序遍历节点在中序序列中的index，以此做切割中序序列。
#	3、因为是后续遍历，所以节点左边的序列值为先为右子节点，再为左子节点。那么先构造右子树，再构造左子树。
#	4、当2中切割的左右序列为空，则返回None
#	5、重复1、2、3、4
class Solution:
    index = 0
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not inorder:
            return None
        root = TreeNode(postorder[-1])
        clip = inorder.index(postorder[-1])
        postorder.pop()
        root.right = self.buildTree(inorder[clip + 1:], postorder)
        root.left = self.buildTree(inorder[0:clip], postorder)
        return root
# 思路2：迭代
#	1、沿用104的思路，中序遍历为 left -> root -> right，后序遍历为 left -> right -> root。
#	2、所以当后序的值从末端开始遍历入栈时，栈中顺序为root -> right，那么中序也倒着遍历就为right -> root，这跟stack出栈顺序一致。所以inorder_index的初始值为size - 1
#	3、根据1、2，当stack[-1].val != inorder[inorder_index]，那么证明栈顶元素还有右子节点，所以stack[-1].right = node
#	4、当stack[-1].val == inorder[inorder_index]，证明右子节点构建完毕，开始pop
#	5、入栈node，重复1、2、3、4、5
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        root = TreeNode(postorder[-1])
        stack = [root]
        size = len(postorder)
        inorder_index = size - 1
        for i in range(size - 2, -1, -1):
            node = TreeNode(postorder[i])
            if stack[-1].val != inorder[inorder_index]:
                stack[-1].right = node
            else:
                temp = None
                while stack and stack[-1].val == inorder[inorder_index]:
                    temp = stack.pop()
                    inorder_index -= 1
                temp.left = node
            stack.append(node)
        return root
~~~

## 114.二叉树展开为链表

题目链接：[力扣-114.二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/)

### 思路1：使用递归

> 1. 创建一个全局变量res，再创建一个前驱节点pre。然后将res赋值给pre。[^1]
> 2. 使用前序遍历，在前序遍历中，将root地址赋值给pre，并让pre指针指向自己的右子节点。[^2]
> 3. 定义两个变量left和right，分别保存root节点的左右子节点，防止被下一层递归篡改。[^3]

#### 错误示范

> 在每一次使用完root时，未断开pre和root的链接，在下一层迭代时，root左右子节点地址被修改，造成错误结果

~~~python
class Solution:
    res = TreeNode()
    pre = res

    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        self.tranverse(root)
        root = self.res.right

    def tranverse(self, root):
        if not root:
            return
        self.pre.right = root  # 这里在下一层，相当把上一层的root的左子节点或右子节点赋值给root.right，即root.right = root.left
        self.pre = self.pre.right  # 这里相当于让self.pre = root，而且没有断开self.pre的左子节点
        self.tranverse(root.left)  # 下面两步都是直接在root上遍历左右子节点，但是在下一层时，root的左右子节点已经被修改了
        self.tranverse(root.right)
~~~

#### 正确示范

> 1. 在使用完root后，断开root和下层递归的连接。保证树递归的正确性
> 2. 断开pre和left的链接，保证不修改root，也保证了pre的单链表特性

~~~python
class Solution:
    res = TreeNode()
    pre = res
    aa = None

    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        self.tranverse(root)
        root = self.res.right

    def tranverse(self, root):
        if not root:
            return
        self.pre.right = root
        self.pre.left = None
        # self.aa = root
        self.pre = self.pre.right
        left = root.left
        right = root.right
        self.tranverse(left)
        self.tranverse(right)
~~~

### 思路2：利用树的前序遍历，非递归(morris算法)

> 1. 前序遍历的本质是根左右，那么可以让每个节点只有右节点，无左子节点。
> 2. 使用临时变量temp存储右子节点，然后让遍历到的节点pre的左子节点覆盖右子节点。即pre.right = pre.left
> 3. 让前驱节点[^ 4]node.right = temp
> 4. 断开pre节点的左子树，并让pre指向自己的右子节点
> 5. 重复1、2、3、4直到遍历到最后一个节点pre == None

~~~python
class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        pre = root
        while pre:
            forward = pre
            if pre.left:
                temp = pre.right
                pre.right = pre.left
                while forward.right:
                    forward = forward.right
                forward.right = temp
            pre.left = None
            pre = pre.right
~~~

### 思路3：反向思考，递归

> 1. 前序遍历，使用一个临时节点记录遍历过的node，在递归返回上一层时，将root.right = node。但这样做，会使得root的右子根节点断开，这样右子树就没法递归遍历。
> 2. 逆向思维，前序遍历为根左右，那么可以交换顺序倒着遍历，右左根，这样先遍历右左节点，最后考虑根节点。这样在离开左右节点时，root左右节点已经不影响遍历了，而且倒着建立单链表，最后返回的root就是正确的链表头节点。
> 3. 离开左右节点时，断开左子节点，让离开的root变为单链表

~~~python
class Solution:
    pre = None

    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        self.flatten(root.right)
        self.flatten(root.left)
        root.right = self.pre
        root.left = None
        self.pre = root
~~~

## 买卖股票的最佳时机

**注意**：`dp[1][i]`表示不持股时的最大利润，不够买股票也是不持股的一种状态，因此对于`dp[1][0]`来讲，其初始化值一定是 `0`

### 121.买卖股票的最佳时机 $\mathrm{I}$

题目链接：[力扣-121。买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/) 

> 思路：维护一个price最小值和一个卖出的最大值profit

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price = prices[0]
        max_profit = 0
        for price in prices:
            min_price = min(min_price, price)
            max_profit = max(max_profit, price - min_price)
        return max_profit
~~~

### 122.买卖股票的最佳时机 $\mathrm{II}$

题目链接：[力扣-122.买卖股票的最佳时机 $\mathrm{II}$](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

####  错误思路

> 思路：动态规划
>
> 1. 初始化状态：dp[i]表示遍历到i时，最大收益
>
>    + 子问题1：每天其实就三个状态，买入、卖出、啥也不干
>
>    * 子问题2：用dp[0]、dp[1]、dp[2]分别表示三个状态
>
> 2. 状态转移方程：
>
>    * `dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])`
>    * `dp[1][i] = dp[0][i - 1] + prices[i]`
>    * `dp[2][i] = max(dp[0][i - 1], dp[1][i - 1], dp[2][i - 1])`
>
> 3. 值初始化：
>
>    * `dp[0][0] = -prices[0]`
>    * `dp[0][1] = 0`
>    * `dp[0][2] = 0`
>
> 4. 运行顺序：从左到右
>
> 总结：
>
> 1. 状态`dp[2][i]`定义太模糊，该状态无法确认是持有股票还是未持有股票，因此未无效状态
> 2. 在买入和卖出更新状态时，发现用不到状态`dp[2][i]`，但是什么动作都不做这个状态肯定是存在的
> 3. 因此思路是错误的

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(3)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        dp[2][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])
            dp[1][i] = dp[0][i - 1] + prices[i]
            dp[2][i] = max(dp[0][i - 1], dp[1][i - 1], dp[2][i - 1])
        return max(dp[0][-1], dp[1][-1], dp[2][-1])
~~~

#### 正确思路

> 1. 初始化状态：
>    - 修正`dp[0][i]`状态为持股时所持最大金额，`dp[1][i]`状态为不持股所持最大金额
> 2. 状态转移方程：
>    - `dp[0][i] = max(dp[0][i - 1], dp[1][i] - prices[i])`   注意`dp[0][i - 1]`表示今天啥也不干，就保持昨天状态。
>    - `dp[1][i] = max(dp[1][i - 1], dp[0][i] + prices[i])`   注意`dp[1][i - 1]`表示今天啥也不干，就保持昨天状态。
> 3. 状态初始化：
>    + `dp[0][0] = -prices[0]`
>    + `dp[1][0]` = 0
> 4. 运行顺序：
>    + 从左到右
> 5. 从`2`可以看出，正确思路定义的状态是包含了啥也不干的状态的

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])
            dp[1][i] = max(dp[0][i - 1] + prices[i], dp[1][i - 1])
        return dp[1][-1]
~~~

### 123.买卖股票的最佳时机 $\mathrm{III}$

题目链接：[力扣-123.买卖股票的最佳时机$\mathrm{III}$](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/)

> 1. 初始化状态：
>    + `dp[0][i]`表示第一次持有股票时，存款最大金额
>    + `dp[1][i]`表示第一次不持股票时，存款最大金额
>    + `dp[2][i]`表示第二次持有股票时，存款最大金额
>    + `dp[3][i]`表示第二次不持股票时，存款最大金额
> 2. 动态转移方程：
>    + `dp[0][i] = max(dp[0][i - 1], -prices[i])`
>    + `dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prcies[i])`
>    + `dp[2][i] = max(dp[2][i - 1], dp[1][i - 1] - prices[i])`
>    + `dp[3][i] = max(dp[3][i - 1], dp[2][i - 1] + prices[i])`
> 3. 状态初始化：**有个隐含条件，当天买入可以当天卖出。**
>    + `dp[0][0] = -prices[0]`
>    + `dp[1][0] = 0`
>    + `dp[2][0] = -prices[0]`
>    + `dp[3][0] = 0`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(4)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        dp[2][0] = -prices[0]
        dp[3][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], -prices[i])
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])
            dp[2][i] = max(dp[2][i - 1], dp[1][i - 1] - prices[i])
            dp[3][i] = max(dp[3][i - 1], dp[2][i - 1] + prices[i])
        return dp[3][-1]
~~~

### 188.买卖股票的最佳时机 $\mathrm{IV}$

题目链接：[力扣-188.买卖股票的最佳时机 $\mathrm{IV}$](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

> 1. 初始化状态：
>    + 题目中要求最多交易次数为k，其实状态分析和123题分析是一样的。
>    + 按照`123`题分析，那么总共有 $2*k$ 个状态，记为`n`个状态。
>    + 那么可以写个循环，直接给n个状态赋值
>    + 当`j为偶数 j -> 0:n`，则表示持有股票的最大利润
>    + 当`j为奇数 j -> 0:n`，则表示不持有股票的最大利润
> 2. 状态转移方程：
>    + 当 `j == 0`时，`dp[0][i] = max(dp[0][i - 1], -prices[i])`
>    + 当`j % 2 == 1`时，`dp[j][i] = max(dp[j][i - 1], dp[j - 1][i - 1] + prices[i])` 
>    + 当`j % 2 == 0`时，`dp[j][i] = max(dp[j][i - 1], dp[j - 1][i - 1] - prices[i])` 
> 3. 初始化数组：
>    + 当`j % 2 == 0`时，`dp[j][0] = -prices[i]`
>    + 当`j % 2 == 1`时,`dp[j][0] = 0`
> 4. 执行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        size = len(prices)
        status_size = 2 * k
        dp = [[0] * size for _ in range(status_size)]
        for i in range(status_size):
            if i % 2 == 0:
                dp[i][0] = -prices[0]
            else:
                dp[i][0] = 0
        for i in range(1, size):
            k = 0
            while k < status_size:
                if k == 0:
                    dp[k][i] = max(dp[k][i - 1], - prices[i])
                elif k % 2 == 0:
                    dp[k][i] = max(dp[k][i - 1], dp[k - 1][i - 1] - prices[i])
                else:
                    dp[k][i] = max(dp[k][i - 1], dp[k - 1][i - 1] + prices[i])
                k += 1
        return dp[status_size - 1][-1]
~~~

### 309.买卖股票的最佳时机含冷冻期

题目链接：[力扣-309.买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

> 1. 初始化状态：
>    + 跟`123`题状态一致，只是多了一个冷冻期
>    + 当考虑冷冻期时，持有股票的状态只能从前天的状态转移过来
> 2. 状态转移方程：
>    + `dp[0][i] = max(dp[0][i - 1], dp[1][i - 2])`
>    + `dp[1][i] = max(dp[1][i - 1], dp[0][i - 1])`
>    + 注意`dp[0][i]`的状态方程较`123`题有所变化 
> 3. 数组初始化：
>    + `dp[0][0] = -prices[0]`
>    + `dp[1][0] = 0`
>    + `dp[0][1] = max(dp[0][0], -prices[1])`
>    + `dp[1][1] = max(dp[1][0], dp[0][0] + prices[1])`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        if size == 1:
            return 0
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        dp[0][1] = max(dp[0][0], -prices[1])
        dp[1][1] = max(dp[1][0], dp[0][0] + prices[1])
        for i in range(2, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 2] - prices[i])
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])
        return dp[1][-1]
~~~

### 714. 买卖股票的最佳时机含手续费

题目链接：[力扣-714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)

> 1. 初始化状态：
>    + 跟`123`定义的状态一致，只需要在购买时多减去所交的税即可
>    + 注意数组初始化时，定义的是不持股时的**最大**利润
>    + 当最后输出结果小于`0`时，可以选择不买入也不卖出，那么利润为`0`
> 2. 状态转移方程：
>    + `dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i] - fee)`
>    + `dp[1][i] = max(dp[1][i - 1]`, $\textcolor{red}{dp[0][i - 1] + prices[i]}$`)`
> 3. 数组初始化：
>    + `dp[0][0] = -prices[0] - fee`
>    + ~~`dp[1][0] = -fee`~~这里的初始化是错误的，`dp[1][i]`表示不持股时的最大利润，不够买股票也是不持股的一种状态，因此对于`dp[1][0]`来讲，其初始化值一定是 `0`
>    + `dp[1][0] = 0`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0] - fee
        dp[1][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i] - fee)
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])
        return dp[1][-1] if dp[1][-1] > 0 else 0
~~~

> 1. 考虑另外一种交税方式，在卖出时交税。这样在初始化数组时，就不用考虑`dp[1][0]`的特殊情况了
>
> 2. 状态转移方程：注意$\textcolor{red}{**红色部分的变化**}$
>
>    + `dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])`
>    + `dp[1][i] = max(dp[1][i - 1]`, $\textcolor{red}{dp[0][i - 1] + prices[i] - fee}$`)`
>
> 3. 状态初始化：
>
>    + `dp[0][0] = -prices[0]`
>
>    + `dp[1][0] = 0`

~~~python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i] - fee)
        return dp[1][-1] if dp[1][-1] > 0 else 0
~~~



[^1]: pre和res都是在class中定义，使用self.pre和self.res调用
[^2]: 这里值得注意的是，需要将pre的左子节点断开，再将pre指向右子节点。这里断开左子节点是上一层root的左子节点，因为self.pre保存的是上一层root的值。有两个意思：一是pre必须为单链表，不能有左子节点，二是如果pre继续存在左子节点，那么在递归返回遍历right时，会因为root存在错误的左子节点，造成重复遍历。
[^3]: 因为在下一轮递归的时候，root的右子树会被改变，相当于让root的右子树直接被自己的左子树覆盖，所以需要在这一层保存正确的地址，确认遍历的是正确的树结构。之所以能保证正确，是因为root左右子树是在下一层才会被修改，而当前层root的左右子树是正确的地址，所以left和right其实是在被修改前就拿到了正确的未被修改的地址的（领先self.pre修改root就拿到了正确地址）
[^4]: 前驱节点指的二叉树遍历（前序、中序、后序）中，挨着根节点的那个节点。
