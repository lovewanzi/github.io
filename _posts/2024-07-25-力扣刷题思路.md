---
layout: post
title: "力扣刷题思路"
date: 2024-07-25 12:00
categories: leetcode
background_image: "/assets/images/background.jpg"
tags: [leetcode, 刷题思路]
toc: true
author: 麻辣烫
---

##  31.下一个排列

题目链接[**力扣-31.下一个排列**](https://leetcode.cn/problems/next-permutation/description/)

```python
# 整体思路：
# 1、倒序寻找第一个升序所在的位置 i
# 2、然后从倒序遍历过的数字中，找出刚好大于位置 i 的数字，位置记为 j
# 3、交换i, j位置上的数字，因为原数组nums[i] > nums[j + 1]，那么交换位置后，数组nums[i+1:size]，也为降序
# 4、因为交换位置后，数组组成的数字高位已经变大很多，为了寻找下一个排列，则需要将交换后，i 位置往后的数字降序排列
```

## 32.最长有效括号

题目链接[力扣-32.最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

思路: 值得注意的是，在子问题3中，已经讨论了`s[i]`连续为`n`个`)`的问题，当为连续`n`个`)`时，遍历过的`dp[i - 1]，dp[i - 2] ... dp[i - n`]都已经在遍历时讨论过了

```python
# 1 初始化状态：
#   dp[i]表示以 i 为结尾的有效括号个数
# 1.1 子问题1，当s[i]为 ( 时，dp[i] = 0
# 1.2 子问题2，当s[i]为 ) 时，s[i - 1]为 ( ，那么dp[i]状态与dp[i - 2]有关
# 1.3 子问题3，当s[i]为 ( 时，s[i - 1]为 ) ，那么dp[i]状态与dp[i - 1] 和 s[i - dp[i - 1] - 1] 及 dp[i - dp[i - 1] - 2]有关
# 2、状态转移方程：
#   dp[i] = dp[i - 2] + 2   当s[i]为 ) 时，s[i - 1]为 (
#   dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2   当s[i] = ) 且 s[i - 1] = ) 且 s[i - dp[i - 1] -1] = ( 时
# 3、初始化：
#   当s[i] 为 (，dp[i] = 0
#               dp[0] = 0
# 4、运行顺序：
#   从左到右
```

## 33.搜索螺旋排序数组

题目链接[力扣-33.搜索螺旋排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)

思路：

````python
# 1、使用二分查找
# 2、在二分查找时，无论mid落在哪个位置，mid一定是处于某个有序的序列中的
# 3、那么先确定left 到 mid是否是有序序列，如果是的话，再在这个序列中搜索target
# 4、如果left 到 mid不是有序序列，那么mid 到 right肯定是有序序列，在mid到right的区间去搜索target和更新left和mid
````

## 34.在排序数组中查找元素的第一个和最后一个位置

题目链接[力扣-34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

思路：因为更新`right`时，右边界`right`总是在减小，所以合并`nums[mid] == target`这个条件，会逐渐逼近左边界。同理`left`逼近右边界

```python
# 思路：直接二分
# 1、当nums[mid] == target时，与搜索条件nums[mid] < target合并。那么左边界left会不停的逼近nums中等于target值的右边界
# 2、当nums[mid] == target时，与搜索条件nums[mid] > target合并。那么右边界right会不停的逼近nums中等于target值的左边界
```

## 39.组合总和

题目链接[力扣-39.组合总和](https://leetcode.cn/problems/combination-sum/)

```python
# 回溯
# 1、返回值：因为时组合问题，不需要返回值。使用path收集遍历过的nums[i]，等满足终止条件时，将path加入res
# 2、终止条件：终止条件为target == 0。
# 3、单层递归逻辑：遍历数组nums，同时target -= nums[i]。如果小于0，直接continue到下一个nums[j]，大于0则进入下一层递归。为了避免重复值，下层的 #    startIndex需要从i开始。从零开始会造成重复答案
```

## 42.接雨水

题目链接[力扣-42.接雨水](https://leetcode.cn/problems/trapping-rain-water/)

思路：双指针法是纵向直接一步到位求出`index`对应的水位有多深。单调栈是横向求出一个池塘不同水位能装多少水，然后累加起来求总和

```python
# 思路1：双指针法。
# 1）记录index位置左右两边的最大值，那么与左右两边最大值中的较小值的差，为该index位置的水位。
# 2）将水位求和，那么就是蓄水大小
# 3）因为水池中，可能会有砖头，石块。意思就是相邻比index位置大的位置，可能就是水池的砖头和石块，并不是池子的边界。所以需要index左右两边的最大值
# 思路2：单调栈。
# 1、维护一个单调递减栈，这样能保证index左边水位比index水位高。
# 2、在右边遇到一个比栈顶大的值，那么可以求出这层水位的含水量，(min(height[left], [right]) - height[index]) * (right - left)
```

## 46.全排列

题目链接[力扣-46.全排列](https://leetcode.cn/problems/permutations/description/)

思路：回溯

```python
# 核心是res怎么去掉重复的数字
# 1、如果不考虑数组遍历范围，那么res里面相同的数字会出现多次
# 2、如果使用index自增，那么小于index的数组值无法被取到
# 3、综上，只能改变nums，在下一次迭代之前将已加入path的nums值直接剔除
```

## 48.旋转图像

### 1.旋转矩阵的基本方法

1. **90° 顺时针旋转**：
   - **步骤1**：将矩阵转置（行列互换）。
   - **步骤2**：反转每一行。
2. **90° 逆时针旋转**：
   - **步骤1**：将矩阵转置。
   - **步骤2**：反转每一列。
3. **180° 旋转**：
   - 直接将矩阵中的元素对称交换。
4. **270° 顺时针旋转**（即90° 逆时针旋转）：
   - 可以通过90°顺时针旋转三次实现，或者按逆时针旋转的步骤进行。

### 2.旋转算法实现

以下是Python代码实现不同角度的矩阵旋转。

#### 2.1 90° 顺时针旋转

```python
def rotate_90_clockwise(matrix):
    n = len(matrix)
    # 矩阵转置
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # 每行反转
    for i in range(n):
        matrix[i].reverse()
    return matrix
```

#### 2.2 90° 逆时针旋转

```python
def rotate_90_counterclockwise(matrix):
    n = len(matrix)
    # 矩阵转置
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # 每列反转
    for j in range(n):
        for i in range(n // 2):
            matrix[i][j], matrix[n - 1 - i][j] = matrix[n - 1 - i][j], matrix[i][j]
    return matrix
```

#### 2.3 180° 旋转

```python
def rotate_180(matrix):
    n = len(matrix)
    for i in range(n):
        for j in range(n):
            if i < n // 2 or (i == n // 2 and j < n // 2):
                matrix[i][j], matrix[n - 1 - i][n - 1 - j] = matrix[n - 1 - i][n - 1 - j], matrix[i][j]
    return matrix
```

### 3.示例

假设我们有一个3x3的矩阵：

```
python复制代码matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# 顺时针旋转90°
print(rotate_90_clockwise(matrix))

# 逆时针旋转90°
print(rotate_90_counterclockwise(matrix))

# 旋转180°
print(rotate_180(matrix))
```

### 4.旋转角度依据

- **90° 顺时针**：元素 `(i,j)` 移动到 `(j,n−1−i)`。

  ① 转置：`(i, j) → (j, i)`

  ② 反转：`(j, i) → (j, n - 1 - i)`

  综上，从`(i, j)`移动到`(j, n - 1 -i)`，只需转置和反转两步

- **90° 逆时针**：元素 `(i,j)` 移动到 `(n−1−j,i)`。

- **180°**：元素 `(i,j)`移动到`(n−1−i,n−1−j)`。

## 49.字母异位词分组

```python
# 思路1：将数组中的每个字符串排序，然后作为字典的key。value为一个接收相同key值的字符串数组，遇到相同key就append
# 思路2：计数字符串，然后将字符串中每个字符和其计数组合成新字符串，例如a1b2c3，作为key
```

## 53.最大子数组和

题目链接[力扣-53.最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

```python
# 1、初始化状态：
#   dp[i]表示以nums[i]结束的连续序列的最大值
# 1.1 子问题：那么题目要求连续，那么状态只有两种，一种是nums[i]和index小于i的序列组合成和更大的序列，另一种是不和之前的序列组合，nums[i]单独成一个序列
# 2、状态转移方程
#   dp[i] = max(dp[i - 1] + nums[i], nums[i])
# 3、初始化状态：
#   dp[0] = nums[0]
# 4、运行顺序：
#   从左到右
```

## 55.跳跃游戏

题目链接[力扣-55.跳跃游戏](https://leetcode.cn/problems/jump-game/description/)

~~~python
# 思路1：
# 1、初始化状态
#   dp[i]表示能否跳跃到当前位置
# 1.1 子问题1：dp[i]状态与dp[0:i-1]有关
# 2、状态转移方程：
#   dp[i] = dp[j] and nums[j] >= (i - j)  j=0,1,...,i-1
# 3、初始值：
#   dp[0] = True
# 4、运行顺序：
#   从左到右。补充：如果j遍历从左到右，那么会出现超时的情况。因此将j从右到左遍历，增大找到使dp[i] = true的j的概率，提交通过
# 思路2：使用贪心算法
#   1、设置一个变量，记录遍历过的位置所能达到的最远位置。
#   2、如果最远位置小于当前位置i，那么表示最远也不可能达到当前位置i，直接返回false
~~~

## 56.合并区间

题目链接[力扣-56.合并区间](https://leetcode.cn/problems/merge-intervals/description/)

~~~python
# 思路：
# 1、按照左边界进行排序。
# 2、设立两个变量left, right分别记录合并后的左右边界，遍历intervals，更新右边界
# 3、当intervals[i]的左边界大于right时，记录下left, right。并更新intervals[i]记录的值为left和right
~~~

## 62.不同路径

题目链接[力扣-62.不同路径](https://leetcode.cn/problems/unique-paths/description/)

~~~python
# 1、初始化状态：
#   dp[i][j] 表示从左上角到当前格子有多少条路径
# 1.1 子问题1：
#   dp[i][j]来源只能来自左边和上边，且 i == 0 时，只能来自左边
# 2、状态转移方程：
#   dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
# 3、状态初始化：
#   dp[0][j] = 1, dp[i][0] = 1
# 4、运行顺序：
#   先m，后n
~~~

## 75.颜色分类

题目链接[力扣-75.颜色分类](https://leetcode.cn/problems/sort-colors/description/)

~~~python
# 双指针，数字0的指针index0，指向1序列的第一个位置，
# 数字1的指针index1指向1序列结束的下一个位置（即遍历到的最新的nums[i])
# 值得注意的是，判断nums[i]为0、1、2时，要用if elif，单独用if时，会造成二次交换
~~~

