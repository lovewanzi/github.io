---
layout: post
title: "力扣刷题思路"
date: 2024-07-25 12:00
categories: leetcode
background_image: "/assets/images/background.jpg"
tags: [leetcode, 刷题思路]
toc: true
author: 麻辣烫
---

## 20.有效的括号

题目链接：[力扣-20. 有效的括号](https://leetcode.cn/problems/valid-parentheses)

> 思路一：栈
>
> 1. 使用字典`dic`存放三种右左括号的对应关系，`key`为右括号，`value`为左括号
> 2. 遇到左括号，入栈
> 3. 遇到右括号，出栈。并比较在`dic`中，当前右括号为`key`对应的`value`是否等于出栈的左括号。相等继续往下遍历，不相等返回`False`
> 4. 结束遍历后，栈为空返回`True`，不为空返回`Fasle`

~~~python
class Solution:
    def isValid(self, s: str) -> bool:
        size = len(s)
        if size % 2 == 1:
            return False
        stack = []
        dic = {')': '(',
               ']': '[',
               '}': '{'
               }
        for i in range(size):
            if s[i] in ']})':
                if not stack or stack and stack.pop() != dic[s[i]]:
                    return False
            else:
                stack.append(s[i])
        return True if not stack else False
~~~

> ~~思路二：计数~~
>
> 1. ~~使用变量`count`记录左括号个数~~
> 2. ~~遇到左括号`count`加一，反之减一。如果遇到右括号时，`count == 0`，证明遇到了多余的右括号，返回`False`。~~
> 3. ~~结束遍历时，`count`不等于零，则证明左括号多余。`return count == 0`~~
> 4. 这个思路是错误的，解决不了两个左右括号不匹配的问题，例如`s = (]`，会返回`True`

##  31.下一个排列

题目链接[**力扣-31.下一个排列**](https://leetcode.cn/problems/next-permutation/description/)

```python
# 整体思路：
# 1、倒序寻找第一个升序所在的位置 i
# 2、然后从倒序遍历过的数字中，找出刚好大于位置 i 的数字，位置记为 j
# 3、交换i, j位置上的数字，因为原数组nums[i] > nums[j + 1]，那么交换位置后，数组nums[i+1:size]，也为降序
# 4、因为交换位置后，数组组成的数字高位已经变大很多，为了寻找下一个排列，则需要将交换后，i 位置往后的数字降序排列
```

## 32.最长有效括号

题目链接[力扣-32.最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

思路: 值得注意的是，在子问题3中，已经讨论了`s[i]`连续为`n`个`)`的问题，当为连续`n`个`)`时，遍历过的`dp[i - 1]，dp[i - 2] ... dp[i - n`]都已经在遍历时讨论过了

```python
# 1 初始化状态：
#   dp[i]表示以 i 为结尾的有效括号个数
# 1.1 子问题1，当s[i]为 ( 时，dp[i] = 0
# 1.2 子问题2，当s[i]为 ) 时，s[i - 1]为 ( ，那么dp[i]状态与dp[i - 2]有关
# 1.3 子问题3，当s[i]为 ( 时，s[i - 1]为 ) ，那么dp[i]状态与dp[i - 1] 和 s[i - dp[i - 1] - 1] 及 dp[i - dp[i - 1] - 2]有关
# 2、状态转移方程：
#   dp[i] = dp[i - 2] + 2   当s[i]为 ) 时，s[i - 1]为 (
#   dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2   当s[i] = ) 且 s[i - 1] = ) 且 s[i - dp[i - 1] -1] = ( 时
# 3、初始化：
#   当s[i] 为 (，dp[i] = 0
#               dp[0] = 0
# 4、运行顺序：
#   从左到右
```

## 33.搜索螺旋排序数组

题目链接[力扣-33.搜索螺旋排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)

思路：

````python
# 1、使用二分查找
# 2、在二分查找时，无论mid落在哪个位置，mid一定是处于某个有序的序列中的
# 3、那么先确定left 到 mid是否是有序序列，如果是的话，再在这个序列中搜索target
# 4、如果left 到 mid不是有序序列，那么mid 到 right肯定是有序序列，在mid到right的区间去搜索target和更新left和mid
````

## 34.在排序数组中查找元素的第一个和最后一个位置

题目链接[力扣-34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

思路：因为更新`right`时，右边界`right`总是在减小，所以合并`nums[mid] == target`这个条件，会逐渐逼近左边界。同理`left`逼近右边界

```python
# 思路：直接二分
# 1、当nums[mid] == target时，与搜索条件nums[mid] < target合并。那么左边界left会不停的逼近nums中等于target值的右边界
# 2、当nums[mid] == target时，与搜索条件nums[mid] > target合并。那么右边界right会不停的逼近nums中等于target值的左边界
```

## 39.组合总和

题目链接[力扣-39.组合总和](https://leetcode.cn/problems/combination-sum/)

```python
# 回溯
# 1、返回值：因为时组合问题，不需要返回值。使用path收集遍历过的nums[i]，等满足终止条件时，将path加入res
# 2、终止条件：终止条件为target == 0。
# 3、单层递归逻辑：遍历数组nums，同时target -= nums[i]。如果小于0，直接continue到下一个nums[j]，大于0则进入下一层递归。为了避免重复值，下层的 #    startIndex需要从i开始。从零开始会造成重复答案
```

## 42.接雨水

题目链接[力扣-42.接雨水](https://leetcode.cn/problems/trapping-rain-water/)

思路：双指针法是纵向直接一步到位求出`index`对应的水位有多深。单调栈是横向求出一个池塘不同水位能装多少水，然后累加起来求总和

```python
# 思路1：双指针法。
# 1）记录index位置左右两边的最大值，那么与左右两边最大值中的较小值的差，为该index位置的水位。
# 2）将水位求和，那么就是蓄水大小
# 3）因为水池中，可能会有砖头，石块。意思就是相邻比index位置大的位置，可能就是水池的砖头和石块，并不是池子的边界。所以需要index左右两边的最大值
# 思路2：单调栈。
# 1、维护一个单调递减栈，这样能保证index左边水位比index水位高。
# 2、在右边遇到一个比栈顶大的值，那么可以求出这层水位的含水量，(min(height[left], [right]) - height[index]) * (right - left)
```

## 46.全排列

题目链接[力扣-46.全排列](https://leetcode.cn/problems/permutations/description/)

思路：回溯

```python
# 核心是res怎么去掉重复的数字
# 1、如果不考虑数组遍历范围，那么res里面相同的数字会出现多次
# 2、如果使用index自增，那么小于index的数组值无法被取到
# 3、综上，只能改变nums，在下一次迭代之前将已加入path的nums值直接剔除
```

## 48.旋转图像

### 1.旋转矩阵的基本方法

1. **90° 顺时针旋转**：
   - **步骤1**：将矩阵转置（行列互换）。
   - **步骤2**：反转每一行。
2. **90° 逆时针旋转**：
   - **步骤1**：将矩阵转置。
   - **步骤2**：反转每一列。
3. **180° 旋转**：
   - 直接将矩阵中的元素对称交换。
4. **270° 顺时针旋转**（即90° 逆时针旋转）：
   - 可以通过90°顺时针旋转三次实现，或者按逆时针旋转的步骤进行。

### 2.旋转算法实现

以下是Python代码实现不同角度的矩阵旋转。

#### 2.1 90° 顺时针旋转

```python
def rotate_90_clockwise(matrix):
    n = len(matrix)
    # 矩阵转置
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # 每行反转
    for i in range(n):
        matrix[i].reverse()
    return matrix
```

#### 2.2 90° 逆时针旋转

```python
def rotate_90_counterclockwise(matrix):
    n = len(matrix)
    # 矩阵转置
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # 每列反转
    for j in range(n):
        for i in range(n // 2):
            matrix[i][j], matrix[n - 1 - i][j] = matrix[n - 1 - i][j], matrix[i][j]
    return matrix
```

#### 2.3 180° 旋转

```python
def rotate_180(matrix):
    n = len(matrix)
    for i in range(n):
        for j in range(n):
            if i < n // 2 or (i == n // 2 and j < n // 2):
                matrix[i][j], matrix[n - 1 - i][n - 1 - j] = matrix[n - 1 - i][n - 1 - j], matrix[i][j]
    return matrix
```

### 3.示例

假设我们有一个3x3的矩阵：

```
python复制代码matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# 顺时针旋转90°
print(rotate_90_clockwise(matrix))

# 逆时针旋转90°
print(rotate_90_counterclockwise(matrix))

# 旋转180°
print(rotate_180(matrix))
```

### 4.旋转角度依据

- **90° 顺时针**：元素 `(i,j)` 移动到 `(j,n−1−i)`。

  ① 转置：`(i, j) → (j, i)`

  ② 反转：`(j, i) → (j, n - 1 - i)`

  综上，从`(i, j)`移动到`(j, n - 1 -i)`，只需转置和反转两步

- **90° 逆时针**：元素 `(i,j)` 移动到 `(n−1−j,i)`。

- **180°**：元素 `(i,j)`移动到`(n−1−i,n−1−j)`。

## 49.字母异位词分组

```python
# 思路1：将数组中的每个字符串排序，然后作为字典的key。value为一个接收相同key值的字符串数组，遇到相同key就append
# 思路2：计数字符串，然后将字符串中每个字符和其计数组合成新字符串，例如a1b2c3，作为key
```

## 53.最大子数组和

题目链接[力扣-53.最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

```python
# 1、初始化状态：
#   dp[i]表示以nums[i]结束的连续序列的最大值
# 1.1 子问题：那么题目要求连续，那么状态只有两种，一种是nums[i]和index小于i的序列组合成和更大的序列，另一种是不和之前的序列组合，nums[i]单独成一个序列
# 2、状态转移方程
#   dp[i] = max(dp[i - 1] + nums[i], nums[i])
# 3、初始化状态：
#   dp[0] = nums[0]
# 4、运行顺序：
#   从左到右
```

## 55.跳跃游戏

题目链接[力扣-55.跳跃游戏](https://leetcode.cn/problems/jump-game/description/)

~~~python
# 思路1：
# 1、初始化状态
#   dp[i]表示能否跳跃到当前位置
# 1.1 子问题1：dp[i]状态与dp[0:i-1]有关
# 2、状态转移方程：
#   dp[i] = dp[j] and nums[j] >= (i - j)  j=0,1,...,i-1
# 3、初始值：
#   dp[0] = True
# 4、运行顺序：
#   从左到右。补充：如果j遍历从左到右，那么会出现超时的情况。因此将j从右到左遍历，增大找到使dp[i] = true的j的概率，提交通过
# 思路2：使用贪心算法
#   1、设置一个变量，记录遍历过的位置所能达到的最远位置。
#   2、如果最远位置小于当前位置i，那么表示最远也不可能达到当前位置i，直接返回false
~~~

## 56.合并区间

题目链接[力扣-56.合并区间](https://leetcode.cn/problems/merge-intervals/description/)

~~~python
# 思路：
# 1、按照左边界进行排序。
# 2、设立两个变量left, right分别记录合并后的左右边界，遍历intervals，更新右边界
# 3、当intervals[i]的左边界大于right时，记录下left, right。并更新intervals[i]记录的值为left和right
~~~

## 62.不同路径

题目链接[力扣-62.不同路径](https://leetcode.cn/problems/unique-paths/description/)

~~~python
# 1、初始化状态：
#   dp[i][j] 表示从左上角到当前格子有多少条路径
# 1.1 子问题1：
#   dp[i][j]来源只能来自左边和上边，且 i == 0 时，只能来自左边
# 2、状态转移方程：
#   dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
# 3、状态初始化：
#   dp[0][j] = 1, dp[i][0] = 1
# 4、运行顺序：
#   先m，后n
~~~

## 75.颜色分类

题目链接[力扣-75.颜色分类](https://leetcode.cn/problems/sort-colors/description/)

~~~python
# 双指针，数字0的指针index0，指向1序列的第一个位置，
# 数字1的指针index1指向1序列结束的下一个位置（即遍历到的最新的nums[i])
# 值得注意的是，判断nums[i]为0、1、2时，要用if elif，单独用if时，会造成二次交换
~~~

## 76.最小覆盖子串

题目链接[力扣-76.最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/)

~~~python
# 思路：滑动窗口
# 1、两个字典，一个字典A记录目标字符串t的字符计数情况。另一个字典B记录遍历过的字符的计数情况
# 2、设置变量match,left，假如字典B中某个字符subs计数B[subs] == A[subs]，那么match加一。
# 3、如果match == len(A)，那么表示完全匹配，计算i - left + 1的值与已记录符合题意子串长度作比较，记录较小子串
# 4、更新left
# 值得注意的是，当match == len(A)，更新left时，要注意B[subs] > A[subs]的情况。所以更新结束条件为while match == len(A)
~~~

## 78.子集

题目链接[力扣-78.子集](https://leetcode.cn/problems/subsets/description/)

~~~python
# 思路：回溯
# 注意下一层回溯起始位置为当前层遍历的位置 i + 1
~~~

## 79.单词搜索

题目链接[力扣-79.单词搜索](https://leetcode.cn/problems/word-search/description/)

> 思路：深度优先搜索题
>
> 1. 定义四个方向，和一个记录搜索路径的状态数组`record`。注意`record`记录的是当前层某一个方向A向下dfs时被搜索过的记录，当这个方向`A`搜索完成时，需要恢复`record`的状态。因为在该层换方向`B`向下搜索时，该位置只要不是上一层被搜索过且设置为`True`，在方向B向下搜索时是可以被搜索的。
>
> 2. 不能直接返回递归调用的状态，因为这项相当于直接中断每一层的遍历
>
> 3. 带返回值的递归，可以在当前层遍历完成后，再决定返回什么样的状态

~~~python
class Solution:
    def exist(self, board, word):
        m, n = len(board), len(board[0])
        to = [[-1, 0], [1, 0], [0, 1], [0, -1]]
        size = len(word)
        for i in range(m):
            for j in range(n):
                if board[i][j] == word[0]:
                    index = 1
                    record = [[False] * n for _ in range(m)]
                    record[i][j] = True
                    if self.dfs(record, to, size, index, board, word, m, n, i, j):
                        return True
        return False

    def dfs(self, record, to, size, index, board, word, m, n, i, j):
        if index == size:
            return True
        for direction in to:  # 每一层遍历的方向
            x = i + direction[0]
            y = j + direction[1]
            if x < m and x > -1 and y > -1 and y < n and not record[x][y] and board[x][y] == word[index]:
                record[x][y] = True  # 表示当前方向往下dfs时，这个位置不能被检索了
                if self.dfs(record, to, size, index + 1, board, word, m, n, x, y):  # 这里不能直接return，不然中断方向的遍历
                    return True
                record[x][y] = False  # 记得恢复状态，因为换个方向往下搜索是可以搜这个格子的
        return False  # 每一层方向遍历完成后，决定返回什么状态
~~~

## 84.柱状图中的最大矩形

题目链接[力扣-84.柱状图中的最大矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

> 思路1：暴力搜索，将每一个`nums[i]`向两边遍历，直到遇到比自己小的`nums[left]`和`nums[right]`才停止。`w = right - left + 1, h = nums[i]`
>
> 思路2：单调栈，定义一个单调递增栈。思路和思路`1`差不多，只不过单调栈会把遍历过的数字存储起来，不需要遍历第二遍
>
> 1. 碰到比`stack[-1]`小的数字开始出栈，`index = stack.pop()，h = height[index], w = i - stack[-1] - 1`
>
> 2. 值得注意的是，`w = i - index`是不正确的，因为假如`index`和`stack[-1]`不为相邻元素，那么`w`会被减小
>
> 3. 单调递增栈的出栈条件是遇到比栈顶更小的元素，如果数组为单调递增数组，那么无法出栈，所以可以在原数组末端`nums.append(0)`，保证出栈。
>
> 4. 当栈中只剩下一个元素时，`stack.pop()`后，`w = i - stack[-1] - 1` 无法执行，所以可以在头位置加一个元素`0`，或者做一个`else`判断，为空则 `w = i`。
>    + 因为`pop`之前`stack`中是有值的，而且这个值一定是数组中目前遍历到i位置的最小值，所以其宽度能直接扩展到`i`。

~~~python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights.append(0)
        size = len(heights)
        stack = []
        res = 0
        for i in range(size):
            while stack and heights[stack[-1]] > heights[i]:
                index = stack.pop()
                h = heights[index]
                if stack:
                    # 这里不能写w = i - index，因为index和stack[-1]可能不是连在一起的，如果不连在一起，会导致从stack[-1]到index之间的w没被计算到，导致结果变小
                    w = i - stack[-1] - 1
                else:
                    # stack为空，那么肯定栈中元素都是大于零的，因为最后一个元素为0，如果前面有0元素，那么不会出栈
                    w = i
                res = max(res, w * h)
            stack.append(i)
        return res
~~~

## 85.最大矩形

题目链接[力扣-85.最大矩形](https://leetcode.cn/problems/maximal-rectangle/description/)

~~~python
# 思路：将matrix前i行都看做一个柱状图，沿用84题的思路。遍历每一行，将前i行的每一列值累加起来，就是84题中的高度。
# 1、当某一个matrix[i][j] == 0时，这一行的高度重置为0
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        m, n = len(matrix), len(matrix[0])
        heights = [0] * n
        res = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    heights[j] += 1
                else:
                    heights[j] = 0
            res = max(res, self.max_rec(copy.deepcopy(heights)))
        return res

    def max_rec(self, heights):
        max_res = 0
        stack = []
        heights.append(0)
        size = len(heights)
        for i in range(size):
            while stack and heights[stack[-1]] > heights[i]:
                index = stack.pop()
                h = heights[index]
                if stack:
                    w = i - stack[-1] - 1
                else:
                    w = i
                max_res = max(max_res, w * h)
            stack.append(i)
        return max_res
~~~

## 94.二叉树的种类

### 1. 普通二叉树 (Binary Tree)

**图示**：

```markdown
     1
    / \
   2   3
  / \   \
 4   5   6
```

**注意事项**：

- 每个节点最多有两个子节点。
- 节点的子节点可以是空的。

------

### 2. 满二叉树 (Full Binary Tree)

**图示**：

```markdown
     1
    / \
   2   3
  / \ / \
 4  5 6  7
```

**注意事项**：

- 每个节点要么没有子节点，要么有两个子节点。
- 完全填满每一层。

------

### 3. 完全二叉树 (Complete Binary Tree)

**图示**：

```markdown
     1
    / \
   2   3
  / \ / 
 4  5 6  
```

**注意事项**：

- 除了最后一层外，所有层上的节点都达到最大数目。
- 最后一层的节点尽可能地靠左排列。

------

### 4. 平衡二叉树 (Balanced Binary Tree)

**图示**：

```markdown
     3
    / \
   2   4
  /     \
 1       5
```

**注意事项**：

- 任意节点的左右子树高度差不超过1。
- 需要平衡操作来保持树的平衡。

------

### 5. 二叉搜索树 (Binary Search Tree, BST)

**图示**：

```markdown
     4
    / \
   2   6
  / \ / \
 1  3 5  7
```

**注意事项**：

- 对于树中的任意节点，其左子树上所有节点的值都小于该节点的值，其右子树上所有节点的值都大于该节点的值。
- 插入和删除操作需要保持这个性质。

------

### 6. 平衡二叉搜索树 (Balanced Binary Search Tree)

**图示**：

```markdown
     4
    / \
   2   6
  / \ / \
 1  3 5  7
```

**注意事项**：

- 同时满足平衡二叉树和二叉搜索树的性质。
- 常见的平衡二叉搜索树有AVL树和红黑树。

------

### 7. AVL树 (AVL Tree)

**图示**：

```markdown
     3
    / \
   2   4
  /     \
 1       5
```

**注意事项**：

- 任意节点的左右子树高度差不超过1。
- 插入和删除操作后可能需要进行旋转操作来保持平衡。

------

### 8. 红黑树 (Red-Black Tree)

**图示**：

```markdown
     4(B)
    /   \
   2(R)  6(R)
  / \   / \
 1(B) 3(B) 5(B) 7(B)
```

**注意事项**：

- 每个节点要么是红色，要么是黑色。
- 根节点是黑色。
- 红色节点不能有红色子节点（即红色节点的两个子节点必须是黑色）。
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
- 插入和删除操作后可能需要进行旋转和重新着色操作来保持红黑树性质。

------

### 9. 伸展树 (Splay Tree)

**图示**：

```markdown
     4
    / \
   2   5
  / \
 1   3
```

**注意事项**：

- 最近访问的节点会被旋转到根部。
- 伸展操作通过旋转将节点移动到根部，以加速后续访问。

------

### 10. Treap

**图示**：

```markdown
     5
    / \
   2   6
  / \
 1   3
```

**注意事项**：

- 同时满足二叉搜索树和堆的性质。
- 每个节点有一个优先级，优先级满足堆的性质（即父节点的优先级大于子节点的优先级）。

------

### 11. 堆 (Heap)

**图示**：

```markdown
    1
   / \
  2   3
 / \ / \
4  5 6  7
```

**注意事项**：

- 堆分为最大堆和最小堆。
- 最大堆：每个节点的值都大于或等于其子节点的值。
- 最小堆：每个节点的值都小于或等于其子节点的值。

------

### 12. 二叉堆 (Binary Heap)

**图示**：

```markdown
    1
   / \
  3   2
 / \ / \
7  6 5  4
```

**注意事项**：

- 一种堆结构，常用于实现优先队列。
- 满足完全二叉树的性质，节点按堆的性质排列。

------

### 13. 霍夫曼树 (Huffman Tree)

**图示**：

```markdown
      *
     / \
    *   E
   / \
  A   *
     / \
    B   C
```

**注意事项**：

- 用于霍夫曼编码，生成最优二叉树以实现数据压缩。
- 权重较小的节点离根较远。

------

### 14. 线段树 (Segment Tree)

**图示**：

```markdown
      18
    /   \
   7    11
  / \   / \
 3   4 5   6
```

**注意事项**：

- 用于解决区间查询问题。
- 可以高效地进行区间更新和区间查询。

------

### 15. 范例树 (Fenwick Tree/Binary Indexed Tree)

**图示**：

```markdown
       15
      / \
     7   8
    / \
   3   4
```

**注意事项**：

- 用于快速更新和查询前缀和。
- 通过维护部分和来实现高效查询和更新。

这些图示和注意事项涵盖了各类二叉树的基本概念和用途。具体应用中，选择合适的二叉树结构对于实现高效算法和数据处理非常重要。

## 96.不同的二叉搜索树

题目链接[力扣-96.不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)

~~~python
class Solution:
    def numTrees(self, n: int) -> int:
        """
        :param n:
        :return:
        思路：动态规划
        1、初始化状态：dp[n]表示n个节点能组成多少个搜素二叉树
        1.1、子问题1：当有n个节点时，从1 -> n 的每个节点分别当做根节点，
             肯定是不同的二叉树（节点值为1 -> n，所以根节点值肯定不同）
        1.2、子问题2：令F(i)表示以数字 i 为根节点的不同二叉搜索树的个数，则有G(n) = F(1) + F(2) + ... + F(n)
        1.3、子问题3：令 i 表示根节点，则F(i) = G(i - 1) * G(n - i)。G(i - 1)表示根节点为i的
             左子树有i - 1个节点，右子树有n - i个节点，那么左子树的种类肯定有G(i - 1)个，而树的个数
             与节点值无关，只与节点个数有关，所以右子树种类有G(n - i)个。那么两边子树组合种类为G(n - i) * G(i - 1)
        1.4、子问题4：结合1.3,1.2有G(n) = G(0)*G(n - 1) + G(1)*G(n - 2) + ... + G(n - 1)*G(0)
        2、状态转移方程：dp[i] = dp[0]*dp[i - 1] + dp[1]*dp[i - 2] + ... + dp[i - 1]*dp[0]
        2.1、据上式可以看出:
            1、当i - 1为偶数
            dp[i] = 2(dp[0]*dp[i - 1] + dp[1]*dp[i - 2] + ... + dp[(i - 1) // 2][(i - 1) // 2])
            2、当i - 1为奇数
            dp[i] = 2(dp[0]*dp[i - 1] + dp[1]*dp[i - 2] + ... + dp[(i - 2) // 2][(i - 2) // 2]) + dp[(i - 2) // 2 + 1][(i - 2) // 2 + 1]
        3、边界条件：当i为0表示无节点，1表示只有一个节点，那么这两种情况自然只有一种组合
            dp[0] = 1, dp[1] = 1
        4、运行顺序：0 -> n
        """
        dp = [0] * (n + 1)  # 不能预设为1，如果为1，每个dp[i]自加的时候都会多加1
        dp[0] = dp[1] = 1
        for i in range(2, n + 1):
            k = i // 2
            for j in range(1, k + 1):
                dp[i] += 2 * dp[j - 1] * dp[i - j]
            if i % 2 == 1:
                dp[i] += dp[i - k - 1] * dp[i - k - 1]

        return dp[-1]
~~~

## 98.验证二叉搜索树

题目链接[力扣-96.验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/solutions/)

中序遍历

~~~python
# 思路1：设置变量val，记录上一个节点的值，比较当前节点root.val和val的值，如果出现root.val <= val 那么返回False
# 思路2：设置前驱节点pre，用pre记录前一个节点的地址，比较前一个节点pre.val和当前节点root.val的值，如果出现root.val <= pre.val，那么返回False
# 思路1
class Solution:
    val = float('-inf')

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        left = self.isValidBST(root.left)
        if root.val > self.val:
            self.val = root.val
        else:
            return False
        right = self.isValidBST(root.right)
        return left and right
# 思路2   
class Solution:
    pre = None

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        left = self.isValidBST(root.left)
        if self.pre:
            if self.pre.val >= root.val:
                return False
        self.pre = root
        right = self.isValidBST(root.right)
        return left and right
~~~

## 101.对称二叉树

题目链接[力扣-101.对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)

~~~python
# 思路1：递归
# 	1、两棵相同的树一起遍历，第一棵树向左第二棵树向右
#	2、在前序的位置比较树的节点值情况
#	3、当两棵树节点值相等时，不能直接返回True，应该继续向下递归，比较子节点的值情况
# 思路2：层序遍历，层序判断是否为对称数组
~~~

~~~python
# 思路1：
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        return self.traverse(root, root)

    def traverse(self, root1, root2):
        if not root1 and not root2:
            return True
        elif not root1 or not root2:
            return False
        else:
            if root1.val != root2.val:
                return False
            left = self.traverse(root1.left, root2.right)
            right = self.traverse(root1.right, root2.left)
            return True if left and right else False

# 思路2
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        stack = [root]
        while stack:
            level = []
            temp_stack = []
            size = len(stack)
            for i in range(size):
                if stack[i]:
                    level.append(stack[i].val)
                    if stack[i].left:
                        temp_stack.append(stack[i].left)
                    else:
                        temp_stack.append(None)
                    if stack[i].right:
                        temp_stack.append(stack[i].right)
                    else:
                        temp_stack.append(None)
                else:
                    level.append(None)
            left, right = 0, size - 1
            while left <= right:
                if level[left] != level[right]:
                    return False
                left += 1
                right -= 1
            stack = temp_stack
        return True
# 思路2的写法2：画个二叉树的图就好理解。
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

            # Initialize a deque with the left and right children of the root
        queue = deque([(root.left, root.right)])

        while queue:
            left, right = queue.popleft()

            # If both are None, continue to the next pair
            if not left and not right:
                continue

            # If one is None and the other is not, it's not symmetric
            if not left or not right:
                return False

            # If the values are different, it's not symmetric
            if left.val != right.val:
                return False

            # Enqueue the children in the order that they should be compared
            queue.append((left.left, right.right))
            queue.append((left.right, right.left))

        return True
~~~

## 102.二叉树的遍历

### 二叉树的层序遍历

题目链接[力扣-102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

~~~python
# 思路：借助栈
# 1、节点入栈stack
# 2、遍历栈stack，建立一个临时栈temp，判断栈中的左子节点和右子节点分别存不存在，存在则入栈temp。
# 3、收集节点值，将临时栈赋值给stack
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        res = []
        stack = [root]
        while stack:
            sub_res = []
            temp_stack = []
            size = len(stack)
            for i in range(size):
                node = stack[i]
                if node.left:
                    temp_stack.append(node.left)
                if node.right:
                    temp_stack.append(node.right)
                sub_res.append(node.val)
            res.append(sub_res)
            stack = temp_stack
        return res
~~~

### 前中后遍历，非递归写法

#### 借助栈

> 1. 使用辅助栈，模拟递归调用的过程。
> 2. 特别注意的是终止循环条件，栈和节点有一个不为空就可以。因为在遍历到前驱节点的后一个节点时，栈肯定为空，但是树还有一半是没有遍历完的

> **前序遍历**

~~~python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []
        while stack or root:
            if root:
                res.append(root.val)
                stack.append(root)
                root = root.left
            else:
                temp = stack.pop()
                root = temp.right
        return res
~~~

> **中序遍历**

~~~python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                temp = stack.pop()
                res.append(temp.val)
                root = temp.right
        return res
~~~

> **后续遍历**
>
> 1. 特殊之处在于需要确认右子节点被访问过后，再访问根节点。
> 2. 设定一个变量跟踪访问过的节点（从stack里pop出来的，表示已经访问过了）

~~~python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []
        last_visit = None
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                if stack[-1].right and stack[-1].right != last_visit:
                    root = stack[-1].right
                else:
                    last_visit = stack.pop()
                    res.append(last_visit.val)
        return res
~~~

#### morris算法

> 1. morris算法其实是将二叉树变为单链表的一个过程，按照前中后遍历的顺序，将左子树整体移动到父节点的左边或者右边。
> 2. 对每个节点重复这个过程。
> 3. 下图就是一个中序遍历时，右子树整体挪到前驱节点 `5` 的一个过程

<img src="/assets/images/Snipaste_2024-08-09_16-57-08.png" alt="morris中序" style="zoom:80%;" />

> **前序遍历**
>
> 1. 顺序 root -> left -> right
> 2. 那么先取根节点，然后将左子树移动到右子树，再将右子树赋值给前驱节点`5`

~~~python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        while root:
            res.append(root.val)
            pre = root
            if root.left:
                temp = root.right
                root.right = root.left
                while pre.right:
                    pre = pre.right
                pre.right = temp
            root.left = None
            root = root.right
        return res
~~~

> **中序遍历**
>
> 1. 顺序 root -> left -> right
> 2. 将包含根节点在内的右边节点移动到前驱节点 `5`
> 3. 接着节点持续左移，直到遇到无左子节点，然后开始收集结果，并开始遍历右节点。其实当无左子节点时，左子树已经形成单链表了。
> 4. 接着开始收集左子树的单链表
> 5. 直到遇到右子树中具有左孩子的节点，又开始1、2、3、4，最终完成遍历

~~~python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        while root:
            pre = root
            if pre.left:
                pre = pre.left
                temp = pre
                while pre.right:
                    pre = pre.right
                pre.right = root
                root.left = None
                root = temp
            else:
                res.append(root.val)
                root = root.right
        return res
~~~

> **后续遍历**：太复杂了，仅作参考。一般Morris算法只做前中序遍历
>
> [Morris后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/solutions/431066/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/)

## 105.从前序遍历和中序遍历构造二叉树

> 题目链接[力扣-105.从前序和中序序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

~~~python
# 思路1：递归 + 分治
# 	1、对于前序遍历而言，当前节点A后一个值一定是当前节点A的左子节点值或者右子节点值。因为前序遍历顺序为 root -> left -> right
#	2、对于中序遍历而言，以前序遍历中节点值A做切割点，那么切割点A左边的序列形成A节点的左子树，右边的序列形成右子树
#	3、通过以上两点，可以用中序遍历做辅助，判断节点A是否有左右节点即可。如果以节点A做切割的中序遍历左边序列为空，那么A.left = None，如果不为空则将前序遍历A节点值的后一个值赋值给A.left
class Solution:
    index = 0

    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not inorder:
            return None
        res = TreeNode(preorder[self.index])
        root_val = preorder[self.index]
        clip = inorder.index(root_val)
        self.index += 1
        res.left = self.buildTree(preorder, inorder[0:clip])
        res.right = self.buildTree(preorder, inorder[clip + 1:])
        return res
# 思路二：做辅助栈
# 1、遍历preorder序列，将prorder[0]入栈
# 2、栈中入栈未添加右子节点的父节点，设置变量index记录中序遍历序列里节点的位置
# 3、判断栈顶节点值是否和中序遍历序列inorder[index]相等
# 	3.1 如果不相等，证明该前序遍历的节点值preorder[stack[-1]]左子节点为inorder[index]
#	3.2 如果相等，那证明stack[-1]对应的节点已经无左子节点了，因为如果有左子节点，其子节点组成的序列一定在inorder[stack[-1]]节点的左边。
# 	3.3 当相等后，开始出栈stack.pop()，直到preorder[stack[-1]] != inorder[index]。那么表示找到了最后一个pop出的节点的右子节点node
#	3.4 对于3.3，因为如果遍历到的node为出栈的 preorder[stack[-1]] == inorder[index] 除最后一个出栈节点之外的其他节点的右子节点，那么表示最后一个出栈的右子节点还有左孙子节点（左子树）没有遍历构建完成。但是在中序遍历中，从preorder[stack[-1]] == inorder[index]开始pop，直到最后一个pop出的节点，都能看出来已经没有左子孙节点能够构建了。所以node一定是最后一个pop出节点的右子节点。
# 4、将node入栈，继续构建右边子树，从node开始重复1、2、3步骤
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        root = TreeNode(preorder[0])
        stack = [root]
        inorder_index = 0
        for i in range(1, len(preorder)):
            node = TreeNode(preorder[i])
            if stack[-1].val != inorder[inorder_index]:
                stack[-1].left = node
            else:
                temp = None
                while stack and stack[-1].val == inorder[inorder_index]:
                    temp = stack.pop()
                    inorder_index += 1
                temp.right = node
            stack.append(node)
        return root
~~~

## 106.从中序遍历和后续遍历构造二叉树

题目链接：[力扣-106.从中序遍历和后续遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

~~~python
# 思路1：递归
# 	1、跟105不同点在于，后续遍历根节点放在了序列末端，那么我们需要倒序遍历后序序列。
#	2、寻找倒序遍历节点在中序序列中的index，以此做切割中序序列。
#	3、因为是后续遍历，所以节点左边的序列值为先为右子节点，再为左子节点。那么先构造右子树，再构造左子树。
#	4、当2中切割的左右序列为空，则返回None
#	5、重复1、2、3、4
class Solution:
    index = 0
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not inorder:
            return None
        root = TreeNode(postorder[-1])
        clip = inorder.index(postorder[-1])
        postorder.pop()
        root.right = self.buildTree(inorder[clip + 1:], postorder)
        root.left = self.buildTree(inorder[0:clip], postorder)
        return root
# 思路2：迭代
#	1、沿用104的思路，中序遍历为 left -> root -> right，后序遍历为 left -> right -> root。
#	2、所以当后序的值从末端开始遍历入栈时，栈中顺序为root -> right，那么中序也倒着遍历就为right -> root，这跟stack出栈顺序一致。所以inorder_index的初始值为size - 1
#	3、根据1、2，当stack[-1].val != inorder[inorder_index]，那么证明栈顶元素还有右子节点，所以stack[-1].right = node
#	4、当stack[-1].val == inorder[inorder_index]，证明右子节点构建完毕，开始pop
#	5、入栈node，重复1、2、3、4、5
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        root = TreeNode(postorder[-1])
        stack = [root]
        size = len(postorder)
        inorder_index = size - 1
        for i in range(size - 2, -1, -1):
            node = TreeNode(postorder[i])
            if stack[-1].val != inorder[inorder_index]:
                stack[-1].right = node
            else:
                temp = None
                while stack and stack[-1].val == inorder[inorder_index]:
                    temp = stack.pop()
                    inorder_index -= 1
                temp.left = node
            stack.append(node)
        return root
~~~

## 114.二叉树展开为链表

题目链接：[力扣-114.二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/)

### 思路1：使用递归

> 1. 创建一个全局变量res，再创建一个前驱节点pre。然后将res赋值给pre。[^1]
> 2. 使用前序遍历，在前序遍历中，将root地址赋值给pre，并让pre指针指向自己的右子节点。[^2]
> 3. 定义两个变量left和right，分别保存root节点的左右子节点，防止被下一层递归篡改。[^3]

#### 错误示范

> 在每一次使用完root时，未断开pre和root的链接，在下一层迭代时，root左右子节点地址被修改，造成错误结果

~~~python
class Solution:
    res = TreeNode()
    pre = res

    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        self.tranverse(root)
        root = self.res.right

    def tranverse(self, root):
        if not root:
            return
        self.pre.right = root  # 这里在下一层，相当把上一层的root的左子节点或右子节点赋值给root.right，即root.right = root.left
        self.pre = self.pre.right  # 这里相当于让self.pre = root，而且没有断开self.pre的左子节点
        self.tranverse(root.left)  # 下面两步都是直接在root上遍历左右子节点，但是在下一层时，root的左右子节点已经被修改了
        self.tranverse(root.right)
~~~

#### 正确示范

> 1. 在使用完root后，断开root和下层递归的连接。保证树递归的正确性
> 2. 断开pre和left的链接，保证不修改root，也保证了pre的单链表特性

~~~python
class Solution:
    res = TreeNode()
    pre = res
    aa = None

    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        self.tranverse(root)
        root = self.res.right

    def tranverse(self, root):
        if not root:
            return
        self.pre.right = root
        self.pre.left = None
        # self.aa = root
        self.pre = self.pre.right
        left = root.left
        right = root.right
        self.tranverse(left)
        self.tranverse(right)
~~~

### 思路2：利用树的前序遍历，非递归(morris算法)

> 1. 前序遍历的本质是根左右，那么可以让每个节点只有右节点，无左子节点。
> 2. 使用临时变量temp存储右子节点，然后让遍历到的节点pre的左子节点覆盖右子节点。即pre.right = pre.left
> 3. 让前驱节点[^ 4]node.right = temp
> 4. 断开pre节点的左子树，并让pre指向自己的右子节点
> 5. 重复1、2、3、4直到遍历到最后一个节点pre == None

~~~python
class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        pre = root
        while pre:
            forward = pre
            if pre.left:
                temp = pre.right
                pre.right = pre.left
                while forward.right:
                    forward = forward.right
                forward.right = temp
            pre.left = None
            pre = pre.right
~~~

### 思路3：反向思考，递归

> 1. 前序遍历，使用一个临时节点记录遍历过的node，在递归返回上一层时，将root.right = node。但这样做，会使得root的右子根节点断开，这样右子树就没法递归遍历。
> 2. 逆向思维，前序遍历为根左右，那么可以交换顺序倒着遍历，右左根，这样先遍历右左节点，最后考虑根节点。这样在离开左右节点时，root左右节点已经不影响遍历了，而且倒着建立单链表，最后返回的root就是正确的链表头节点。
> 3. 离开左右节点时，断开左子节点，让离开的root变为单链表

~~~python
class Solution:
    pre = None

    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        self.flatten(root.right)
        self.flatten(root.left)
        root.right = self.pre
        root.left = None
        self.pre = root
~~~

## 买卖股票的最佳时机

**注意**：`dp[1][i]`表示不持股时的最大利润，不够买股票也是不持股的一种状态，因此对于`dp[1][0]`来讲，其初始化值一定是 `0`

### 121.买卖股票的最佳时机 $\mathrm{I}$

题目链接：[力扣-121。买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/) 

> 思路：维护一个price最小值和一个卖出的最大值profit

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price = prices[0]
        max_profit = 0
        for price in prices:
            min_price = min(min_price, price)
            max_profit = max(max_profit, price - min_price)
        return max_profit
~~~

### 122.买卖股票的最佳时机 $\mathrm{II}$

题目链接：[力扣-122.买卖股票的最佳时机 $\mathrm{II}$](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

####  错误思路

> 思路：动态规划
>
> 1. 初始化状态：dp[i]表示遍历到i时，最大收益
>
>    + 子问题1：每天其实就三个状态，买入、卖出、啥也不干
>
>    * 子问题2：用dp[0]、dp[1]、dp[2]分别表示三个状态
>
> 2. 状态转移方程：
>
>    * `dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])`
>    * `dp[1][i] = dp[0][i - 1] + prices[i]`
>    * `dp[2][i] = max(dp[0][i - 1], dp[1][i - 1], dp[2][i - 1])`
>
> 3. 值初始化：
>
>    * `dp[0][0] = -prices[0]`
>    * `dp[0][1] = 0`
>    * `dp[0][2] = 0`
>
> 4. 运行顺序：从左到右
>
> 总结：
>
> 1. 状态`dp[2][i]`定义太模糊，该状态无法确认是持有股票还是未持有股票，因此未无效状态
> 2. 在买入和卖出更新状态时，发现用不到状态`dp[2][i]`，但是什么动作都不做这个状态肯定是存在的
> 3. 因此思路是错误的

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(3)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        dp[2][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])
            dp[1][i] = dp[0][i - 1] + prices[i]
            dp[2][i] = max(dp[0][i - 1], dp[1][i - 1], dp[2][i - 1])
        return max(dp[0][-1], dp[1][-1], dp[2][-1])
~~~

#### 正确思路

> 1. 初始化状态：
>    - 修正`dp[0][i]`状态为持股时所持最大金额，`dp[1][i]`状态为不持股所持最大金额
> 2. 状态转移方程：
>    - `dp[0][i] = max(dp[0][i - 1], dp[1][i] - prices[i])`   注意`dp[0][i - 1]`表示今天啥也不干，就保持昨天状态。
>    - `dp[1][i] = max(dp[1][i - 1], dp[0][i] + prices[i])`   注意`dp[1][i - 1]`表示今天啥也不干，就保持昨天状态。
> 3. 状态初始化：
>    + `dp[0][0] = -prices[0]`
>    + `dp[1][0]` = 0
> 4. 运行顺序：
>    + 从左到右
> 5. 从`2`可以看出，正确思路定义的状态是包含了啥也不干的状态的

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])
            dp[1][i] = max(dp[0][i - 1] + prices[i], dp[1][i - 1])
        return dp[1][-1]
~~~

### 123.买卖股票的最佳时机 $\mathrm{III}$

题目链接：[力扣-123.买卖股票的最佳时机$\mathrm{III}$](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/)

> 1. 初始化状态：
>    + `dp[0][i]`表示第一次持有股票时，存款最大金额
>    + `dp[1][i]`表示第一次不持股票时，存款最大金额
>    + `dp[2][i]`表示第二次持有股票时，存款最大金额
>    + `dp[3][i]`表示第二次不持股票时，存款最大金额
> 2. 动态转移方程：
>    + `dp[0][i] = max(dp[0][i - 1], -prices[i])`
>    + `dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prcies[i])`
>    + `dp[2][i] = max(dp[2][i - 1], dp[1][i - 1] - prices[i])`
>    + `dp[3][i] = max(dp[3][i - 1], dp[2][i - 1] + prices[i])`
> 3. 状态初始化：**有个隐含条件，当天买入可以当天卖出。**
>    + `dp[0][0] = -prices[0]`
>    + `dp[1][0] = 0`
>    + `dp[2][0] = -prices[0]`
>    + `dp[3][0] = 0`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(4)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        dp[2][0] = -prices[0]
        dp[3][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], -prices[i])
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])
            dp[2][i] = max(dp[2][i - 1], dp[1][i - 1] - prices[i])
            dp[3][i] = max(dp[3][i - 1], dp[2][i - 1] + prices[i])
        return dp[3][-1]
~~~

### 188.买卖股票的最佳时机 $\mathrm{IV}$

题目链接：[力扣-188.买卖股票的最佳时机 $\mathrm{IV}$](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

> 1. 初始化状态：
>    + 题目中要求最多交易次数为k，其实状态分析和123题分析是一样的。
>    + 按照`123`题分析，那么总共有 $2*k$ 个状态，记为`n`个状态。
>    + 那么可以写个循环，直接给n个状态赋值
>    + 当`j为偶数 j -> 0:n`，则表示持有股票的最大利润
>    + 当`j为奇数 j -> 0:n`，则表示不持有股票的最大利润
> 2. 状态转移方程：
>    + 当 `j == 0`时，`dp[0][i] = max(dp[0][i - 1], -prices[i])`
>    + 当`j % 2 == 1`时，`dp[j][i] = max(dp[j][i - 1], dp[j - 1][i - 1] + prices[i])` 
>    + 当`j % 2 == 0`时，`dp[j][i] = max(dp[j][i - 1], dp[j - 1][i - 1] - prices[i])` 
> 3. 初始化数组：
>    + 当`j % 2 == 0`时，`dp[j][0] = -prices[i]`
>    + 当`j % 2 == 1`时,`dp[j][0] = 0`
> 4. 执行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        size = len(prices)
        status_size = 2 * k
        dp = [[0] * size for _ in range(status_size)]
        for i in range(status_size):
            if i % 2 == 0:
                dp[i][0] = -prices[0]
            else:
                dp[i][0] = 0
        for i in range(1, size):
            k = 0
            while k < status_size:
                if k == 0:
                    dp[k][i] = max(dp[k][i - 1], - prices[i])
                elif k % 2 == 0:
                    dp[k][i] = max(dp[k][i - 1], dp[k - 1][i - 1] - prices[i])
                else:
                    dp[k][i] = max(dp[k][i - 1], dp[k - 1][i - 1] + prices[i])
                k += 1
        return dp[status_size - 1][-1]
~~~

### 309.买卖股票的最佳时机含冷冻期

题目链接：[力扣-309.买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

> 1. 初始化状态：
>    + 跟`123`题状态一致，只是多了一个冷冻期
>    + 当考虑冷冻期时，持有股票的状态只能从前天的状态转移过来
> 2. 状态转移方程：
>    + `dp[0][i] = max(dp[0][i - 1], dp[1][i - 2] - prices[i])`
>    + `dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])`
>    + 注意`dp[0][i]`的状态方程较`123`题有所变化 
> 3. 数组初始化：
>    + `dp[0][0] = -prices[0]`
>    + `dp[1][0] = 0`
>    + `dp[0][1] = max(dp[0][0], -prices[1])`
>    + `dp[1][1] = max(dp[1][0], dp[0][0] + prices[1])`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        if size == 1:
            return 0
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        dp[0][1] = max(dp[0][0], -prices[1])
        dp[1][1] = max(dp[1][0], dp[0][0] + prices[1])
        for i in range(2, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 2] - prices[i])
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])
        return dp[1][-1]
~~~

### 714. 买卖股票的最佳时机含手续费

题目链接：[力扣-714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)

> 1. 初始化状态：
>    + 跟`123`定义的状态一致，只需要在购买时多减去所交的税即可
>    + 注意数组初始化时，定义的是不持股时的**最大**利润
>    + 当最后输出结果小于`0`时，可以选择不买入也不卖出，那么利润为`0`
> 2. 状态转移方程：
>    + `dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i] - fee)`
>    + `dp[1][i] = max(dp[1][i - 1]`, $\textcolor{red}{dp[0][i - 1] + prices[i]}$`)`
> 3. 数组初始化：
>    + `dp[0][0] = -prices[0] - fee`
>    + ~~`dp[1][0] = -fee`~~这里的初始化是错误的，`dp[1][i]`表示不持股时的最大利润，不够买股票也是不持股的一种状态，因此对于`dp[1][0]`来讲，其初始化值一定是 `0`
>    + `dp[1][0] = 0`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0] - fee
        dp[1][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i] - fee)
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])
        return dp[1][-1] if dp[1][-1] > 0 else 0
~~~

> 1. 考虑另外一种交税方式，在卖出时交税。这样在初始化数组时，就不用考虑`dp[1][0]`的特殊情况了
>
> 2. 状态转移方程：注意$\textcolor{red}{**红色部分的变化**}$
>
>    + `dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])`
>    + `dp[1][i] = max(dp[1][i - 1]`, $\textcolor{red}{dp[0][i - 1] + prices[i] - fee}$`)`
>
> 3. 状态初始化：
>
>    + `dp[0][0] = -prices[0]`
>
>    + `dp[1][0] = 0`

~~~python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i] - fee)
        return dp[1][-1] if dp[1][-1] > 0 else 0
~~~

## 124. 二叉树中的最大路径和

题目链接：[力扣-124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum)

>1. 思路：递归
>   + 题目明确要求是二叉树的最大路径和，且不能重复遍历。那么可以考虑在离开左右子树，回到父节点时，收集路径最大和
>   + 对于当前节点来讲，包含当前节点的最大路径和，即为左子树最大路径和`leftMax`，加上右子树最大路径和`rightMax`，加上当前节点值`root.val`。即`rootMax = leftMax + root.val + rightMax`
>   + 当`rootMax`小于`0`时，则应该舍弃，因为对于其父节点来讲，是负增益。因此将其置`0`，再返回给父节点，这样相当于其父节点断开这一子树
>   + 因为返回给父节点的值都是包含了当前节点的，因此不存在不连续的问题。
>2. 递归三步：
>   + 确定递归终止条件：
>     + 当`root == None`时，终止递归
>   + 确定参数和返回值：
>     + 参数：① 需要一个全局变量`self.res`收集当前节点的最大路径和`rootMax`。 ② 需要传入`root`节点，以便于向下左递归
>     + 返回值：每次返回包含当前节点值`root.val`的左右子树中，较大的路径最大和`max(leftMax, rightMax) + root.val`，这样能保证传给父节点的路径和是连续的节点值的和。
>   + 单层递归逻辑：① 使用`self.res`与当前节点的最大路径和左比较，更新`self.res`为两者之间的最大值。② 比较`leftMax`和`rightMax`，取二者中较大值与当前`root.val`的和返回给父节点。
>   + 如果`max(leftMax, rightMax) + root.val`小于零，则向父节点返回`0`

~~~python
class Solution:
    res = -1001

    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        self.tranverse(root)
        return self.res

    def tranverse(self, root):
        if not root:
            return 0
        left = self.tranverse(root.left)
        right = self.tranverse(root.right)
        total = left + right + root.val
        self.res = max(total, self.res)
        bigger = max(right, left) + root.val
        return bigger if bigger > 0 else 0
~~~

## 128.最长连续序列

题目链接：[力扣-128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence)

### 思路1：使用并查集

> 1. 并查集知识点链接：[并查集](https://suwanzi.cn/categories/数据结构/#并查集)
>
> 2. 使用字典来记录遍历过的`num`，若再次遇到直接跳过
>
> 3. 有两种写法：
>
>    + 使用字典存储父节点信息，集合计数也是用字典存储。
>
>      ~~~python
>      import collections
>      class UF:
>          def __init__(self, nums):
>              self.dic = {num: num for num in nums}
>              self.count = {num: 1 for num in nums}
>      
>          def find(self, x):
>              if x != self.dic[x]:
>                  self.dic[x] = self.find(self.dic[x])
>              return self.dic[x]
>      
>          def merge(self, p, q):
>              if self.dic[p] == self.dic[q]:
>                  return
>              root_p = self.find(p)
>              root_q = self.find(q)
>              self.dic[root_p] = root_q
>              self.count[root_q] += self.count[root_p]
>              
>      class Solution:
>          def longestConsecutive(self, nums: List[int]) -> int:
>              if not nums:
>                  return 0
>              uf = UF(nums)
>              had = collections.defaultdict(int)
>              for num in nums:
>                  if num not in had:
>                      if num + 1 in uf.dic:
>                          uf.merge(num, num + 1)
>                  had[num] = 1
>              return max(uf.count.values())
>      ~~~
>
>    + 使用数组存储数字的索引，让索引代表具体数值。
>
>      ~~~python
>      import collections
>      class UF:
>          def __init__(self, size):
>              self.dic = [i for i in range(size)]
>              self.count = [1 for _ in range(size)]
>      
>          def find(self, x):
>              if x != self.dic[x]:
>                  self.dic[x] = self.find(self.dic[x])
>              return self.dic[x]
>      
>          def merge(self, p, q):
>              if self.dic[p] == self.dic[q]:
>                  return
>              root_p = self.find(p)
>              root_q = self.find(q)
>              self.dic[root_p] = root_q
>              self.count[root_q] += self.count[root_p]
>              
>      class Solution:
>          def longestConsecutive(self, nums):
>              if not nums:
>                  return 0
>              size = len(nums)
>              uf = UF(size)
>              had = collections.defaultdict(int)
>              for i in range(size):
>                  if nums[i] not in had:
>                      if nums[i] + 1 in had:
>                          uf.merge(i, had[nums[i] + 1])
>                      if nums[i] - 1 in had:
>                          uf.merge(i, had[nums[i] - 1])
>                      had[nums[i]] = i
>              return max(uf.count)
>      ~~~
>
>    + 注意两种写法判断是否`union`的条件是不一样的。
>
>      + 对第一种写法来讲，因为是用的字典来模拟的树结构。其实已经将所有的num值存在了`self.dic`中了，因此只需要
>
>        `if num + 1 in uf.dic`这一个判断语句，就可以判断`num`是否有相邻节点`num + 1`。在遍历完`nums`过后，就可以把所有相邻的节点都整合到一个集合里。
>
>      + 对于第二种写法，是用的`nums`的下标`i`来表示的具体数值，因此在遍历到`i`时，我们是不知道`nums[i]`是有小于他，或者大于他的邻接节点的。因此需要做两次判断，只做`nums[i] + 1`或者`nums[i] - 1`的判断，会造成节点错漏。假设有节点`1,2,3`，如果按照顺序加入上方的`had`字典，那么`1`先加入`had`，这时候`nums[i] + 1 = 2` 是没在`had`中的，同理`2,3`的`num[i] + 1 = 3, 4`也都没加入`had`。因此一次`merge`都不会发生。

### 思路2：使用字典

> 1. 使用字典`dic`记录包含`key`在内的序列长度，变量`res`记录最大序列长度
> 2. 以`key`为出发点，判断`key - 1`和`key + 1`是否在`dic`中。若在，则取其值`left = dic[key - 1]`及`right = dic[key + 1]`
> 3. 则包含`key`在内的最大序列长度`res = max(res, left + right + 1)`
> 4. 更新包含`key`在内序列的边界，即`dic[key - left] = left + right + 1`、`dic[key + right] = left + right + 1`

~~~python
class Solution:
    def longestConsecutive(self, nums):
        if not nums:
            return 0
        dic = {}
        res = 0
        for num in nums:
            if num not in dic:
                dic[num] = 1
                left = dic.get(num - 1, 0)
                right = dic.get(num + 1, 0)
                length = left + right + 1
                res = max(res, length)
                dic[num - left] = length
                dic[num + right] = length
        return res
~~~

## 139.单词拆分：

题目链接：[力扣-139.单词拆分](https://leetcode.cn/problems/word-break/description/)

### 思路1：dfs

> 1. 使用字典`dic`记录`wordDict`里面的所有单词，记录一个起始节点`index`
> 2. 确定终止条件
>    + 如果`index == size`，那么证明所有单词已经匹配完毕，直接`return True`
> 3. 参数和返回值：
>    + `dfs`的参数需要什么就加什么，不固定
>    + 返回值为`boolean`类型，即是否能完全匹配
> 4. 单层递归逻辑：
>    + 如果`s[index:i + 1]`在`dic`中，那么更新`index`，并进入下一层递归。

~~~python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dic = {word: len(word) for word in wordDict}
        size = len(s)
        return self.dfs(s, dic, 0, size)

    def dfs(self, s, dic, index, size):
        if index == size:
            return True
        for i in range(size):
            word = s[index:i + 1]
            if word in dic and self.dfs(s, dic, i + 1, size):
                return True
        return False
~~~

> 注意：上面的代码只能通过部分样例，如果字符串中重复的字母过多，且`wordDict`中包含这些重复的字符，那么会造成重复递归判断。造成超时
>
> 例如：`s = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`，`wordDict = [a, aa, aaa]`。可以预见的是，每个`a`、`aa`、`aaa`都会被重复判断好多次
>
> ![递归的树形图](/assets/images/Snipaste_2024-08-14_19-57-47.png)
>
> 优化：
>
> + 使用带记忆的递归，即使用一个状态字典，记录判断过的子字符串。
>
>   ![带记忆的递归](/assets/images/Snipaste_2024-08-14_19-58-49.png)
>
> + 记录`wordDict`中最长单词的长度`word_max`，一旦`s[index:i+1]`长度超过`word_max`，那么立即停止单层遍历

~~~python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dic = {word: len(word) for word in wordDict}
        word_max = max(dic.values())
        size = len(s)
        status = [None] * size
        return self.dfs(s, dic, 0, size, status, word_max)

    def dfs(self, s, dic, index, size, status, word_max):
        if index == size:
            return True
        if status[index] != None:  # 如果status[index]有值，证明已经验证过以s[index]开头的字符串组成的单词不符合题意
            return status[index]
        for i in range(index, size):
            word = s[index:i + 1]
            if i - index + 1 > word_max:
                break
            if word in dic and self.dfs(s, dic, i + 1, size, status, word_max):
                # status[index] = True 这一步是完全不需要的，因为只有递归到index == size才会执行到这里
                return True
        status[index] = False  # 记录从以s[index]开头的字符串组成的单词，在wordDict中不存在 
        return False
~~~

### 思路2：动态规划

> 1. 初始化状态：
>    + `dp[i]`表示前`i`个元素`s[0:i]`能否被`wordDict`表示，注意前`i`个元素下标是`0,1,2,...,i - 1`，不是到`i`
>    + 定义`dp`数组时，将其长度定为`size + 1`，不然初始化必须要找到`s[0:i] in wordDict`才能完成初始化
>    + 设有分割点`j`分割前`i`个元素，则若`dp[i]`能被表示，必有`dp[j] = True and s[j:i] in wordDict`。这里的`s[j:i]`从`j`开始，是因为把空字符串`""`也看成了前`j`个元素之一，即`s = '' + s`。因此前`j`个元素是不包含`s[j]`的
> 2. 状态转移方程：
>    + `dp[i] = dp[j] and s[j:i] in wordDict`
> 3. 初始化状态：
>    + `dp[0] = True`   当为空串时，空串肯定能被`wordDict`表示
> 4. 运行顺序：
>    + 先遍历`i`，再遍历`j`
> 5. 优化：
>    + 若有`s[j:i] in wordDict`，那么必有`i - j <= max(len(word))`，`word`为`wordDict`中的元素。因此`j`遍历起始点为`i - max(len(word)`不为`0`
>    + 当找到`dp[i] = True`时，立即`break`，后序没必要再遍历了

~~~python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        size = len(s)
        dp = [False] * (size + 1)
        dp[0] = True
        word_max = len(max(wordDict, key=len))
        for i in range(1, size + 1):
            start = 0 if i <= word_max else i - word_max
            for j in range(start, i):
                if dp[j] and s[j:i] in wordDict:
                    dp[i] = True
                    break
        return dp[-1]
~~~

## 141.环形链表

> 思路1：使用字典或者数组存下遍历过的`node`，若遍历过的`node`再次出现再字典或数组中，返回`True`
>
> 思路2：快慢指针，快指针追上慢指针，则返回`True`

~~~python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        pre = ListNode()
        pre.next = head
        slow, fast = pre, pre.next
        while slow != fast:
            if not fast or not fast.next:
                return False
            slow = slow.next
            fast = fast.next.next
        return True
~~~

> 思考：为什么快指针不每次按照`3`倍，`4`倍，甚至`n`倍的速度去跑？
>
> + 假设当`slow`入环时，和`fast`指针相距距离`k`。设环长度为`r`，`slow`走了`h`步后被追上，若要`fast`追上`slow`，则有
>   $$
>   \begin{aligned}
>               
>   k + h + nr = mh \\
>   h = \frac{\left(k + nr\right)}{m - 1}
>               
>   \end{aligned}
>   $$
>   
> + 可以看到上面的公式，如果`m = 2`，那么$h = k + nr$，当`fast`走的步数为$k,k + r, ... , k + nr$时，会被追到。最短走$k$步就被追到。
> + 如果$m > 2$，则要看 $k + nr$ 和 $m - 1$ 成整数倍关系才能追上。特别注意的是，如果 $m$ 为奇数，那么 $k = mv - v$ 肯定为偶数，$v$ 为慢指针走的距离，$m - 1$ 也为偶数，所以 $h$ 一定有整数值使得公式成立。
>   + 另一个角度去理解：如果 $m >= 3$，那么快指针很容易跨过慢指针，也就是追慢指针时，很容易从慢指针头上跳过去。

## 142.环形链表 $\mathrm{II}$

题目链接：[力扣-142.环形链表](https://leetcode.cn/problems/linked-list-cycle/description/)

> 假设相遇时圈外走的长度为`d1`，圈内走的长度为`d2`，圈的周长为`r`，那么有:
>
>
> $$
> \begin{aligned}
> slow = d1 + d2 + c_1r \\
> fast = d1 + d2 + c_2r \\
> \text{又有} \\
> fast = 2 * slow \\
> \text{那么} \\
> d1 + d2 + c_2r = 2(d1 + d2 + c_1r) \\
> \text{化简}\\ 
> d1 = (c_2 - c_1)r - d2 \quad \Rightarrow \quad d1 = (c_2 - c_1 - 1)r + (r - d2) \\
> \text{而}\quad r - d2\quad\text{是相遇点回到入口剩下的距离}
> \end{aligned}
> $$
>
> + 从上面公式可以看出，如果让节点重新从头节点`head`开始出发，同时让`fast`从相遇点以`slow`的速度继续开始往下遍历，那么当`head`走到环入口处时，`fast`正好也走到入口点

~~~python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = ListNode()
        pre.next = head
        slow, fast = pre, pre.next  # 这里是为了让 slow != fast，让while进入循环
        while slow != fast:
            slow = slow.next
            if not fast or not fast.next:
                return None
            fast = fast.next.next
        fast = fast.next  # 这里是因为上面为了让while进入循环，fast多走了一步
        while fast != pre:
            fast = fast.next
            pre = pre.next
        return pre
~~~

> 对于代码中找到相遇点后，`fast`多走一步的解释：
> $$
> \begin{aligned}
> d1 + d2 + c_2r - 1 = 2(d1 + d2 + c_1r) \\
> d1 = (c_2 - c_1 - 1)r + (r - (d2 + 1))
> \end{aligned}
> $$
> 从上面公式可以看出，`d1`为`d2`再向前走一步后，圈内剩下的步数

## 146.LRU缓存

题目链接：[力扣-146.LRU缓存](https://leetcode.cn/problems/lru-cache/description/)

> 1. 题目要求`get`和`put`都只有`O(1)`，那么首先想到的`get`就是字典，`put`能`O(1)`操作的就是双链表
> 2. 那么用字典`dic`的`key`存放输入的`key`，字典的`value`存放代表`(key,value)`在双链表中的，节点的地址
> 3. 在初始化双链表时，直接加虚拟头尾节点，这样在增删移动节点时，不需要判断前后条件是否存在。
> 4. `get()`过的节点需要移到链表头部，表示最近使用过，那么需要定义一个方法`moveToFirst`
> 5. `put()`进的节点肯定在链表头部，那么需要定义一个方法`addFirst`
> 6. 在操作完一个节点，或者`lru`达到最大容量时，需要删除最久没被用过的那个节点。因此需要定义一个方法`deleteNode`
> 7. `node`一定包含`key`和`value`两个值，不然在超出`lru`容量，需要删除最久未使用的节点时，在`dic`中会不知道删除哪个对应的`key`
> 8. 在下面的代码中，被注释掉的代码是因为，按照逻辑需要将移动的节点`node`在原地址删除，然后再移动。如果先移动，就算移动到头节点，原地址的前后节点还保存着对`node`的引用，这不符合双链表的逻辑。

~~~python
class double_list:
    def __init__(self, key, val):
        self.pre = None
        self.next = None
        self.key = key
        self.val = val


class LRUCache:

    def __init__(self, capacity: int):
        self.head = double_list(key=0, val=0)
        self.last = double_list(key=0, val=0)
        self.head.next = self.last
        self.last.pre = self.head
        self.cap = capacity
        self.count = 0
        self.lru = {}

    def get(self, key: int) -> int:
        if key not in self.lru:
            return -1
        self.moveToFirst(self.lru[key])
        return self.lru[key].val

    def put(self, key: int, value: int) -> None:
        if key not in self.lru:
            node = double_list(key=key, val=value)
            self.addFirst(node)
            self.lru[key] = node
            if self.cap < self.count:
                self.lru.pop(self.last.pre.key)
                self.deleteNode(self.last.pre)
        else:
            self.lru[key].val = value
            self.moveToFirst(self.lru[key])

    def addFirst(self, node):
        after = self.head.next
        self.head.next = node
        node.pre = self.head
        node.next = after
        after.pre = node
        self.count += 1

    def moveToFirst(self, node):
        # pre = node.pre
        # next = node.next
        self.deleteNode(node)
        self.addFirst(node)
        # pre.next = next
        # next.pre = pre

    def deleteNode(self, node):
        pre = node.pre
        after = node.next
        pre.next = after
        after.pre = pre
        node.next = None
        node.pre = None
        self.count -= 1
~~~

## 148.排序链表

题目链接：[力扣-148.排序链表](https://leetcode.cn/problems/sort-list/description/)

---

> 1. 复杂度为$n\log_2n$，那么考虑归并排序
> 2. 设置快慢指针，当`fast`跑到链表末端时，`slow`正好在链表中间
> 3. 将链表截断，分治进行合并
> 4. 注意`fast`停止的条件
>    + 因为链表是单向的，`slow`没办法回退上一个节点，若想让链表正确二分，则`slow`要在二分节点的前一个节点停下来，不然链表没法在中间断开
>    + 因此为了让`slow`少跑一步，则要增加判断条件`head.next.next != None`

~~~python
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        slow, fast = head, head
        while fast and fast.next and fast.next.next:
            fast = fast.next.next
            slow = slow.next
        half = slow.next
        slow.next = None
        return self.merge(self.sortList(head), self.sortList(half))

    def merge(self, list1, list2):
        pre = ListNode()
        head = pre
        while list1 and list2:
            if list1.val < list2.val:
                head.next = ListNode(list1.val)
                list1 = list1.next
            else:
                head.next = ListNode(list2.val)
                list2 = list2.next
            head = head.next
        head.next = list1 if list1 else list2
        return pre.next
~~~

## 155.最小栈

题目链接：[力扣-155.最小栈](https://leetcode.cn/problems/min-stack/description/)

> 1. 要求常数时间返回最小值，那么在初始化时就定义一个变量`self.minValue`保存最小值
> 2. 在栈中存储入栈数值和`self.minValue`的差值`diff`，这样在`pop()`和`push()`时能够还原所有数值
>    + 为什么要存入差值，不存入入栈时的原数值。是因为在`self.minValue`被`pop()`操作后，无法判断哪个数值是最小值了
>    + 而若存入差值，只有当`diff < 0`出现时，才需要更新`self.minValue`，而且能通过`diff`还原出新的最小值

~~~python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_value = 0

    def push(self, val: int) -> None:
        if self.stack:
            diff = val - self.min_value
            self.stack.append(diff)
            self.min_value = self.min_value if diff >= 0 else val
        else:
            self.stack.append(0)
            self.min_value = val

    def pop(self) -> None:
        diff = self.stack.pop()
        self.min_value = self.min_value if diff >= 0 else self.min_value - diff

    def top(self) -> int:
        return self.min_value if self.stack[-1] <= 0 else self.min_value + self.stack[-1]

    def getMin(self) -> int:
        return self.min_value
~~~

## 160.相交链表

> + 思路1：字典
>
>   + 存入链表`A`中每个节点的地址，然后遍历另一条链表`B`，若发现`B`中的节点在字典中存在，则返回该节点
>
> + 思路2：遍历相同长度的链表
>
>   + 先求出两条链表的长度，找出两只链表之间的长度差`diff`
>   + 让长的那支链表先跑`diff`步，然后同时遍历两只链表。遇到相等的节点，就返回该节点
>
> + 思路3：数学问题
>
>   + 假设相交节点到节点末尾的长度为`c`，链表`A`到相交节点的距离为`a`，链表`B`到相交节点的距离为`b`。
>
>   + 那么想让两条链表跑相同的距离再相遇，就让两条链表都跑`a + b + c`步。即让`A`跑完接着跑`B`，`B`跑完接着跑`A`，这样两条链表会在`a + b + c`处相遇
>
>   + 特别注意的是，如果两条链表都跑了`a + b + c`后，还没有相交节点，那么就证明两条链表不相交。因此两条链表都需要一个`None`节点来停止循环。
>
>   + 下面这种写法是错误的，因为如果遇到不相交的链表，`preA`和`preB`一直会被`headA`和`headB`赋值进入死循环。所以需要`preA == preB == None`这个条件来停下来
>
>     ~~~python
>     preA = preA.next if preA.next else headB
>     preB = preB.next if preB.next else headA
>     ~~~
>
>     

~~~python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        preA, preB = headA, headB
        while preA != preB:
            preA = preA.next if preA else headB
            preB = preB.next if preB else headA
        return preA
~~~

## 169.多数元素

> 1. 思路1：字典
>    + 字典记录每个元素的`count`，超过一半直接返回该元素
> 2. 思路2：兑子游戏
>    + 即只要不相同的元素，就互相兑子，`count`减一
>    + 当`count`为`0`时，更新被兑子的元素，并将`count`置`1`

~~~python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 1
        more = nums[0]
        size = len(nums)
        for i in range(1, size):
            if nums[i] != more:
                if count > 0:
                    count -= 1
                if count == 0:
                    more = nums[i]
                    count = 1
            else:
                count += 1
        return more
~~~

## 打家劫舍

### 198.打家劫舍 $\mathrm{I}$

题目链接：[力扣-198.打家劫舍 $\mathrm{I}$](https://leetcode.cn/problems/house-robber/description/)

> 1. 初始化状态：
>    + `dp[i]`表示打劫到第 `i` 家能打劫到的最多的钱
>    + 若打劫第`i`家，则第`i - 1`家显然不能偷，那么只能由`dp[i - 2]`和`nums[i]`决定
>    + 若不打劫第`i`家，则状态由`dp[i - 1]`决定
> 2. 状态转移方程：
>    + `dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])`
> 3. 数组初始化：
>    + `dp[0] = nums[0]`
>    + `dp[1] = max(nums[0] ,nums[1])`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def rob(self, nums: List[int]) -> int:
        size = len(nums)
        if size == 1:
            return nums[0]
        dp = [0] * size
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, size):
            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])
        return dp[-1]
~~~

### 213.打家劫舍 $\mathrm{II}$

题目链接：[力扣-213.打家劫舍$\mathrm{II}$](https://leetcode.cn/problems/house-robber-ii/description/)

> 1. 和打家劫舍$\mathrm{I}$一样定义状态，只是用两个数组来分别考虑取`nums[0]`和`nums[-1]`的两种情况
> 2. 状态转移方程：
>    + `dp[0][i] = max(dp[0][i - 2] + nums[i], dp[0][i - 1])`
>    + `dp[1][i] = max(dp[1][i - 2] + nums[i], dp[1][i - 1])`
> 3. 初始化数组：
>    + `dp[0][0] = nums[0]`
>    + `dp[0][1] = max(nums[0], nums[1])`
>    + `dp[1][0] = 0`
>    + `dp[1][1] = nums[1]`
> 4. 运行顺序：
>    + 从左到右
> 5. 注意：
>    + 在返回最终结果比较最大值是，是比较的` max(dp[0][size - 2], dp[1][-1])`，而不是` max(dp[0][-1], dp[1][-1])`

~~~python
class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        size = len(nums)
        if size < 3:
            return max(nums)
        dp = [[0]*size for _ in range(2)]
        dp[0][0] = nums[0]
        dp[0][1] = max(nums[0], nums[1])
        dp[1][1] = nums[1]
        for i in range(2, size):
            dp[0][i] = max(dp[0][i - 2] + nums[i], dp[0][i - 1])
            dp[1][i] = max(dp[1][i - 2] + nums[i], dp[1][i - 1])
        return max(dp[0][size - 2], dp[1][-1])
~~~

### 337.打家劫舍 $\mathrm{III}$

#### 思路一：动态规划

>1. 初始化状态：
>
>     + 跟前两个打家劫舍类似，使用一个变量记录遍历到当前节点能打劫到的最多的钱。
>
>
>     + 那么遍历到当前节点就只有两种状态，一种是打劫当前节点，另一种是不打劫当前节点。那么自然可以想到使用一个长度为`2`的数组来记录两种状态。考虑到是二叉树，那么就使用数组`left`记录左子树返回的两种状态，同样用`right`记录右子树
>    
>     + 如果打劫当前节点，那么就不能打劫两个子节点，即打劫当前节点的状态只能由孙子节点决定，也就是说是不打劫子节点的那个变量决定。`stolen = left[1] + right[1] + root.val`
>    
>     + 如果不打劫当前节点，那么孙子节点打不打劫都是可以的，即`nostolen = max(left) + max(right)`
>
>
>2. 状态转移方程：
>
>     + `stolen = left[1] + right[1] + root.val`
>
>     + `nostolen = max(left) + max(right)`
>
>
>3. 初始化状态：
>     + 当`root == None`时，返回`[0, 0]`
>
>
>4. 运行顺序：
>     + 自底向上，离开双节点时更新状态，即后序遍历
>

~~~python
class Solution:
    def rob(self, root):
        return max(self.traverse(root))
    
    def traverse(self, root):
        if not root:
            return [0, 0]
        left = self.traverse(root.left)
        right = self.traverse(root.right)
        stolen = left[1] + right[1] + root.val
        nostolen = max(left) + max(right)
        return [stolen, nostolen]
~~~

#### 思路二：暴力递归遍历

> 1. 既然相邻层不能偷，那么当前节点能偷到的最多的钱有两种情况
>    + 偷当前节点，那么只能偷当前节点和孙子节点。
>    + 不偷当前节点，那么偷儿子节点
>    + 比较种情况中的最大值，则为当前节点能偷到的最大值
> 2. 在离开左右子节点时做最大值的判断，即后序遍历。
> 3. 递归三部曲：
>    + 终止条件：当`root == None`时，啥也偷不到，终止。
>    + 参数和返回值：
>      + 参数：传入根节点`root`
>      + 返回值：返回当前节点能到的最大的钱
>    + 单层递归逻辑：比较第`1`点中两种情况，获取最大值然后返回给上一层

~~~python
class Solution:
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        return self.traverse(root)

    def traverse(self, root):
        if not root:
            return 0
        grandSonLeft = 0
        grandSonRight = 0
        if root.left:
            grandSonLeft = self.traverse(root.left.left) + self.traverse(root.left.right)
        if root.right:
            grandSonRight = self.traverse(root.right.left) + self.traverse(root.right.right)
        grandFather = root.val
        son = self.traverse(root.left) + self.traverse(root.right)
        return max(son, grandFather + grandSonLeft + grandSonRight)
~~~

> 1. 上面的代码只通过了部分样例，在遇到树深的样例时运行超时
> 2. 优化：
>    + 可以看到在从上往下进行遍历时，每个节点有三种身份。即`grandFather`节点，`son`节点，`grandson`节点。因此在向上返回时，只要返回到该节点的祖先节点，该节点的这三个身份都会被重新计算一遍
>    + 因此可以定义一个带记忆的递归，记录遍历到当前节点时所能偷到的最大值，再次遍历到该节点时，直接返回。因为是树结构，因此直接考虑字典，`key`为节点地址，`value`为能偷到的最大值

~~~python
class Solution:
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.dic = {}
        return self.traverse(root)

    def traverse(self, root):
        if not root:
            return 0
        if root in self.dic:
            return self.dic[root]
        grandSonLeft = 0
        grandSonRight = 0
        if root.left:
            grandSonLeft = self.traverse(root.left.left) + self.traverse(root.left.right)
        if root.right:
            grandSonRight = self.traverse(root.right.left) + self.traverse(root.right.right)
        grandFather = root.val
        son = self.traverse(root.left) + self.traverse(root.right)
        max_stolen = max(son, grandFather + grandSonLeft + grandSonRight)
        self.dic[root] = max_stolen
        return max _stolen
~~~

### 2560.打家劫舍 $\mathrm{IV}$

题目链接：[力扣-2560.打家劫舍$\mathrm{IV}$](https://leetcode.cn/problems/house-robber-iv/description/)

>1. 要使得小偷某次偷窃行动结束后，能够偷窃的单个房间的最大值，在所有偷窃方案中的单个房间偷窃的最大值中最小
>   + 小偷有多种偷窃方案$p_1,p_2,p_3,...,p_n$，在每种偷窃方案中的单个房价能偷到的最大值为$v_1,v_2,v_3,...,v_n$
>   + 那么所求的就是在这些方案中，找出方案$p_i$使得$v_j$最小
>2. 题目加了一个约束条件，即能偷的最小房间个数不得小于`k`。而对于小偷来讲，$v_j$越小则能偷的房间数就越小，是正比关系
>3. 那么我们就可以通过能偷到的最大房间数来逼近`k`。自然，其能偷的房间会一起被约束。而能偷到的最大房间数我们是可以转化成`dp`问题的
>   + 初始化状态：
>     + `dp[i]`表示偷到第`i`个房间时，能偷的最大房间数。我们可以用`dp[i]`的值来逼近`k`，`dp[i]`值越接近`k`，证明能偷的最大值$v_j$越小
>   + 状态转移方程：
>     + `dp[i] = dp[i - 1]`	当`nums[i] > `$v_j$时，因为约束条件，房间`i`是不能偷的，因此`dp[i]`状态取决于`dp[i - 1]`
>     + `dp[i] = max(dp[i - 1], dp[i - 2] + 1)`         当`nums[i] <= `$v_j$时，房间`i`可偷，因此就是经典的打家劫舍问题了
>   + 初始化状态：
>     + `dp[0] = 1`	当`nums[0] <= `$v_j$时，房间`0`可偷
>     + ~~`dp[1] = 1`        当`nums[1] <= `$v_j$时，房间`1`可偷，为`1`。房间`0`可偷，也只能偷一个房间，为`1`。房间`0`不可偷，房间`1`可偷，为`1`~~
>     + `dp[1] = 1 if nums[1] <= `$v_j$`or dp[0] == 1`，上面删除线部分未考虑当`nums[1] >` $v_j$时，房间`i`可偷的情况
>   + 运行顺序：从左到右
>4. 对于`2`，既然要搜寻一个合适的$v_j$，来使得能偷的房间数逼近`k`，那么可考虑使用二分查找加速搜索过程。（经典的最大值最小化问题，知识点：[最大化最小值问题](https://suwanzi.cn/categories/数据结构/#最大化最小值或最小化最大值)）
>5. 那么二分查找出来的数值，会不会不存在于数组`nums`中呢？ 2
>   + 设答案为 `ans`，那么当最大金额为 `ans `时，可以偷至少 `k`间房子。如果 `ans `不在 `nums `中，那么当最大金额为 `ans−1` 时，也可以偷至少 `k`间房子，假如`ans - 1`也不在`nums`中，那么`ans - 2`也可以偷`k`间房子，一次类推到`nums[i]`在`nums`中。那么有`nums[i] =< res <= ans`这个区间的答案都符合题意，这与二分算法相矛盾：根据视频中讲的[红蓝染色法](https://www.bilibili.com/video/BV1AP41137w7/?vd_source=cb427266333ff90bbe3b3969c8065151)，循环结束时，`ans `和 `ans−1` 的颜色必然是不同的，即 `ans `可以满足题目要求，而 `ans − 1` 不满足题目要求（其实更新完`left`和`right`时，要么在`target`左边界，要么在右边界，终止的`left`和`right`是不可能处在边界中间的）。所以，二分出来的答案，一定在 `nums`中。

~~~python
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        return self.findMinMax(nums, k, 0, max(nums), self.dpFuc)

    def findMinMax(self, nums, target, left, right, func):
        while left <= right:
            mid = left + (right - left) // 2
            if func(maxVal=mid, nums=nums) >= target:
                right = mid - 1
            else:
                left = mid + 1
        return right + 1

    def dpFuc(self, maxVal, nums):
        size = len(nums)
        dp = [0] *  size
        if nums[0] <= maxVal:
            dp[0] = 1
        if nums[1] <= maxVal:
            dp[1] = 1

        for i in range(2, size):
            if nums[i] > maxVal:
                dp[i] = dp[i - 1]
            else:
                dp[i] = max(dp[i - 2] + 1, dp[i - 1])
        return dp[-1]
~~~

## 200.岛屿数量

题目链接：[力扣-200.岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)

> 思路1：DFS
>
> + 四个方向搜索，使用状态数组记录搜索过的节点
> + 当新一轮的搜索开始时，岛屿计数加一

~~~python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        guides = [[1, 0], [-1, 0], [0, -1], [0, 1]]
        m, n = len(grid), len(grid[0])
        status = [[False] * n for _ in range(m)]
        count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1' and not status[i][j]:
                    count += 1
                    self.dfs(grid, guides, status, m, n, i, j)
        return count
    
    def dfs(self, grid, guides, status, m, n, i, j):
        status[i][j] = True
        for guide in guides:
            x = guide[0] + i
            y = guide[1] + j
            if x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == '1' and not status[x][y]:
                self.dfs(grid, guides, status, m, n, x, y)
~~~

> 思路2：并查集
>
> + 并查集知识点链接：[并查集](https://suwanzi.cn/categories/数据结构/#并查集)
>
> 1. 将坐标转换为字符串作为节点值
>    + 字符串不能直接使用`str(i) + str(j)`这种作为节点值，比如`str(1) + str(11)`与`str(11) + str(1)`会长生相同的节点值。因此使用`str(i) + '|' + str(j)`
> 2. 经典遍历矩阵时的四个方向`[[1, 0], [-1, 0], [0, 1], [0, -1]]`，如果新坐标为`1`那么`merge`
> 3. 最后再将所有节点`find`碾平一次，保证每个集合的树深为`2`
> 4. 将表示节点树的字典`dic`的值装入`set`，`set`中有多少值就有多找个岛屿

~~~python
class UF:
    def __init__(self, grid, m, n):
        self.dic = {}
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    self.dic[str(i) + '|' + str(j)] = str(i) + '|' + str(j)

    def find(self, x):
        if self.dic[x] != x:
            self.dic[x] = self.find(self.dic[x])
        return self.dic[x]

    def merge(self, p, q):
        rootp = self.find(p)
        rootq = self.find(q)
        if rootp == rootq:
            return
        if p == rootp:
            self.dic[rootp] = rootq
        else:
            self.dic[rootq] = rootp

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0])
        uf = UF(grid, m, n)
        guides = [[1, 0], [-1, 0], [0, 1], [0, -1]]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    for guide in guides:
                        x = guide[0] + i
                        y = guide[1] + j
                        if x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == '1':
                            uf.merge(str(i) + '|' + str(j), str(x) + '|' + str(y))
        for key in uf.dic.keys():
            uf.find(key)
        return len(set(uf.dic.values()))
~~~

> 并查集优化：
>
> 1. 不需要遍历四个方向，如果遍历`[-1, 0], [0, -1]`相当于往回走了，这是重复遍历。
> 2. 当使用`str(i) + '|' + str(j)`会有字符串的操作，可以直接使用元组作为节点值`(i, j)`
> 3. `UF`函数设置一个变量`self.count`，在初始化节点值时，每个为`1`的节点都是一个单独的岛屿，所以`self.count`初始化为`1`的个数。当进行一次合并时`self.count`减一，最后返回`self.count`
> 4. 既然不需要`[-1, 0], [0, -1]`那么判断条件就不需要`x >= 0`和`y >= 0`了

~~~python
class UF:
    def __init__(self, grid, m, n):
        self.dic = {}
        self.count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    self.dic[(i, j)] = (i, j)
                    self.count += 1

    def find(self, x):
        if self.dic[x] != x:
            self.dic[x] = self.find(self.dic[x])
        return self.dic[x]

    def merge(self, p, q):
        rootp = self.find(p)
        rootq = self.find(q)
        if rootp == rootq:
            return
        self.dic[rootp] = rootq
        self.count -= 1

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0])
        uf = UF(grid, m, n)
        guides = [[1, 0], [0, 1]]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    for guide in guides:
                        x = guide[0] + i
                        y = guide[1] + j
                        if  x < m and  y < n and grid[x][y] == '1':
                            uf.merge((i, j), (x, y))
        return uf.count
~~~

## 206.反转链表

### 单链表

题目链接：[力扣-206.反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)

> 1. 用临时节点`temp`存储头节点的`next`
> 2. 让`head`节点的下一个 节点等于当前节点
> 3. 更新当先节点为`head`
> 4. 更新`head`为`1`中的`temp`

~~~python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = None
        while head:
            temp = head.next
            head.next = pre
            pre = head
            head = temp
        return pre
~~~

### 双链表

> 1. `pre`更新为当前节点的`next`
> 2. 其余更新`next`步骤和单链表一样

~~~python
class Solution:
    def reverseList(self, head):
        pre = None
        while head:
            temp = head.next  # 1、保存当前节点的下一个节点信息，便于遍历head和反转当前节点的pre指针
            head.next = pre  # 当前节点的next指针指向上一个节点
            head.pre = temp  # 当前节点的pre指针指向next节点，完成反转
            pre = head  # 将新链表的头节点变为当前节点
            head = temp
        return pre
~~~

## 课程表

### 207.课程表 $\mathrm{I}$

题目链接：[力扣-207. 课程表](https://leetcode.cn/problems/course-schedule)

> 思路1：DFS
>
> 1. 使用字典`dic`创建图，`key`为节点，`value`为子节点组成的数组
>
> 2. 遍历`prerequisites`，以其`prerequisites[i][1]`为起点，以`prerequisites[i][0]`为终点。如果从图中`prerequisites[i][1]`出发，能达到`prerequisites[i][0]`，则证明能学到课程`prerequisites[i][0]`
>
> 3. 使用字典`status`记录遍历过的节点，如果一个节点遇到两次则存在环，终止`DFS`
>
> 4. 如果遍历完`prerequisites`还未返回`False`，则证明课程能全部学完，返回`True`
>
>    + ~~~python
>      class Solution:
>          def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
>              graph = {}
>              size = len(prerequisites)
>              for i in range(size):
>                  prerequisite = prerequisites[i]
>                  if graph.get(prerequisite[1]):
>                      graph[prerequisite[1]].append(prerequisite[0])
>                  else:
>                      graph[prerequisite[1]] = [prerequisite[0]]
>        
>              for i in range(size):
>                  status = {}
>                  prerequisite = prerequisites[i]
>                  status[prerequisite[1]] = False
>                  if not self.dfs(graph, prerequisite[1], prerequisite[0], status):
>                      return False
>              return True
>            
>          def dfs(self, graph, start, end, status):
>              if start == end:
>                  return True
>              if status[start]:
>                  return False
>              sons = graph[start]
>              for son in sons:
>                  if son not in status or not status[son]:
>                      status[son] = True
>                      if self.dfs(graph, son, end, status):
>                          return True
>                      status[son] = False
>              return False
>
> 5. 错因：上述关于遍历`prerequisites`和使用`status`的思路是错误的
>
>    + 以`prerequisites[i][1]`为起点，以`prerequisites[i][0]`为终点，没有考虑到这两个点正好在环上的情况
>      + 如果正好在环上，以`start == end`来判断是否返回`True`会得到错误结果
>      + 如果不以`start == end`作为判断依据，那么想不到用什么做判断依据了
>    + 以`status`作为记录状态，每次判断`prerequisites[i]`便会重新创建状态，那遍历过的状态会消失。假如起始点和终点都在环上，那么丢失的状态可能会导致检测不出环
>
> 6. 修正：
>
>    + 以字典创建图`graph`，遍历以`0 -> numCourse - 1`节点为起始节点（记为节点`k`）的路径。如果无论从哪个节点出发，都不会有循环，则证明不存在环。那么意味着每个课程之间没有相互作为前置条件，则都能学习
>
>    + 使用状态数组`status`记录访问过的节点。
>
>      + `status[i] == 0`，表示该节点未被访问
>      + `status[i] == 1`，表示遍历从`k`节点出发的这轮遍历，经过了`i`节点
>      + `status[i] == -1`，表示从`i`节点开始遍历图，不存在环，从别的节点遍历过来就不需要继续往下遍历了，减少遍历次数
>
>    + 递归遍历的三部曲：
>
>      + 终止递归条件：
>        + 当发现`status[i] == 1`，那么证明从节点`k`出发的遍历出现了环，`retrun False` 
>        + 当发现`status[i] == -1`，那么表示从节点`k`出发的遍历遇到了确认不会出现换的节点，`return True`
>      + 参数和返回值：`DFS`按需添加参数，返回值为布尔值
>      + 单层递归逻辑：
>        + 在进入节点`i`，判断是否终止递归后，将`status[i]`标记为`1`。
>        + 遍历节点`i`的子节点，判断是否存在环，存在则`return Fasle`
>        + 如果子节点递归返回时，都返回`True`，那么证明从节点`i`开始往后遍历，都不存在环。那么在离开节点`i`时，将`status`标记为`-1`
>        + 结束单层遍历后，发现无环，那么向上层返回`True`
>
>    + 在单层遍历中，不能判断某个子节点无环就返回`True`
>
>      + 这样即使某个子节点有环，而另一个子节点无环也会返回`True`。因为只要有一条路返回`True`那么节点`i`队递归返回时就为`True`
>
>      + 状态数组`status`也无法标记为`-1`，如果标记为`-1`的话，单层遍历结束表示子节点全部有环，才会执行到这一步。
>
>      + 即下面的写法是错误的：
>
>        ~~~python
>        for son in sons:
>            if self.dfs(graph, son, status):
>                return True
>        status[index] = -1
>        return False
>        ~~~

~~~python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = {}
        size = len(prerequisites)
        for i in range(size):
            prerequisite = prerequisites[i]
            if graph.get(prerequisite[1]):
                graph[prerequisite[1]].append(prerequisite[0])
            else:
                graph[prerequisite[1]] = [prerequisite[0]]
        status = [0] * numCourses
        for i in range(numCourses):
            if i in graph:
                if not self.dfs(graph, i, status):
                    return False
        return True

    def dfs(self, graph, index, status):
        if status[index] == 1:
            return False
        if status[index] == -1 or index not in graph:
            return True
        status[index] = 1
        sons = graph[index]
        for son in sons:
            if not self.dfs(graph, son, status):
                return False
        status[index] = -1
        return True
~~~

> 思路2：BFS
>
> 1. 使用字典创建图`graph`，并使用另一个字典记录每个节点的入度`indegrees`
> 2. 入栈入度为`0`的节点，当这些节点出栈时，其子节点的入度减一
> 3. 循环操作`2`，直到栈为空。
> 4. 遍历`indegrees`，如果有节点入度不为`0`，那么返回`Fasle`

**注意：**使用`queue`相较于`collections`的`deque`会比较慢，因为`queue`有加锁操作，比较慢。而`deque`底层是双链表，操作复杂度为`O(1)`

~~~python
# import queue
# from typing import List
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = {}
        indegrees = {}
        size = len(prerequisites)
        for i in range(size):
            prerequisite = prerequisites[i]
            if graph.get(prerequisite[1]):
                graph[prerequisite[1]].append(prerequisite[0])
            else:
                graph[prerequisite[1]] = [prerequisite[0]]

            if indegrees.get(prerequisite[0]):
                indegrees[prerequisite[0]] += 1
            else:
                indegrees[prerequisite[0]] = 1

        # que = queue.Queue()
        que = collections.deque()
        for key in graph.keys():
            if key not in indegrees.keys():
                # que.put(key)
                que.append(key)
        # while not que.empty():
        while que:
            # pre = que.get()
            pre = que.pop()
            if pre in graph:
                for son in graph[pre]:
                    indegrees[son] -= 1
                    if indegrees[son] == 0:
                        # que.put(son)
                        que.append(son)
        for val in indegrees.values():
            if val > 0:
                return False
        return True
~~~

### 210.课程表 $\mathrm{II}$

题目链接：[力扣-210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii)

> 思路：BFS
>
> 1. 创建图`graph`和入度表`indegrees`
> 2. 将入度为`0`的节点入栈`que`，然后出栈。
> 3. 在出栈时，将出栈节点的子节点入度减一，并用`res`收集出栈的节点。重复`2、3`过程，直到栈空
> 4. 判断入度标`indegrees`是否还有节点度不为`0`，如果不为零则表示有环，按题意返回`[]`
> 5. 遍历`0 -> numCourse - 1`，如果`res`不包含`0 -> numCourse - 1`里的数，那么添加进`res`

~~~python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = {}
        indegrees = {}
        res = []
        for x, y in prerequisites:
            if graph.get(y):
                graph[y].append(x)
            else:
                graph[y] = [x]
            if indegrees.get(x):
                indegrees[x] += 1
            else:
                indegrees[x] = 1
        que = collections.deque()
        for key in graph.keys():
            if key not in indegrees:
                que.append(key)
        while que:
            pre = que.pop()
            res.append(pre)
            if pre in graph:
                for son in graph[pre]:
                    indegrees[son] -= 1
                    if indegrees[son] == 0:
                        que.append(son)
        for val in indegrees.values():
            if val > 0:
                return []
        for i in range(numCourses):
            if i not in res:
                res.append(i)
        return res
~~~

> 优化：
>
> 1. 可以考虑使用数组来作为入度表，给每个节点初始化一个为`0`的入度。简化后序根据入读表判断是否有环和`res`中缺少课程号的过程
> 2. 使用`collections`的`defaultDict`，这样就不用考虑`key`是否存在的问题

~~~python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = collections.defaultdict(list)
        indegrees = [0] * numCourses
        res = []
        for x, y in prerequisites:
            graph[y].append(x)
            indegrees[x] += 1
        que = collections.deque()
        for i in range(numCourses):
            if indegrees[i] == 0:
                que.append(i)
        while que:
            pre = que.pop()
            res.append(pre)
            for son in graph[pre]:
                indegrees[son] -= 1
                if indegrees[son] == 0:
                    que.append(son)
        if numCourses != len(res):
            return []
        return res
~~~

> 思路2：DFS
>
> 1. 因为上课的顺序是有顺序的，所以说返回的结果`res`需要考虑顺序的正确性。
>    + 对于`207`中验证环的顺序，如果在进入递归时将`index`加入`res`，那么并不能保证顺序性，因为`index`小的课程号并不一定为必须先修的课程。
>    + 如果在离开时将`index`加入`res`，那么根据递归的特性，相当于先将后修的课程加入`res`，再加入前置课程`index`。这样得出的顺序和课程选修顺序是相反的。那么在返回`res`时，需要将`res`取反
> 2. 基于以上讨论，我们可以建立逆序表，在离开递归时将`index`加入`res`，这样可以省下将`res`取反的步骤
> 3. 判断环的方式和`207`一样，如果存在环直接返回`[]`

~~~python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = collections.defaultdict(list)
        for x, y in prerequisites:
            graph[x].append(y)
        status = [None] * numCourses
        res = []
        for i in range(numCourses):
            if not self.dfs(graph, status, res, i):
                return []
        return res

    def dfs(self, graph, status, res, index):
        if status[index] == 1:
            return False
        if status[index] == -1:
            return True
        status[index] = 1
        for son in graph[index]:
            if not self.dfs(graph, status, res, son):
                return False
        status[index] = -1
        res.append(index)
        return True
~~~

### 630.课程表 $\mathrm{III}$

题目链接：[力扣-630. 课程表 III](https://leetcode.cn/problems/course-schedule-iii)

> 思路：堆 + 排序
>
> 1. 对于上课来讲，肯定是`DDL`越早的课，越需要先被上完。基于这一点可以考虑通过`courses[i][1]`来进行排序，将`courses[i][1]`小的排在前面
> 2. 那么往后遍历时，肯定会遇到上课时间短，但是`DDL`又很大的`courses[i]`。
>    + 课时短的课程应该是要先被考虑的，如果前面课时长而`DDL`又小的课被上了，那么累计课时大于当前课时的`DDL`，这门课就上不成了
>    + 所以考虑到这点，我们应该允许反悔。即放弃课时最长的那门课，选课时较短的这门课。即用一个大顶堆维护已选课程

~~~python
class Heap:
    def __init__(self):
        self.count = 0
        self.nums = []
        self.build_heap()
    
    def build_heap(self):
        size = len(self.nums)
        for i in range(size):
            self.up(i)
        self.count = size

    def up(self, index):
        while index > 0 and (index - 1) // 2 >= 0:
            temp = (index - 1) // 2
            if self.nums[index][0] > self.nums[temp][0]:
                self.nums[index], self.nums[temp] = self.nums[temp], self.nums[index]
            index = temp

    def down(self, end):
        start = 0
        while 2 * start + 1 <= end:
            temp = 2 * start + 1
            if temp + 1 <= end and self.nums[temp + 1][0] > self.nums[temp][0]:
                temp += 1
            if self.nums[start][0] > self.nums[temp][0]:
                break
            self.nums[start], self.nums[temp] = self.nums[temp], self.nums[start]
            start = temp

    def push(self, val):
        if self.count < len(self.nums):
            self.nums[self.count] = val
        else:
            self.nums.append(val)
        self.up(self.count)
        self.count += 1

    def pop(self):
        if self.count ==  0:
            return None
        val = self.nums[0]
        # self.count -= 1
        if self.count > 1:
            self.nums[0] = self.nums[self.count - 1]
            if self.count > 2:
                self.down(self.count - 2)
        self.count -= 1
        return val

class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        courses = sorted(courses, key=lambda x: x[1])
        heap = Heap()
        study = 0
        count = 0
        for x, y in courses:
            if x <= y:
                if study + x <= y:
                    study += x
                    count += 1
                    heap.push([x, y])
                else:
                    if x < heap.nums[0][0] and study - heap.nums[0][0] + x <= y:
                        val = heap.pop()
                        heap.push([x, y])
                        study = study - val[0] + x
        return count
~~~

### 1462.课程表 $\mathrm{IV}$

题目链接：[力扣-1462.课程表 $\mathrm{IV}$](https://leetcode.cn/problems/course-schedule-iv)

> 思路1：DFS
>
> 1. 跟`207,210`思路一样，使用字典`graph`模拟图。因为题目说明了无环，那么不需要记录状态。因此不需要`status`
>
> 2. 以`queries[i][0]`为起点`start`，以`queries[i][1]`为终点`end`，遍历`graph`，并将遍历结果返回。使用`res`收集
>
> 3. 递归三部曲：
>
>    + 终止递归条件：`start == end`或者遍历到图的无子节点的位置，返回
>
>    + 参数和返回值：`DFS`参数看情况添加，返回值为布尔值
>
>    + 单层递归逻辑：
>
>      + 当`start == end`时，返回`True`
>      + 继续往下遍历`graph[start]`的子节点，直到`start == end`或者无子节点
>      + 若遍历完自己点都找不到`start == end`，那么返回`False`
>
>    + ~~~python
>      class Solution:
>          def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
>              graph = collections.defaultdict(list)
>              res = []
>              for x, y in prerequisites:
>                  graph[x].append(y)
>              for i, j in queries:
>                  res.append(self.dfs(i, j, graph))
>              return res
>                  
>          def dfs(self, start, end, graph):
>              if start == end:
>                  return True
>              for son in graph[start]:
>                  if self.dfs(son, end, graph):
>                      return True
>              return False
>      ~~~
>
> 4. 修正：上面的代码运行超时
>
>    + 分析原因，假设`queries`有`[3, 20], [1, 20]`两个查询选项，那么代码会在`graph`中重复遍历两次`3 -> 20`的路径。
>    + 因此我们需要将遍历过的路径记下来，下次遇到就直接返回结果。
>      + 考虑使用字典记录能否从`a -> b`，如果使用字典，那么键`a`对应的`value`为一个数组，在查询时需要遍历数组，还是耗时
>      + 在标记路径时，可以考虑使用二维数组，用坐标`(a, b)`表示是否联通
>    + 由于`DFS`是层层递归，因此在离开节点时，我们将坐标状态记录在`status`状态表中，防止重复遍历。
>      + 那么意味着我们需要在这一层就要将以`index`开始，到后序的所有子节点的路径都要存储到二维数组`path`中
>      + 因此在子节点递归返回后，遍历节点`0 -> numCourses - 1`，确认`path[index][0 -> numCourses - 1]`的状态。而`index`的子节点肯定是包含在`0 -> numCourses - 1`中的，因此遍历了`0 -> numCourses - 1`就相当于确认了所有`index`子路径的状态。在递归返回时，`index`子路径的状态已经是被确定了，因此`index`到子节点的状态也肯定能被确定
>    + 在经过`DFS`后，所有状态都被确定，因此直接遍历`queries`查询`queries[i][0], queries[i][1]`对应的状态即可

~~~python
class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        graph = collections.defaultdict(list)
        res = []
        path = [[False] * numCourses for _ in range(numCourses)]
        status = [False] * numCourses
        for x, y in prerequisites:
            graph[x].append(y)
        for i in range(numCourses):
            self.dfs(i, graph, path, status, numCourses)
        for i, j in queries:
            res.append(path[i][j])
        return res

    def dfs(self, index, graph, path, status, numCourses):
        if status[index]:
            return True
        for son in graph[index]:
            path[index][son] = True
            self.dfs(son, graph, path, status, numCourses)
            for i in range(numCourses):
                path[index][i] = path[index][i] or path[son][i]  # 注意和BFS的区别，DFS自底向上，因此递推关系为 index -> son -> i
        status[index] = True
~~~

> 思路2：BFS
>
> 1. 使用字典模拟图`graph`，然后使用数组`indegrees`记录每个节点的入度。
> 2. 将入度为零的节点存入一个队列`que`，使用`while`循环出队列。
> 3. 在出列时，遍历出列节点的子节点，并使用一个二维数组`path`记录出列节点`pre`和子节点`son`的链接关系
>    + 此时`path[pre][son]`之间的链接关系已被确定。那么是`pre`的前驱节点的，也肯定是`son`的前驱节点
>    + 那么有`path[i][son] = path[i][son] or path[i][pre]`
> 4. 若`son`的入度为零，那么将`son`入队列
> 5. 遍历`queries`，将查询结果返回

~~~python
class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        graph = collections.defaultdict(list)
        res = []
        path = [[False] * numCourses for _ in range(numCourses)]
        indegrees = [0] * numCourses
        for x, y in prerequisites:
            graph[x].append(y)
            indegrees[y] += 1
        que = collections.deque()
        for i in range(numCourses):
            if indegrees[i] == 0:
                que.append(i)
        while que:
            pre = que.pop()
            for son in graph[pre]:
                path[pre][son] = True
                for i in range(numCourses):
                    path[i][son] = path[i][son] or path[i][pre]  # 注意和DFS的区别，BFS从上到下，因此递推关系为 i -> pre -> son
                indegrees[son] -= 1
                if indegrees[son] == 0:
                    que.append(son)
        for i, j in queries:
            res.append(path[i][j])
        return res
~~~

## 208.前缀树

题目链接：[力扣-208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree)

> 1. 因为单词只包含小写字母，那么可以用一个长度为`26`的数组模拟`26`个字母。
> 2. 在`index`位置存放一个`Trie`对象，然后把指针指向这个空对象，以便下一个字母来时，给其赋值（跟创建链表一个思路）
> 3. 在查询时，按照遍历链表的方式遍历前缀树。现在思考一个问题，什么时候停止呢？
>    + 如果遇到`word`里面的字母在`Trie`中的数组不存在，那么返回`False`
>    + 如果`word`中每个字符都在`Trie`中有匹配，为了保证匹配的不是某个单词的前缀，所以需要使用一个标识符来确认单词添加结束。即`Trie`类应该包含一个标识符
> 4. 在确认是否是前缀时，和第`3`点流程一致，但是不需要确认标识符这一步

~~~python
class Trie:

    def __init__(self):
        self.tree = [None] * 26
        self.isEnd = False

    def insert(self, word: str) -> None:
        node = self
        for c in word:
            index = ord(c) - ord('a')
            if not node.tree[index]:
                node.tree[index] = Trie()
            node = node.tree[index]
        node.isEnd = True

    def search(self, word: str) -> bool:
        node = self
        for c in word:
            index = ord(c) - ord('a')
            if not node.tree[index]:
                return False
            node = node.tree[index]
        return True if node.isEnd else False

    def startsWith(self, prefix: str) -> bool:
        node = self
        for c in prefix:
            index = ord(c) - ord('a')
            if not node.tree[index]:
                return False
            node = node.tree[index]
        return True
~~~

## 221.最大正方形

题目链接：[力扣-221.最大正方形](https://leetcode.cn/problems/maximal-square)

> 思路：动态规划
>
> 1. 初始化状态：
>    + `dp[i][j]`表示以坐标`(i, j)`为右下角的矩阵的最大边长
>    + 由于`dp[i][j]`的左边，上边，即左上都可以作为矩阵的右下角。即`dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]`。
>      + 那么`dp[i][j]`往左最多能拓展到`min(dp[i][j - 1], dp[i - 1][j - 1])`处
>      + 同理`dp[i][j]`往上最多能拓展到`min(dp[i - 1][j], dp[i - 1][j - 1])`处
> 2. 状态转移方程：
>    + 根据`1`中的讨论，合并状态有：`dp[i][j] = min(dp[i][j - 1], dp[i - 1][j - 1], dp[i - 1][j])`
> 3. 初始化数组：
>    + 只要`i == 0` 或`j == 0`，那么`dp[i][j] = matrix[i][j]`
> 4. 运行顺序：先列后行

~~~python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        m, n = len(matrix), len(matrix[0])
        dp = [[0] * n for _ in range(m)]
        res = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    if j == 0 or i == 0:
                        dp[i][j] = 1
                    else:
                        w = min(dp[i][j - 1], dp[i - 1][j - 1])
                        h = min(dp[i - 1][j], dp[i - 1][j - 1])
                        edge = min(w, h) + 1
                        dp[i][j] = edge
                    res = max(dp[i][j] * dp[i][j], res)
        return res
~~~

## 226.翻转二叉树

> 思路1：递归
>
> 1. 进入递归时，交换左右子树
> 2. 离开递归时，返回根节点

~~~python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
~~~

> 思路2：非递归
>
> 1. 将非`None`节点入栈
> 2. 出栈并交换入栈节点的左右子树
> 3. 入栈非空的左右子节点
> 4. 重复`1,2,3`

~~~python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        que = [root]
        while que:
            pre = que.pop(0)
            pre.left, pre.right = pre.right, pre.left
            if pre.left:
                que.append(pre.left)
            if pre.right:
                que.append(pre.right)
        return root
~~~

## 234.回文链表

> 思路1：暴力法
>
> + 遍历到数组中，再确认是否是回文数组
>
> 思路2：递归
>
> 1. 使用一个全局变量`pre`，将`head`赋值给`pre`。
> 2. 递归三部曲：
>    + 终止条件：当`pre`为`None`时，终止递归
>    + 参数和返回值：
>      + 参数：前驱节点`pre`和节点`head`
>      + 返回值：返回`pre`和`head`的比较结果，类型为布尔型
>    + 单层递归逻辑：
>      + 在离开递归时比较`pre.val`和`head.val`的值，如果不相等返回`False`

~~~python
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        self.pre = head
        return self.tranvers(head)

    def tranvers(self, head):
        if not head:
            return True
        son = self.tranvers(head.next)
        if self.pre.val != head.val:
            return False
        self.pre = self.pre.next
        return son
~~~

## 236.二叉树的最近公共祖先

题目链接：[力扣-236.二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)

> 思路：递归
>
> 1. 递归三部曲：
>    + 终止条件：当`root`为空
>    + 参数和返回值：
>      + 参数：`p, q, root`节点
>      + 返回值：布尔类型的值，为`root`和`p, q`的比较结果
>    + 单层递归逻辑：
>      + 使用一个全局标量`self.res`来表示结果，并使用标识符`self.isTrue`来表示是否找到祖先节点，防止递归返回到父节点时，`self.res`的结果被修改。
>      + 当`root`为`None`时，和`p, q`肯定不相等。返回`False`
>      + 当，当前`root`等于`p, q`时
>        + 如果这时有`left`或者`right`为`True`，那么证明当前的`p | q`节点就是最近的祖先节点。更新`self.res`和标识符
>        + 如果`left`和`right`都为`False`，那么直接返回`True`，表示找到了一个前驱节点
>      + 当`left`和`right`都为`True`时，那么证明当前节点为最近的祖先节点，更新`self.res`和标识符
>      + 返回是否寻找到目标节点的布尔值，即`left or right`

~~~python 
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        self.ans = None
        self.isTrue = False
        self.tranverse(root, p, q)
        return self.ans

    def tranverse(self, root, p, q):
        if not root:
            return False
        left = self.tranverse(root.left, p, q)
        right = self.tranverse(root.right, p, q)
        if root == p or root == q:
            if left or right:
                self.ans = root
                self.isTrue = True
            return True
        if left and right and not self.isTrue:
            self.isTrue = True
            self.ans = root
        return left or right
~~~

> 优化：
>
> 1. 在寻找`p, q`节点时，在进入递归时就可以判断是否寻找到`p, q`，这样不用继续向下遍历。因为这时候假如只找到一个节点`p | q`就不继续向下递归的话，证明找到的这个节点就是最近的祖先节点。
> 2. 判断是否更新`self.ans`的标识符`self.isTrue`其实可以不需要，因为只有最近的公共祖先节点才会同时满足`left == right == True`

~~~python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        self.ans = None
        self.tranverse(root, p, q)
        return self.ans

    def tranverse(self, root, p, q):
        if not root:
            return False
        if root == p or root == q:
            self.ans = root
            return True
        left = self.tranverse(root.left, p, q)
        right = self.tranverse(root.right, p, q)
        if left and right:
            self.ans = root
        return left or right
~~~

## 238. 除自身以外数组的乘积

题目链接：[力扣-238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

> 思路1：左右收集乘积
>
> 1. 题目要求不能使用除法，那么使用双指针，分别求除自己意外，左边和右边的连乘
> 2. 最后将两个连乘数组对应位置上的数值乘起来，返回结果

~~~python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        size = len(nums)
        left = [0] * size
        right = [0] * size
        left[0] = 1
        right[size - 1] = 1
        for i in range(1, size):
            left[i] = left[i - 1] * nums[i - 1]
            right[size - i - 1] = right[size - i] * nums[size - i]
        for i in range(size):
            left[i] = left[i] * right[i]
        return left
~~~

> 优化：使用了额外空间`left`和`right`，可以考虑在空间上优化
>
> 1. 使用数组`ans`收集除`nums[i]`之外，左边的乘积。
> 2. 使用临时变量`temp`，重新遍历`nums[i]`，收集右边的乘积
>    + 不能按照`ans[i] = nums[i + 1] * ans[i + 1]`的方式更新`ans`。因为`ans[i]`表示除`nums[i]`之外，左边的乘积。如果这样更新`ans`会将乘过的数字重新再乘一次
> 3. 在遍历的同时，将`temp`与`nums[i]`相乘

~~~python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        size = len(nums)
        ans = [1] * size
        for i in range(1, size):
            ans[i] = ans[i - 1] * nums[i - 1]
        temp = 1
        for i in range(size - 2, -1, -1):
            temp = temp * nums[i + 1]
            ans[i] = ans[i] * temp
        return ans
~~~

## 239.滑动窗口最大值

题目链接：[力扣-239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

> 思路：单调递减栈
>
> 1. 题目所求的为滑动窗口中的最大值，那么我们只需要将窗口中小于当前值的所有值去掉就行，不影响结果
> 2. 因为是滑动窗口，因此左右边界是变化的。因此为了判断是否出栈左边界的元素，存入栈中为序号而非具体值
> 3. 使用一个变量`left`来表示窗口的左边界，当栈头元素等于`left`时，表示下一个窗口来到时，这个栈头需要出栈了。而且因为`left`的约束，可以确定栈中的元素一定是在窗口中的

~~~python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        size = len(nums)
        res = []
        que = collections.deque()
        k  = k - 1
        left = 0
        for i in range(size):
            while que and nums[que[-1]] <= nums[i]:
                que.pop()
            que.append(i)
            if i < k:
                continue
            res.append(nums[que[0]])
            if que[0] == left:
                que.popleft()
            left += 1
        return res
~~~

## 240.搜索二维矩阵 $\mathrm{II}$

题目链接：[力扣-240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

> 思路：二分
>
> 1. 纵向和横向都是递增序列，那么肯定考虑二分法。
> 2. 如果每行第一个元素都大于`target`，那么后序每个元素都大于`target`，返回`False`。如果每行最后一个元素小于`target`，那么一整行元素小于`target`，这行`continue`
> 3. 定义一个全局变量`right`，因为`matrix[i][right]`大于`target`的话，`matrix[i][right]`对应的列和行后面的元素肯定是大于`target`的，因此后序二分也可以直接收缩右边界`right`

~~~python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m, n = len(matrix), len(matrix[0])
        right = n
        for i in range(m):
            if matrix[i][-1] < target:
                continue
            if matrix[i][0] > target:
                return False
            left = 0
            while left <= right:
                mid = left + (right - left) // 2
                if matrix[i][mid] == target:
                    return True
                elif matrix[i][mid] > target:
                    right = mid - 1
                else:
                    left = mid + 1
        return False
~~~

## 279.完全平方数

题目链接：[力扣-279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

> 思路：动态规划
>
> 1. 初始化状态：
>    + `dp[i]`表示数字`i`由平方数组成的最小个数
>    + 那么问题转换成完全背包问题
> 2. 状态转移方程：
>    + `dp[i] = min{dp[i - 1][j], dp[i][j - val] + 1}`
> 3. 数组初始化：
>    + 当`i == 0`时，那么`0`可以由`0`个平方数组成。因此`dp[0] = 0`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [10001] * (n + 1)
        dp[0] = 0
        val = 1
        sqr = 1
        while val <= n:
            for i in range(1, n + 1):
                if i < val:
                    dp[i] = dp[i]
                else:
                    dp[i] = min(dp[i], dp[i - val] + 1)
            sqr += 1
            val = sqr * sqr
        return dp[-1]
~~~

> 优化：
>
> 1. 在完全背包问题中，要选取第`i`个物品的条件是$j >= w_i$。因此对这道题来讲，`i`小于`val`时，`dp[i]`的状态只能由`dp[i - 1]`决定
> 2. 由`1`可知，`i`的遍历范围为`val -> n + 1`，且判断`i`是否大于`val`的步骤也可以省去

~~~python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [10001] * (n + 1)
        dp[0] = 0
        val = 1
        sqr = 1
        while val <= n:
            for i in range(val, n + 1):
                dp[i] = min(dp[i], dp[i - val] + 1)
            sqr += 1
            val = sqr * sqr
        return dp[-1]
~~~

## 283.移动零

题目链接：[力扣-283. 移动零](https://leetcode.cn/problems/move-zeroes/)

> 思路：双指针
>
> 1. 使用`index`记录第一个`0`的位置，每遇到一个非`0`元素就交换，并将`index`的值加`1`

~~~python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        index1 = 0
        size = len(nums)
        for i in range(size):
            if nums[i] != 0:
                if nums[index1] == 0:
                    nums[i], nums[index1] = nums[index1], nums[i]
                    index1 += 1
            else:
                index1 = i if nums[index1] != 0 else index1
~~~

> 优化：可以去掉多余步骤
>
> 1. 在原本的思路是需要判断，当遇到`0`时，是否更新`index1`的值的。但其实这部分可以省略
> 2. 让`index1`随着非`0`元素一起自增，当遇到`0`元素时，`index1`自然会留在原地不更新。但是指针`i`是一直自增的

~~~python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        index1 = 0
        size = len(nums)
        for i in range(size):
            if nums[i] != 0:
                nums[i], nums[index1] = nums[index1], nums[i]
                index1 += 1
~~~

## 287.寻找重复数

题目链接：[力扣-287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

> 思路一：兑子游戏，多数棋子肯定留在最后
>
> + 错误点在于，如果棋子占比数小于一半，那么其实跟多数棋子不相等的棋子都是敌人。所以留下的不一定是多数棋子
>
> 思路2：环形链表
>
> 1. 数组是可以抽象成一个链表的，即以`i`为前节点`nums[i]`为后节点，同理可知`nums[nums[i]]`为`nums[i]`的后一个节点
>
> 2. 抽象成链表后，重复数相当于一个环，那么可以使用环形链表找入环节点的思想。
>
>    + 思考为什么存在环？
>
>      - `case1:`起点从 `nums[0]`开始，进入自环 `nums[i]=i `此时必定有某个下标 `j` 满足 `nums[j]=i` 重复数字 `nums[i]` ，因此进入自环，只能是重复数字的自环。
>
>      - `case2`: 看一下路线：`nums[0]-->nums[nums[0]]-->nums[nums[nums[0]]]-->.......`
>        - 以上路线可以一直进行下去，如果没有环，那么就意味着 `nums` 数组是无限长的，显然不可能
>        - 因为 `case1` ，所以也不可能进入自环，除非是重复数字的自环
>
>    + 为什么入环点就是重复数字？
>
>      + 因为只有入环点才会入度大于等于`2`，而只有重复数的入度才会大于等于`2`

~~~python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow = 0
        fast = nums[0]
        while slow != fast:
            slow = nums[slow]
            fast = nums[nums[fast]]
        fast = nums[fast]
        slow = 0
        while fast != slow:
            fast = nums[fast]
            slow = nums[slow]
        return slow
~~~

> 思路2：二分查找
>
> 1. 因为数组`nums`中的数都在区间`1 -> n`，因此比`nums[i]`小的数都是可知的。
> 2. 那么我们可以二分查找`1 -> n`，求出`mid`。然后计数小于等于`mid`的数，记为`count`
> 3. 如果`count`比`mid`大，那么表明重复数一定在`left -> mid`中间，因为整数小于等于`mid`的数字就只有`mid`个。那么更新`right = mid - 1`
> 4. 反之更新`left`，最后一定是逼近重复数的

~~~python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        size = len(nums)
        left = 0
        right = size - 1
        while left <= right:
            mid = left + (right - left) // 2
            count = 0
            for num in nums:
                if num <= mid:
                    count += 1
            if count > mid:
                right = mid - 1
            else:
                left = mid + 1
        return left
~~~

## 297.二叉树的序列化与反序列化

> 思路1：BFS
>
> 1. 序列化（`serialize`）
>    + 使用`BFS`的方式遍历树，但是需要注意的是，对于不为`None`的节点，在`temp`队列中需要加上两个`None`节点
>    + 按照题意，在`BFS`完成后，需要将`arr`收集的尾部无效空节点去除
> 2. 反序列化（`deserialize`）
>    + 将输入`data`分裂成数组`arr`
>    + 使用一个队列`que2`初始化父节点，`que1`记录`que2`中父节点的子节点，哪些节点加入`que1`中由`arr[start, end]`决定
>      + `start`：每次都更新为`end`
>      + `end`：因为按照题意，节点不为空的父节点，即使其子节点为`None`也必须要有两个子节点。因此`end = 2 * count`，其中`count`为不为空的父节点的个数
>      + 遍历`que2`，使用`index`记录`que1`中元素的位置，每给`que2`中的父节点确认一个子节点`index`就自加一，因为需要通过`index`定位子节点位置，所以不能直接加二。若父节点为空，则直接加二。
>      + 将子节点入列`temp`
>      + 更新`start, end`
>    + 将`que2`更新为`temp`，重复上述过程

~~~python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ''
        que = collections.deque()
        que.append(root)
        arr = []
        while que:
            temp = collections.deque()
            for node in que:
                if node:
                    arr.append(node.val)
                else:
                    arr.append('null')
                if node:
                    temp.append(node.left)
                    temp.append(node.right)
            que = temp
        size = len(arr)
        end = 0
        for i in range(size - 1, -1, -1):
            if arr[i] != 'null':
                end = i
                break
        arr = arr[:end + 1]
        res = ','.join([str(x) for x in arr])
        return res

    def deserialize(self, data):
        """Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """
        if not data:
            return []
        arr = data.split(sep=',')
        root = TreeNode(int(arr[0]))
        son = 2
        start = 1
        end = start + son
        que1 = collections.deque(arr[start:end])
        que2 = collections.deque()
        que2.append(root)
        ele = len(arr)
        while que2:
            temp = collections.deque()
            size = len(que2)
            size1 = len(que1)
            index = 0
            count = 0
            for i in range(size):
                if que2[i]:
                    if index < size1 and que1[index] != 'null':
                        que2[i].left = TreeNode(int(que1[index]))
                        temp.append(que2[i].left)
                        count += 2
                    index += 1
                    if index < size1 and que1[index] != 'null':
                        que2[i].right = TreeNode(int(que1[index]))
                        temp.append(que2[i].right)
                        count += 2
                    index += 1
                else:
                    index += 2
            que2 = temp
            a = end
            end = count + end if count + end <= ele else ele
            start = a
            que1 = collections.deque(arr[start:end])
        return root
~~~

> 优化：上面的代码过于复杂，很多冗余代码
>
> 1. 对于序列化（`serialize`）:
>    + `if node`判断了两次，代码可以合并
>    + 使用`start, end`截取太麻烦，直接`pop()`
> 2. 对于非序列化（`deserialize`）
>    + 因为只空节点只能是子节点，所以在构造时只需要将非空节点入列`que`
>    + 使用`index`记录`arr`数组的位置，若`arr[index] != null`，那么构造左右节点。每构造一个节点`index`都需要加一
>      + 值得注意的是，即使`arr[index] == null`不构造节点，`index`的值也要加一。因为代表当前正在构造子节点的节点，其有个子节点为空。
>      + 因为空节点只能是子节点，因此只要非空节点在`que`中遍历完毕，那么有空子节点的父节点也会使得`index`自加，所以`index`一定会自加到正确的位置

~~~python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ''
        que = collections.deque()
        que.append(root)
        arr = []
        while que:
            temp = collections.deque()
            for node in que:
                if node:
                    arr.append(node.val)
                    temp.append(node.left)
                    temp.append(node.right)
                else:
                    arr.append('null')
            que = temp
        while arr[-1] == 'null':
            arr.pop()
        res = ','.join([str(x) for x in arr])
        return res

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        :type data: str
        :rtype: TreeNode
        """
        if not data:
            return []
        arr = data.split(sep=',')
        root = TreeNode(int(arr[0]))
        que = collections.deque([root])
        size = len(arr)
        index = 1
        while que:
            temp = collections.deque()
            for node in que:
                if index < size and arr[index] != 'null':
                    node.left = TreeNode(int(arr[index]))
                    temp.append(node.left)
                index += 1
                if index < size and arr[index] != 'null':
                    node.right = TreeNode(int(arr[index]))
                    temp.append(node.right)
                index += 1
            que = temp
        return root
~~~

## 300.最长递增子序列

> 思路一：动态规划
>
> 1. 初始化动态：
>    + `dp[i]`表示包含数字`nums[i]`在内的最大连续子序列
>    + 那么遍历`0 -> i`位置的`dp`，找出`nums[i] > nums[j]`的所有子序列个数的最大值
> 2. 状态转移方程：
>    + `dp[i] = max(dp[0] -> dp[i - 1]) + 1`
> 3. 初始化状态：
>    + `dp[0] = 1`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        size = len(nums)
        dp = [0] * size
        dp[0] = 1
        for i in range(1, len(nums)):
            for j in range(i + 1):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j])
            dp[i] += 1
        return max(dp)
~~~

> 思路二：二分
>
> 1. 记录一个单调递增的数组`cap`，表示遍历到`i`处时，最长的子序列，`cap`中每一个数字都表示，长度为`k ( 1 =< k <= res)` 的子序列的最后一位数字的最小值。`res`记录最长子序列的长度
> 2. 因为`cap`有序，那么可以在`cap`中使用二分法找到第一个大于`nums[i]`的数字，使用`nums[i]`替换掉它
>    + 如果`nums[i] > cap[res - 1]`，那么直接令`cap[res] = nums[i]`，并将`res`自加一
>    + 之所以要替换第一个大于`nums[i]`的数原因有两点
>      + 一是替换后并不会影响最大子序列的长度
>      + 二是使得子序列的最后一位尽可能的小，因为最后一位越小，和后序到来的数字组成更长序列的概率就越大。
> 3. 因为是寻找第一个大于`nums[i]`的值，因此二分结束后，将`cap[left] = nums[i]`即可
>    + 二分法有一个特殊情况，即当有`nums[i] == cap[mid]`时，这时候表示`cap`中的序列最后一位最小值不需要更新，因此直接将`mid`赋值给`left`，直接`break`

~~~python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        size = len(nums)
        cap = [0] * size
        cap[0] = nums[0]
        res = 1
        for i in range(1, size):
            if nums[i] > cap[res - 1]:
                cap[res] = nums[i]
                res += 1
                continue
            left = 0
            right = res - 1
            while left <= right:
                mid = left + (right - left) // 2
                if nums[i] < cap[mid]:
                    right = mid - 1
                elif nums[i] > cap[mid]:
                    left = mid + 1
                else:
                    left = mid
                    break
            cap[left] = nums[i]
        return res
~~~

## 301.删除无效的括号

题目链接：[力扣-301. 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/)

> 思路一：`DFS`
>
> 1. 题目要求删除最小的括号数，那么我们需要统计删除左右括号的数目
>    + 使用`left`记录需要删除的左括号数字，使用`right`记录需要删除的右括号的数字
>    + 遍历字符串`s`，遇到左括号`left`加`1`，遇到右括号`left`减`1`。如果遇到右括号时候，如果`left`等于`0`，那么证明遇到了多余的右括号，`right`加一
>      + 特殊情况：字符串`s = )(`。这时`left = 0`，那么最终遍历结果为`left = 1`，`right = 1`。表示两个括号都需要删除，符合题意
> 2. 接着根据给定的字符串，逐个尝试删除每个括号字符，接着递归的处理剩余的字符。
>    + 怎么理解递归删除？
>      + 每层递归都尝试删除`start -> size`的字符`s[i]`，那么从树的层面上看，就是一个笛卡尔积。即尝试删除每种组合
> 3. 递归处理三部曲：
>    + 终止条件：
>      + 当`left`和`right`都为`0`时，证明需要删除的括号已经删除完了，那么停止迭代
>    + 参数和返回值：
>      + 参数：`DFS`需要什么加什么参数
>      + 返回值：因为使用`res`收集删除括号后，有效的字符串。因此不需要返回值
>    + 单层递归逻辑：
>      + 在终止递归时，判断此时剩余的字符串`s`是否满足有效括号的条件。如果满足，那么将`s`添加进`res`。并终止递归
>      + 遍历从`s[start]`开始的字符串`s[start:]`，判断`s[i]  start =< i < size` 为左括号还是右括号，将`s[i]`删除。然后进入下一层递归。（结合笛卡尔积理解）
>        + 所谓删除，直接是将传入下一层的`s = s[:i] + s[i + 1:]`，这样相当于删除`s[i]`
>        + `start`更新为`i`，这里用到了剪枝操作。因为`start`之前的括号，在当前轮次之前的轮次已经被删除掉了。比如从`i = 3`开始递归删除括号，在之后的轮次中删除`i = 0`的括号。但其实以`i = 0`开始递归删除括号的第三个轮次，也会删除`i = 3`的括号。因此为了防止重复递归，在下个轮次中进行剪枝
>        + 当字符串中出现连续相同的括号时，无论删除哪个括号都会得到相同的结果，因此可以继续剪枝。即在以`s[start]`做递归删除后，与`s[start]`紧挨相同的括号都可以直接跳过。注意这里的跳过是指的单层遍历的时候跳过，并不是指的下个轮次不能删除。
>        + 判断当前要被删除的括号为左还是为右，为左则将`left`减一，为右则将`right`减一。然后进入下一轮递归
>    + 判断是否为有效括号组成的字符串：
>      + 使用`count`计数左括号，并遍历删除无效括号后的`s`
>      + 如果遇到左括号，那么`count`加一。遇到右括号，`count`减一。
>      + 如果遇到右括号时，`count`等于`0`，那么证明遇到了多出来的右括号，直接返回`False`
>      + 删除无效括号后的`s`遍历完成后，`return True if count == 0 else False`

~~~python
class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        left = 0
        right = 0
        for c in s:
            if c == '(':
                left += 1
            else:
                if c == ')':
                    if left == 0:
                        right += 1
                    else:
                        left -= 1
        res = set()
        self.dfs(s, 0, res, left, right)
        return res

    def dfs(self,s, start, res, left, right):
        if right == 0 and left == 0:
            if self.is_invalid(s):
                res.add(s)
            return
        size = len(s)
        for i in range(start, size):
            if i > start and s[i] == s[i - 1]:
                continue
            if left > 0 and s[i] == '(':
                self.dfs(s[:i] + s[i + 1:], i, res, left - 1, right)
            if right > 0 and s[i] == ')':
                self.dfs(s[:i] + s[i + 1:], i, res, left, right - 1)

    def is_invalid(self, s):
        count = 0
        for c in s:
            if c =='(':
                count += 1
            if c == ')':
                if count == 0:
                    return False
                count -= 1
        return count == 0
~~~

> 优化思路：
>
> 1. 如果还需要删除的括号数大于剩余未被遍历过的字符子串，即`left + right > size - start + 1`，那么证明继续向下遍历也得不到结果，终止递归
> 2. ~~每当`left == 0 and right == 0`时，都要检查`s`的合法性，这样效率太低。~~
>    + ~~使用变量`count`计数左括号的个数，遇到左括号加一，遇到右括号减一。终止递归时，只需要判断`count`是否为`0`就可以判断是否加入`res`~~
>      + ~~因为单层遍历删除`s[i]`，所以想要统计删除后的`s`还剩下多少左右括号，在更新`count`时需要在循环体的末尾统计。因为相较于`i`，当从`i + 1`开始向下递归时，`s[i]`是保留在删除后的子串`s`中的~~
>      + ~~如果出现了`count == 0`且遇到了右括号的情况，那么证明右括号删除过多，直接终止递归~~
>    + 如果使用`count`计数，那么只能计算已经遍历过的字符串。那么假如遍历过的字符串为`()(`，最后一个字符为`)`，这时`count = 1`那么`res`不会添加`()()`。这样只要合法的`s`包含最后一个字符，那么都不会加入到`res`中。
>    + 所以说使用`count`并不能追踪`s`是合法字符串，但是能追踪字符串`s`的非法性。只要遍历过的字符串出现当`count == 0`时，碰到了右括号，那么提前终止递归（剪枝）

~~~python
class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        left = 0
        right = 0
        for c in s:
            if c == '(':
                left += 1
            else:
                if c == ')':
                    if left == 0:
                        right += 1
                    else:
                        left -= 1
        res = set()
        self.dfs(s, 0, res, left, right, 0, 0)
        return res

    def dfs(self,s, start, res, left, right, left_count, right_count):
        size = len(s)
        if right + left> size - start + 1:
            return
        if right == 0 and left == 0:
            if self.is_invalid(s):
                res.add(s)
            return
        for i in range(start, size):
            if i > start and s[i] == s[i - 1]:
                if s[i] == '(':
                    left_count += 1
                if s[i] == ')':
                    right_count += 1
                if right_count > left_count:
                    return
                continue
            if left > 0 and s[i] == '(':
                self.dfs(s[:i] + s[i + 1:], i, res, left - 1, right, left_count, right_count)
            if right > 0 and s[i] == ')':
                self.dfs(s[:i] + s[i + 1:], i, res, left, right - 1, left_count, right_count)
            if s[i] == '(':
                left_count += 1
            if s[i] == ')':
                right_count += 1
            if right_count > left_count:
                return

    def is_invalid(self, s):
        count = 0
        for c in s:
            if c == '(':
                count += 1
            else:
                if c == ')':
                    if count == 0:
                        return False
                    count -= 1
        return count == 0
~~~

> 思路二：`BFS`
>
> 1. 根据思路一，删除括号关键点在于删除每种可能的组合。
>    + 那么其实可以遍历字符串`s`，然后删除字符`s[i]`，再将每个删除后的新字符串收集起来
>    + 判断删除后的新字符串是否合法，合法则收集起来。不合法继续遍历新字符串，然后删除字符
> 2. 根据`1`中的分析，删除字符可能出现重复的字符串，因此需要使用`set()`记录遍历过的字符串，防止重复遍历
> 3. 因为题目要求删除最少的字符，使得字符串合法。而每次遍历，新字符串都只删除一个字符，因此只要找到合法的新字符串，那么就不需要继续删除了。那么设定一个状态`is_delete`，判断是否需要继续向下删除
> 4. 如果`s[i] == s[i - 1]`，那么重复，直接跳过

~~~python
from collections import deque

class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        que = collections.deque()
        res = []
        trace = set()
        que.append(s)
        trace.add(s)
        is_delete = True
        while que:
            s_new = que.popleft()
            if self.is_invalid(s_new):
                res.append(s_new)
                is_delete = False
            if is_delete:
                size = len(s_new)
                for i in range(size):
                    if i > 0 and s_new[i] == s_new[i - 1] or s_new[i] not in ('(', ')'):
                        continue
                    s_next = s_new[:i] + s_new[i + 1:]
                    if s_next not in trace:
                        trace.add(s_next)
                        que.append(s_next)
        return res

    def is_invalid(self, s):
        count = 0
        for c in s:
            if c =='(':
                count += 1
            else:
                if c == ')':
                    if count == 0:
                        return False
                    count -= 1
        return count == 0
~~~

## 312.戳气球

题目链接：[力扣-312. 戳气球](https://leetcode.cn/problems/burst-balloons/)

> 思路：动态规划
>
> 1. 初始化状态
>    + 将整个数组分解成多个小区间，求小区间能获得硬币的最大值。那么合并区间后的大区间就是最大值
>    + 假设有小区间`(m, n)`，那么令`k`将区间分成`(m, k)`和`(k, n)`两部分。`k`指的是区间中最后一个被戳爆的气球
>      + 因为两个区间都有`k`，这样会产生重复计算，因此定义所有区间都为开区间。
>      + 因为`k`是最后一个被戳爆的气球，因此根据题意，戳爆`k`时，区间`(m, n)`的最大值为`(m, k) + nums[m] * nums[k] * nums[n] + (k, n)`
>      + 因此，遍历`k, m + 1 -> n - 1`，就能找到最佳分割点，使得`(m, n)`区间能得到的硬币最大
>    + 因为区间是由小到大逐渐扩散的，因此大区间的状态肯定能由小区间转移过来
>    + 为了轻松处理边界条件，即在数组头和数组尾时，能表示出开区间。在数组头和数组尾分别添加数字`1`，这样在不影响结果的情况下，不用考虑复杂的边界条件
>    + 令`dp[i][j]`表示开区间`(i, j)`之间能获取硬币最大值
> 2. 状态转移方程
>    + `dp[i][j] = max(dp[i][j], dp[i][k] + nums[i] * nums[k] * nums[j] + dp[k][j])`
> 3. 初始化`dp`数组
>    + 区间`(i, j)`小于`3`的都为`0`，因为至少长度为`3`，**开区间**才能有气球被戳爆
> 4. 运行顺序
>    + 先确定区间长度
>    + 再确定开始位置和结束位置
>    + 遍历`k`

~~~python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1]
        size = len(nums)
        dp = [[0] * size for _ in range(size)]
        for length in range(2, size):
            for i in range(size - length):
                j = i + length
                a = 0
                for k in range(i + 1, j):
                    # dp[i][j] = max(dp[i][j], dp[i][k] + nums[i] * nums[k] * nums[j] + dp[k][j])
                    # 这里不使用max的原因是，在比较大小的情况下，max会多出函数调用的时间。
                    # 且这里对dp[i][j]进行了多次赋值操作，也是蛮大的时间开销。经过测试，这道题不使用max函数运行时间比使用max函数少了一半
                    m = dp[i][k] + nums[i] * nums[k] * nums[j] + dp[k][j]
                    if m > a:
                        a = m
                dp[i][j] = a
        return dp[0][-1]
~~~

## 322.零钱兑换

题目链接：[力扣-312. 戳气球](https://leetcode.cn/problems/burst-balloons/)

> 思路：典型的背包问题，动态规划
>
> 1. 初始化状态：
>    + `dp[i]`表示总额为`j`需要最少的硬币个数
> 2. 状态转移方程：
>    + `dp[i] = max(dp[i], dp[i - coin])`
> 3. 初始化数组：
>    + 因为是需要满背包状态，因此当背包容量`j = 0`时，只有硬币个数都取`0`才有合法值
>    + `dp[0] = 0`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [amount + 1] * (amount + 1)
        dp[0] = 0
        for coin in coins:
            for j in range(coin, amount + 1):
                # dp[j] = min(dp[j - coin] + 1, dp[j])
                if dp[j] > dp[j - coin] + 1:
                    dp[j] = dp[j - coin] + 1
        return dp[-1] if dp[-1] != amount + 1 else -1
~~~

## 338.比特位计数

题目链接：[力扣-338. 比特位计数](https://leetcode.cn/problems/counting-bits/)

> 思路：动态规划
>
> 1. 初始化状态：
>    + `dp[i]`表示数字`i`有多少个`1`比特位
>    + 比特位左移一位，数字增大两倍。因此`dp[i]`的状态可由`dp[i >> 1]`决定
> 2. 状态转移方程：
>    + `dp[i] = dp[i >> 1] if i & 1 == 0 else dp[i >> 1] + 1`
> 3. 状态数组初始化：
>    + dp[0] = 0
> 4. 运行顺序：
>    + 从左到右

~~~ python
class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            # div = i % 2
            # pre = i // 2
            # dp[i] = dp[pre] if div == 0 else dp[pre] + 1
            dp[i] = dp[i >> 1] if i & 1 == 0 else dp[i >> 1] + 1
        return dp
~~~

## 347.前K个高频元素

> 思路一：排序 + 字典
>
> 1. 使用字典统计数组中各元素的个数，然后根据个数倒序排列
> 2. 取`topK`
> 3. 优化：使用堆，只需要排序`k`个元素，减少排序时间

~~~python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        dic = collections.defaultdict(int)
        for num in nums:
            dic[num] += 1
        count = list(dic.items())
        count.sort(key=lambda x:x[1], reverse=True)
        res = []
        index = 0
        while index < k:
            res.append(count[index][0])
            index += 1
        return res
~~~

## 394.字符串解码

题目链接：[力扣-394. 字符串解码](https://leetcode.cn/problems/decode-string/)

> 思路：栈
>
> 1. 遍历字符串`s`，将字符入栈
> 2. 当遇到字符`]`时，证明一个完整的需要被扩大倍数的子字符串入栈完成。开始出栈
>    + 判断出栈字符是否为字母，将所有字母按顺序组合在一起
>    + 判断出栈字符是否为数字，将所有数字按顺序组合在一起
>      + 比较数字组成的字符串时，是按照字典序比较的，比如`'3' > '21'`
>    + 将字符串赋值`num`次，然后将复制好的新字符串入栈，等待下一次复制
>      + 不用担心直接入栈会影响字符串拼接的顺序
>      + 当入栈的字符串不需要复制时，证明栈中已经没有数字和括号，栈为空。那么直接入栈没问题
>      + 当入栈的字符需要复制时，证明栈中还有数字和左括号，直接入栈也没问题
> 3. 最后拼接栈中剩余的字符，返回结果

~~~python
class Solution:
    def decodeString(self, s: str) -> str:
        que = collections.deque()
        for c in s:
            if c == ']':
                temp = []
                while que:
                    val = que.pop()
                    if val >= '0' and val <= '9':
                        num = val
                        while que and que[-1] >= '0' and que[-1] < '9':
                            num = que.pop() + num
                        num = int(num)
                        temp_str = ''
                        for i in range(len(temp) - 1, -1, -1):
                            temp_str += temp[i]
                        temp_str = num * temp_str
                        que.append(temp_str)
                        break
                    else:
                        if val != '[':
                            temp.append(val)
            else:
                que.append(c)
        res = ''
        while que:
            res = res + que.popleft()
        return res
~~~

## 399.除法求值

题目链接：[力扣-399. 除法求值](https://leetcode.cn/problems/evaluate-division/)

> 思路：`DFS`
>
> 1. 使用字典模拟加权有向图`graph`，使用状态字典`status`记录状态
> 2. 遍历查询集`queries`，以分子为开头，分母为结尾进行`dfs`查询
> 3. 递归三部曲：
>    + 终止条件
>      + 分子等于分母，证明从开始查询的分子到分母有一条有效路径，终止递归，收集结果到`res`
>      + 如果发现当前节点出现在状态字典中，那么终止递归
>    + 参数和返回值
>      + 参数：需要什么参数就加什么参数
>      + 返回值：返回当前路径是否搜索到结果的布尔值
>    + 单层遍历逻辑
>      + 当搜索到结果或者当前节点出现在状态字典中时，返回布尔值
>      + 将当前节点添加进状态字典，表示已经搜索过
>      + 遍历当前节点的子节点，将当前节点与子节点之间的权值累乘起来，然后进入下一层递归
>      + 递归返回时，如果找到正确搜索结果，终止递归，返回`True`。若没找到，先将累乘结果除以当前边的权值（回溯），接着遍历剩余子节点
>      + 子节点遍历结束也没有搜索到正确结果，返回`False`
> 4. 根据`dfs`的返回结果，如果没有搜索到查询问题对应的等式成立，那么`res.append(-1.0)`

~~~python
class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        graph = collections.defaultdict(dict)
        index = 0
        for x, y in equations:
            graph[x][y] = values[index]
            graph[y][x] = 1 / values[index]
            index += 1
        res = []
        for x, y in queries:
            status = {}
            if x not in graph or y not in graph:
                res.append(-1.0)
            elif x == y:
                res.append(1.0)
            else:
                if not self.dfs(res, x, y, graph, 1, status):
                    res.append(-1)
        return res

    def dfs(self, res, x, y, graph, val, status):
        if x == y:
            res.append(val)
            return True
        if x in status:
            return False
        status[x] = 1
        node = graph[x]
        for next, weight in node.items():
            val = val * weight
            if self.dfs(res, next, y, graph, val, status):
                return True
            val = val / weight
        return False
~~~



---



[^1]: `pre`和`res`都是在`class`中定义，使用`self.pre`和`self.res`调用
[^2]: 这里值得注意的是，需要将`pre`的左子节点断开，再将`pre`指向右子节点。这里断开左子节点是上一层`root`的左子节点，因为`self.pre`保存的是上一层`root`的值。有两个意思：一是`pre`必须为单链表，不能有左子节点，二是如果`pre`继续存在左子节点，那么在递归返回遍历`right`时，会因为`root`存在错误的左子节点，造成重复遍历。
[^3]: 因为在下一轮递归的时候，`root`的右子树会被改变，相当于让`root`的右子树直接被自己的左子树覆盖，所以需要在这一层保存正确的地址，确认遍历的是正确的树结构。之所以能保证正确，是因为`root`左右子树是在下一层才会被修改，而当前层`root`的左右子树是正确的地址，所以`left`和`right`其实是在被修改前就拿到了正确的未被修改的地址的（领先`self.pre`修改`root`就拿到了正确地址）
[^4]: 前驱节点指的二叉树遍历（前序、中序、后序）中，挨着根节点的那个节点。
