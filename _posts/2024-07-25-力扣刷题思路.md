---
layout: post
title: "力扣刷题思路"
date: 2024-07-25 12:00
categories: leetcode
background_image: "/assets/images/background.jpg"
tags: [leetcode, 刷题思路]
toc: true
author: 麻辣烫
---

##  31.下一个排列

题目链接[**力扣-31.下一个排列**](https://leetcode.cn/problems/next-permutation/description/)

```python
# 整体思路：
# 1、倒序寻找第一个升序所在的位置 i
# 2、然后从倒序遍历过的数字中，找出刚好大于位置 i 的数字，位置记为 j
# 3、交换i, j位置上的数字，因为原数组nums[i] > nums[j + 1]，那么交换位置后，数组nums[i+1:size]，也为降序
# 4、因为交换位置后，数组组成的数字高位已经变大很多，为了寻找下一个排列，则需要将交换后，i 位置往后的数字降序排列
```

## 32.最长有效括号

题目链接[力扣-32.最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

思路: 值得注意的是，在子问题3中，已经讨论了`s[i]`连续为`n`个`)`的问题，当为连续`n`个`)`时，遍历过的`dp[i - 1]，dp[i - 2] ... dp[i - n`]都已经在遍历时讨论过了

```python
# 1 初始化状态：
#   dp[i]表示以 i 为结尾的有效括号个数
# 1.1 子问题1，当s[i]为 ( 时，dp[i] = 0
# 1.2 子问题2，当s[i]为 ) 时，s[i - 1]为 ( ，那么dp[i]状态与dp[i - 2]有关
# 1.3 子问题3，当s[i]为 ( 时，s[i - 1]为 ) ，那么dp[i]状态与dp[i - 1] 和 s[i - dp[i - 1] - 1] 及 dp[i - dp[i - 1] - 2]有关
# 2、状态转移方程：
#   dp[i] = dp[i - 2] + 2   当s[i]为 ) 时，s[i - 1]为 (
#   dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2   当s[i] = ) 且 s[i - 1] = ) 且 s[i - dp[i - 1] -1] = ( 时
# 3、初始化：
#   当s[i] 为 (，dp[i] = 0
#               dp[0] = 0
# 4、运行顺序：
#   从左到右
```

## 33.搜索螺旋排序数组

题目链接[力扣-33.搜索螺旋排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)

思路：

````python
# 1、使用二分查找
# 2、在二分查找时，无论mid落在哪个位置，mid一定是处于某个有序的序列中的
# 3、那么先确定left 到 mid是否是有序序列，如果是的话，再在这个序列中搜索target
# 4、如果left 到 mid不是有序序列，那么mid 到 right肯定是有序序列，在mid到right的区间去搜索target和更新left和mid
````

## 34.在排序数组中查找元素的第一个和最后一个位置

题目链接[力扣-34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

思路：因为更新`right`时，右边界`right`总是在减小，所以合并`nums[mid] == target`这个条件，会逐渐逼近左边界。同理`left`逼近右边界

```python
# 思路：直接二分
# 1、当nums[mid] == target时，与搜索条件nums[mid] < target合并。那么左边界left会不停的逼近nums中等于target值的右边界
# 2、当nums[mid] == target时，与搜索条件nums[mid] > target合并。那么右边界right会不停的逼近nums中等于target值的左边界
```

## 39.组合总和

题目链接[力扣-39.组合总和](https://leetcode.cn/problems/combination-sum/)

```python
# 回溯
# 1、返回值：因为时组合问题，不需要返回值。使用path收集遍历过的nums[i]，等满足终止条件时，将path加入res
# 2、终止条件：终止条件为target == 0。
# 3、单层递归逻辑：遍历数组nums，同时target -= nums[i]。如果小于0，直接continue到下一个nums[j]，大于0则进入下一层递归。为了避免重复值，下层的 #    startIndex需要从i开始。从零开始会造成重复答案
```

## 42.接雨水

题目链接[力扣-42.接雨水](https://leetcode.cn/problems/trapping-rain-water/)

思路：双指针法是纵向直接一步到位求出`index`对应的水位有多深。单调栈是横向求出一个池塘不同水位能装多少水，然后累加起来求总和

```python
# 思路1：双指针法。
# 1）记录index位置左右两边的最大值，那么与左右两边最大值中的较小值的差，为该index位置的水位。
# 2）将水位求和，那么就是蓄水大小
# 3）因为水池中，可能会有砖头，石块。意思就是相邻比index位置大的位置，可能就是水池的砖头和石块，并不是池子的边界。所以需要index左右两边的最大值
# 思路2：单调栈。
# 1、维护一个单调递减栈，这样能保证index左边水位比index水位高。
# 2、在右边遇到一个比栈顶大的值，那么可以求出这层水位的含水量，(min(height[left], [right]) - height[index]) * (right - left)
```

## 46.全排列

题目链接[力扣-46.全排列](https://leetcode.cn/problems/permutations/description/)

思路：回溯

```python
# 核心是res怎么去掉重复的数字
# 1、如果不考虑数组遍历范围，那么res里面相同的数字会出现多次
# 2、如果使用index自增，那么小于index的数组值无法被取到
# 3、综上，只能改变nums，在下一次迭代之前将已加入path的nums值直接剔除
```

## 48.旋转图像

### 1.旋转矩阵的基本方法

1. **90° 顺时针旋转**：
   - **步骤1**：将矩阵转置（行列互换）。
   - **步骤2**：反转每一行。
2. **90° 逆时针旋转**：
   - **步骤1**：将矩阵转置。
   - **步骤2**：反转每一列。
3. **180° 旋转**：
   - 直接将矩阵中的元素对称交换。
4. **270° 顺时针旋转**（即90° 逆时针旋转）：
   - 可以通过90°顺时针旋转三次实现，或者按逆时针旋转的步骤进行。

### 2.旋转算法实现

以下是Python代码实现不同角度的矩阵旋转。

#### 2.1 90° 顺时针旋转

```python
def rotate_90_clockwise(matrix):
    n = len(matrix)
    # 矩阵转置
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # 每行反转
    for i in range(n):
        matrix[i].reverse()
    return matrix
```

#### 2.2 90° 逆时针旋转

```python
def rotate_90_counterclockwise(matrix):
    n = len(matrix)
    # 矩阵转置
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # 每列反转
    for j in range(n):
        for i in range(n // 2):
            matrix[i][j], matrix[n - 1 - i][j] = matrix[n - 1 - i][j], matrix[i][j]
    return matrix
```

#### 2.3 180° 旋转

```python
def rotate_180(matrix):
    n = len(matrix)
    for i in range(n):
        for j in range(n):
            if i < n // 2 or (i == n // 2 and j < n // 2):
                matrix[i][j], matrix[n - 1 - i][n - 1 - j] = matrix[n - 1 - i][n - 1 - j], matrix[i][j]
    return matrix
```

### 3.示例

假设我们有一个3x3的矩阵：

```
python复制代码matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# 顺时针旋转90°
print(rotate_90_clockwise(matrix))

# 逆时针旋转90°
print(rotate_90_counterclockwise(matrix))

# 旋转180°
print(rotate_180(matrix))
```

### 4.旋转角度依据

- **90° 顺时针**：元素 `(i,j)` 移动到 `(j,n−1−i)`。

  ① 转置：`(i, j) → (j, i)`

  ② 反转：`(j, i) → (j, n - 1 - i)`

  综上，从`(i, j)`移动到`(j, n - 1 -i)`，只需转置和反转两步

- **90° 逆时针**：元素 `(i,j)` 移动到 `(n−1−j,i)`。

- **180°**：元素 `(i,j)`移动到`(n−1−i,n−1−j)`。

## 49.字母异位词分组

```python
# 思路1：将数组中的每个字符串排序，然后作为字典的key。value为一个接收相同key值的字符串数组，遇到相同key就append
# 思路2：计数字符串，然后将字符串中每个字符和其计数组合成新字符串，例如a1b2c3，作为key
```

## 53.最大子数组和

题目链接[力扣-53.最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

```python
# 1、初始化状态：
#   dp[i]表示以nums[i]结束的连续序列的最大值
# 1.1 子问题：那么题目要求连续，那么状态只有两种，一种是nums[i]和index小于i的序列组合成和更大的序列，另一种是不和之前的序列组合，nums[i]单独成一个序列
# 2、状态转移方程
#   dp[i] = max(dp[i - 1] + nums[i], nums[i])
# 3、初始化状态：
#   dp[0] = nums[0]
# 4、运行顺序：
#   从左到右
```

## 55.跳跃游戏

题目链接[力扣-55.跳跃游戏](https://leetcode.cn/problems/jump-game/description/)

~~~python
# 思路1：
# 1、初始化状态
#   dp[i]表示能否跳跃到当前位置
# 1.1 子问题1：dp[i]状态与dp[0:i-1]有关
# 2、状态转移方程：
#   dp[i] = dp[j] and nums[j] >= (i - j)  j=0,1,...,i-1
# 3、初始值：
#   dp[0] = True
# 4、运行顺序：
#   从左到右。补充：如果j遍历从左到右，那么会出现超时的情况。因此将j从右到左遍历，增大找到使dp[i] = true的j的概率，提交通过
# 思路2：使用贪心算法
#   1、设置一个变量，记录遍历过的位置所能达到的最远位置。
#   2、如果最远位置小于当前位置i，那么表示最远也不可能达到当前位置i，直接返回false
~~~

## 56.合并区间

题目链接[力扣-56.合并区间](https://leetcode.cn/problems/merge-intervals/description/)

~~~python
# 思路：
# 1、按照左边界进行排序。
# 2、设立两个变量left, right分别记录合并后的左右边界，遍历intervals，更新右边界
# 3、当intervals[i]的左边界大于right时，记录下left, right。并更新intervals[i]记录的值为left和right
~~~

## 62.不同路径

题目链接[力扣-62.不同路径](https://leetcode.cn/problems/unique-paths/description/)

~~~python
# 1、初始化状态：
#   dp[i][j] 表示从左上角到当前格子有多少条路径
# 1.1 子问题1：
#   dp[i][j]来源只能来自左边和上边，且 i == 0 时，只能来自左边
# 2、状态转移方程：
#   dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
# 3、状态初始化：
#   dp[0][j] = 1, dp[i][0] = 1
# 4、运行顺序：
#   先m，后n
~~~

## 75.颜色分类

题目链接[力扣-75.颜色分类](https://leetcode.cn/problems/sort-colors/description/)

~~~python
# 双指针，数字0的指针index0，指向1序列的第一个位置，
# 数字1的指针index1指向1序列结束的下一个位置（即遍历到的最新的nums[i])
# 值得注意的是，判断nums[i]为0、1、2时，要用if elif，单独用if时，会造成二次交换
~~~

## 76.最小覆盖子串

题目链接[力扣-76.最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/)

~~~python
# 思路：滑动窗口
# 1、两个字典，一个字典A记录目标字符串t的字符计数情况。另一个字典B记录遍历过的字符的计数情况
# 2、设置变量match,left，假如字典B中某个字符subs计数B[subs] == A[subs]，那么match加一。
# 3、如果match == len(A)，那么表示完全匹配，计算i - left + 1的值与已记录符合题意子串长度作比较，记录较小子串
# 4、更新left
# 值得注意的是，当match == len(A)，更新left时，要注意B[subs] > A[subs]的情况。所以更新结束条件为while match == len(A)
~~~

## 78.子集

题目链接[力扣-78.子集](https://leetcode.cn/problems/subsets/description/)

~~~python
# 思路：回溯
# 注意下一层回溯起始位置为当前层遍历的位置 i + 1
~~~

## 79.单词搜索

题目链接[力扣-79.单词搜索](https://leetcode.cn/problems/word-search/description/)

~~~python
# 这是一道典型的深度优先搜索题
# 1、定义四个方向，和一个记录搜索路径的状态数组record。注意record记录的是当前层某一个方向A向下dfs时被搜索过的记录，当这个方向A搜索完成时，需要恢复record的状态。因为在该层换方向B向下搜索时，该位置只要不是上一层被搜索过且设置为True，在方向B向下搜索时是可以被搜索的。
# 2、不能直接返回递归调用的状态，因为这项相当于直接中断每一层的遍历
# 3、带返回值的递归，可以在当前层遍历完成后，再决定返回什么样的状态
class Solution:
    def exist(self, board, word):
        m, n = len(board), len(board[0])
        to = [[-1, 0], [1, 0], [0, 1], [0, -1]]
        size = len(word)
        for i in range(m):
            for j in range(n):
                if board[i][j] == word[0]:
                    index = 1
                    record = [[False] * n for _ in range(m)]
                    record[i][j] = True
                    if self.dfs(record, to, size, index, board, word, m, n, i, j):
                        return True
        return False

    def dfs(self, record, to, size, index, board, word, m, n, i, j):
        if index == size:
            return True
        for direction in to:  # 每一层遍历的方向
            x = i + direction[0]
            y = j + direction[1]
            if x < m and x > -1 and y > -1 and y < n and not record[x][y] and board[x][y] == word[index]:
                record[x][y] = True  # 表示当前方向往下dfs时，这个位置不能被检索了
                if self.dfs(record, to, size, index + 1, board, word, m, n, x, y):  # 这里不能直接return，不然中断方向的遍历
                    return True
                record[x][y] = False  # 记得恢复状态，因为换个方向往下搜索是可以搜这个格子的
        return False  # 每一层方向遍历完成后，决定返回什么状态
~~~

## 84.柱状图中的最大矩形

题目链接[力扣-84.柱状图中的最大矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

~~~python
# 思路1：暴力搜索，将每一个nums[i]向两边遍历，直到遇到比自己小的nums[left]和nums[right]才停止。w = right - left + 1, h = nums[i]
# 思路2：单调栈，定义一个单调递增栈。思路和思路1差不多，只不过单调栈会把遍历过的数字存储起来，不需要遍历第二遍
# 	1、碰到比stack[-1]小的数字开始出栈，index = stack.pop()，h = height[index], w = i - stack[-1] - 1
#	2、值得注意的是，w = i - index是不正确的，因为假如index和stack[-1]不为相邻元素，那么w会被减小
#	3、单调递增栈的出栈条件是遇到比栈顶更小的元素，如果数组为单调递增数组，那么无法出栈，所以可以在原数组末端nums.append(0)，保证出栈。
#	4、当栈中只剩下一个元素时，stack.pop()后，w = i - stack[-1] - 1 无法执行，所以可以在头位置加一个元素0，或者做一个else判断，为空则 w = i。因为pop之前stack中是有值的，而且这个值一定是数组中目前遍历到i位置的最小值，所以其宽度能直接扩展到i。
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights.append(0)
        size = len(heights)
        stack = []
        res = 0
        for i in range(size):
            while stack and heights[stack[-1]] > heights[i]:
                index = stack.pop()
                h = heights[index]
                if stack:
                    # 这里不能写w = i - index，因为index和stack[-1]可能不是连在一起的
                    w = i - stack[-1] - 1
                else:
                    # stack为空，那么肯定栈中元素都是大于零的，因为最后一个元素为0，如果前面有0元素，那么不会出栈
                    w = i
                res = max(res, w * h)
            stack.append(i)
        return res
~~~

## 85.最大矩形

题目链接[力扣-85.最大矩形](https://leetcode.cn/problems/maximal-rectangle/description/)

~~~python
# 思路：将matrix前i行都看做一个柱状图，沿用84题的思路。遍历每一行，将前i行的每一列值累加起来，就是84题中的高度。
# 1、当某一个matrix[i][j] == 0时，这一行的高度重置为0
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        m, n = len(matrix), len(matrix[0])
        heights = [0] * n
        res = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    heights[j] += 1
                else:
                    heights[j] = 0
            res = max(res, self.max_rec(copy.deepcopy(heights)))
        return res

    def max_rec(self, heights):
        max_res = 0
        stack = []
        heights.append(0)
        size = len(heights)
        for i in range(size):
            while stack and heights[stack[-1]] > heights[i]:
                index = stack.pop()
                h = heights[index]
                if stack:
                    w = i - stack[-1] - 1
                else:
                    w = i
                max_res = max(max_res, w * h)
            stack.append(i)
        return max_res
~~~

## 94.二叉树的种类

### 1. 普通二叉树 (Binary Tree)

**图示**：

```markdown
     1
    / \
   2   3
  / \   \
 4   5   6
```

**注意事项**：

- 每个节点最多有两个子节点。
- 节点的子节点可以是空的。

------

### 2. 满二叉树 (Full Binary Tree)

**图示**：

```markdown
     1
    / \
   2   3
  / \ / \
 4  5 6  7
```

**注意事项**：

- 每个节点要么没有子节点，要么有两个子节点。
- 完全填满每一层。

------

### 3. 完全二叉树 (Complete Binary Tree)

**图示**：

```markdown
     1
    / \
   2   3
  / \ / 
 4  5 6  
```

**注意事项**：

- 除了最后一层外，所有层上的节点都达到最大数目。
- 最后一层的节点尽可能地靠左排列。

------

### 4. 平衡二叉树 (Balanced Binary Tree)

**图示**：

```markdown
     3
    / \
   2   4
  /     \
 1       5
```

**注意事项**：

- 任意节点的左右子树高度差不超过1。
- 需要平衡操作来保持树的平衡。

------

### 5. 二叉搜索树 (Binary Search Tree, BST)

**图示**：

```markdown
     4
    / \
   2   6
  / \ / \
 1  3 5  7
```

**注意事项**：

- 对于树中的任意节点，其左子树上所有节点的值都小于该节点的值，其右子树上所有节点的值都大于该节点的值。
- 插入和删除操作需要保持这个性质。

------

### 6. 平衡二叉搜索树 (Balanced Binary Search Tree)

**图示**：

```markdown
     4
    / \
   2   6
  / \ / \
 1  3 5  7
```

**注意事项**：

- 同时满足平衡二叉树和二叉搜索树的性质。
- 常见的平衡二叉搜索树有AVL树和红黑树。

------

### 7. AVL树 (AVL Tree)

**图示**：

```markdown
     3
    / \
   2   4
  /     \
 1       5
```

**注意事项**：

- 任意节点的左右子树高度差不超过1。
- 插入和删除操作后可能需要进行旋转操作来保持平衡。

------

### 8. 红黑树 (Red-Black Tree)

**图示**：

```markdown
     4(B)
    /   \
   2(R)  6(R)
  / \   / \
 1(B) 3(B) 5(B) 7(B)
```

**注意事项**：

- 每个节点要么是红色，要么是黑色。
- 根节点是黑色。
- 红色节点不能有红色子节点（即红色节点的两个子节点必须是黑色）。
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
- 插入和删除操作后可能需要进行旋转和重新着色操作来保持红黑树性质。

------

### 9. 伸展树 (Splay Tree)

**图示**：

```markdown
     4
    / \
   2   5
  / \
 1   3
```

**注意事项**：

- 最近访问的节点会被旋转到根部。
- 伸展操作通过旋转将节点移动到根部，以加速后续访问。

------

### 10. Treap

**图示**：

```markdown
     5
    / \
   2   6
  / \
 1   3
```

**注意事项**：

- 同时满足二叉搜索树和堆的性质。
- 每个节点有一个优先级，优先级满足堆的性质（即父节点的优先级大于子节点的优先级）。

------

### 11. 堆 (Heap)

**图示**：

```markdown
    1
   / \
  2   3
 / \ / \
4  5 6  7
```

**注意事项**：

- 堆分为最大堆和最小堆。
- 最大堆：每个节点的值都大于或等于其子节点的值。
- 最小堆：每个节点的值都小于或等于其子节点的值。

------

### 12. 二叉堆 (Binary Heap)

**图示**：

```markdown
    1
   / \
  3   2
 / \ / \
7  6 5  4
```

**注意事项**：

- 一种堆结构，常用于实现优先队列。
- 满足完全二叉树的性质，节点按堆的性质排列。

------

### 13. 霍夫曼树 (Huffman Tree)

**图示**：

```markdown
      *
     / \
    *   E
   / \
  A   *
     / \
    B   C
```

**注意事项**：

- 用于霍夫曼编码，生成最优二叉树以实现数据压缩。
- 权重较小的节点离根较远。

------

### 14. 线段树 (Segment Tree)

**图示**：

```markdown
      18
    /   \
   7    11
  / \   / \
 3   4 5   6
```

**注意事项**：

- 用于解决区间查询问题。
- 可以高效地进行区间更新和区间查询。

------

### 15. 范例树 (Fenwick Tree/Binary Indexed Tree)

**图示**：

```markdown
       15
      / \
     7   8
    / \
   3   4
```

**注意事项**：

- 用于快速更新和查询前缀和。
- 通过维护部分和来实现高效查询和更新。

这些图示和注意事项涵盖了各类二叉树的基本概念和用途。具体应用中，选择合适的二叉树结构对于实现高效算法和数据处理非常重要。

## 96.不同的二叉搜索树

题目链接[力扣-96.不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)

~~~python
class Solution:
    def numTrees(self, n: int) -> int:
        """
        :param n:
        :return:
        思路：动态规划
        1、初始化状态：dp[n]表示n个节点能组成多少个搜素二叉树
        1.1、子问题1：当有n个节点时，从1 -> n 的每个节点分别当做根节点，
             肯定是不同的二叉树（节点值为1 -> n，所以根节点值肯定不同）
        1.2、子问题2：令F(i)表示以数字 i 为根节点的不同二叉搜索树的个数，则有G(n) = F(1) + F(2) + ... + F(n)
        1.3、子问题3：令 i 表示根节点，则F(i) = G(i - 1) * G(n - i)。G(i - 1)表示根节点为i的
             左子树有i - 1个节点，右子树有n - i个节点，那么左子树的种类肯定有G(i - 1)个，而树的个数
             与节点值无关，只与节点个数有关，所以右子树种类有G(n - i)个。那么两边子树组合种类为G(n - i) * G(i - 1)
        1.4、子问题4：结合1.3,1.2有G(n) = G(0)*G(n - 1) + G(1)*G(n - 2) + ... + G(n - 1)*G(0)
        2、状态转移方程：dp[i] = dp[0]*dp[i - 1] + dp[1]*dp[i - 2] + ... + dp[i - 1]*dp[0]
        2.1、据上式可以看出:
            1、当i - 1为偶数
            dp[i] = 2(dp[0]*dp[i - 1] + dp[1]*dp[i - 2] + ... + dp[(i - 1) // 2][(i - 1) // 2])
            2、当i - 1为奇数
            dp[i] = 2(dp[0]*dp[i - 1] + dp[1]*dp[i - 2] + ... + dp[(i - 2) // 2][(i - 2) // 2]) + dp[(i - 2) // 2 + 1][(i - 2) // 2 + 1]
        3、边界条件：当i为0表示无节点，1表示只有一个节点，那么这两种情况自然只有一种组合
            dp[0] = 1, dp[1] = 1
        4、运行顺序：0 -> n
        """
        dp = [0] * (n + 1)  # 不能预设为1，如果为1，每个dp[i]自加的时候都会多加1
        dp[0] = dp[1] = 1
        for i in range(2, n + 1):
            k = i // 2
            for j in range(1, k + 1):
                dp[i] += 2 * dp[j - 1] * dp[i - j]
            if i % 2 == 1:
                dp[i] += dp[i - k - 1] * dp[i - k - 1]

        return dp[-1]
~~~

## 98.验证二叉搜索树

题目链接[力扣-96.验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/solutions/)

中序遍历

~~~python
# 思路1：设置变量val，记录上一个节点的值，比较当前节点root.val和val的值，如果出现root.val <= val 那么返回False
# 思路2：设置前驱节点pre，用pre记录前一个节点的地址，比较前一个节点pre.val和当前节点root.val的值，如果出现root.val <= pre.val，那么返回False
# 思路1
class Solution:
    val = float('-inf')

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        left = self.isValidBST(root.left)
        if root.val > self.val:
            self.val = root.val
        else:
            return False
        right = self.isValidBST(root.right)
        return left and right
# 思路2   
class Solution:
    pre = None

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        left = self.isValidBST(root.left)
        if self.pre:
            if self.pre.val >= root.val:
                return False
        self.pre = root
        right = self.isValidBST(root.right)
        return left and right
~~~

## 101.对称二叉树

题目链接[力扣-101.对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)

~~~python
# 思路1：递归
# 	1、两棵相同的树一起遍历，第一棵树向左第二棵树向右
#	2、在前序的位置比较树的节点值情况
#	3、当两棵树节点值相等时，不能直接返回True，应该继续向下递归，比较子节点的值情况
# 思路2：层序遍历，层序判断是否为对称数组
~~~

~~~python
# 思路1：
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        return self.traverse(root, root)

    def traverse(self, root1, root2):
        if not root1 and not root2:
            return True
        elif not root1 or not root2:
            return False
        else:
            if root1.val != root2.val:
                return False
            left = self.traverse(root1.left, root2.right)
            right = self.traverse(root1.right, root2.left)
            return True if left and right else False

# 思路2
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        stack = [root]
        while stack:
            level = []
            temp_stack = []
            size = len(stack)
            for i in range(size):
                if stack[i]:
                    level.append(stack[i].val)
                    if stack[i].left:
                        temp_stack.append(stack[i].left)
                    else:
                        temp_stack.append(None)
                    if stack[i].right:
                        temp_stack.append(stack[i].right)
                    else:
                        temp_stack.append(None)
                else:
                    level.append(None)
            left, right = 0, size - 1
            while left <= right:
                if level[left] != level[right]:
                    return False
                left += 1
                right -= 1
            stack = temp_stack
        return True
# 思路2的写法2：画个二叉树的图就好理解。
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

            # Initialize a deque with the left and right children of the root
        queue = deque([(root.left, root.right)])

        while queue:
            left, right = queue.popleft()

            # If both are None, continue to the next pair
            if not left and not right:
                continue

            # If one is None and the other is not, it's not symmetric
            if not left or not right:
                return False

            # If the values are different, it's not symmetric
            if left.val != right.val:
                return False

            # Enqueue the children in the order that they should be compared
            queue.append((left.left, right.right))
            queue.append((left.right, right.left))

        return True
~~~

## 102.二叉树的遍历

### 二叉树的层序遍历

题目链接[力扣-102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

~~~python
# 思路：借助栈
# 1、节点入栈stack
# 2、遍历栈stack，建立一个临时栈temp，判断栈中的左子节点和右子节点分别存不存在，存在则入栈temp。
# 3、收集节点值，将临时栈赋值给stack
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        res = []
        stack = [root]
        while stack:
            sub_res = []
            temp_stack = []
            size = len(stack)
            for i in range(size):
                node = stack[i]
                if node.left:
                    temp_stack.append(node.left)
                if node.right:
                    temp_stack.append(node.right)
                sub_res.append(node.val)
            res.append(sub_res)
            stack = temp_stack
        return res
~~~

### 前中后遍历，非递归写法

#### 借助栈

> 1. 使用辅助栈，模拟递归调用的过程。
> 2. 特别注意的是终止循环条件，栈和节点有一个不为空就可以。因为在遍历到前驱节点的后一个节点时，栈肯定为空，但是树还有一半是没有遍历完的

> **前序遍历**

~~~python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []
        while stack or root:
            if root:
                res.append(root.val)
                stack.append(root)
                root = root.left
            else:
                temp = stack.pop()
                root = temp.right
        return res
~~~

> **中序遍历**

~~~python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                temp = stack.pop()
                res.append(temp.val)
                root = temp.right
        return res
~~~

> **后续遍历**
>
> 1. 特殊之处在于需要确认右子节点被访问过后，再访问根节点。
> 2. 设定一个变量跟踪访问过的节点（从stack里pop出来的，表示已经访问过了）

~~~python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []
        last_visit = None
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                if stack[-1].right and stack[-1].right != last_visit:
                    root = stack[-1].right
                else:
                    last_visit = stack.pop()
                    res.append(last_visit.val)
        return res
~~~

#### morris算法

> 1. morris算法其实是将二叉树变为单链表的一个过程，按照前中后遍历的顺序，将左子树整体移动到父节点的左边或者右边。
> 2. 对每个节点重复这个过程。
> 3. 下图就是一个中序遍历时，右子树整体挪到前驱节点 `5` 的一个过程

<img src="/assets/images/Snipaste_2024-08-09_16-57-08.png" alt="morris中序" style="zoom:80%;" />

> **前序遍历**
>
> 1. 顺序 root -> left -> right
> 2. 那么先取根节点，然后将左子树移动到右子树，再将右子树赋值给前驱节点`5`

~~~python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        while root:
            res.append(root.val)
            pre = root
            if root.left:
                temp = root.right
                root.right = root.left
                while pre.right:
                    pre = pre.right
                pre.right = temp
            root.left = None
            root = root.right
        return res
~~~

> **中序遍历**
>
> 1. 顺序 root -> left -> right
> 2. 将包含根节点在内的右边节点移动到前驱节点 `5`
> 3. 接着节点持续左移，直到遇到无左子节点，然后开始收集结果，并开始遍历右节点。其实当无左子节点时，左子树已经形成单链表了。
> 4. 接着开始收集左子树的单链表
> 5. 直到遇到右子树中具有左孩子的节点，又开始1、2、3、4，最终完成遍历

~~~python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        while root:
            pre = root
            if pre.left:
                pre = pre.left
                temp = pre
                while pre.right:
                    pre = pre.right
                pre.right = root
                root.left = None
                root = temp
            else:
                res.append(root.val)
                root = root.right
        return res
~~~

> **后续遍历**：太复杂了，仅作参考。一般Morris算法只做前中序遍历
>
> [Morris后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/solutions/431066/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/)

## 105.从前序遍历和中序遍历构造二叉树

> 题目链接[力扣-105.从前序和中序序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

~~~python
# 思路1：递归 + 分治
# 	1、对于前序遍历而言，当前节点A后一个值一定是当前节点A的左子节点值或者右子节点值。因为前序遍历顺序为 root -> left -> right
#	2、对于中序遍历而言，以前序遍历中节点值A做切割点，那么切割点A左边的序列形成A节点的左子树，右边的序列形成右子树
#	3、通过以上两点，可以用中序遍历做辅助，判断节点A是否有左右节点即可。如果以节点A做切割的中序遍历左边序列为空，那么A.left = None，如果不为空则将前序遍历A节点值的后一个值赋值给A.left
class Solution:
    index = 0

    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not inorder:
            return None
        res = TreeNode(preorder[self.index])
        root_val = preorder[self.index]
        clip = inorder.index(root_val)
        self.index += 1
        res.left = self.buildTree(preorder, inorder[0:clip])
        res.right = self.buildTree(preorder, inorder[clip + 1:])
        return res
# 思路二：做辅助栈
# 1、遍历preorder序列，将prorder[0]入栈
# 2、栈中入栈未添加右子节点的父节点，设置变量index记录中序遍历序列里节点的位置
# 3、判断栈顶节点值是否和中序遍历序列inorder[index]相等
# 	3.1 如果不相等，证明该前序遍历的节点值preorder[stack[-1]]左子节点为inorder[index]
#	3.2 如果相等，那证明stack[-1]对应的节点已经无左子节点了，因为如果有左子节点，其子节点组成的序列一定在inorder[stack[-1]]节点的左边。
# 	3.3 当相等后，开始出栈stack.pop()，直到preorder[stack[-1]] != inorder[index]。那么表示找到了最后一个pop出的节点的右子节点node
#	3.4 对于3.3，因为如果遍历到的node为出栈的 preorder[stack[-1]] == inorder[index] 除最后一个出栈节点之外的其他节点的右子节点，那么表示最后一个出栈的右子节点还有左孙子节点（左子树）没有遍历构建完成。但是在中序遍历中，从preorder[stack[-1]] == inorder[index]开始pop，直到最后一个pop出的节点，都能看出来已经没有左子孙节点能够构建了。所以node一定是最后一个pop出节点的右子节点。
# 4、将node入栈，继续构建右边子树，从node开始重复1、2、3步骤
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        root = TreeNode(preorder[0])
        stack = [root]
        inorder_index = 0
        for i in range(1, len(preorder)):
            node = TreeNode(preorder[i])
            if stack[-1].val != inorder[inorder_index]:
                stack[-1].left = node
            else:
                temp = None
                while stack and stack[-1].val == inorder[inorder_index]:
                    temp = stack.pop()
                    inorder_index += 1
                temp.right = node
            stack.append(node)
        return root
~~~

## 106.从中序遍历和后续遍历构造二叉树

题目链接：[力扣-106.从中序遍历和后续遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

~~~python
# 思路1：递归
# 	1、跟105不同点在于，后续遍历根节点放在了序列末端，那么我们需要倒序遍历后序序列。
#	2、寻找倒序遍历节点在中序序列中的index，以此做切割中序序列。
#	3、因为是后续遍历，所以节点左边的序列值为先为右子节点，再为左子节点。那么先构造右子树，再构造左子树。
#	4、当2中切割的左右序列为空，则返回None
#	5、重复1、2、3、4
class Solution:
    index = 0
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not inorder:
            return None
        root = TreeNode(postorder[-1])
        clip = inorder.index(postorder[-1])
        postorder.pop()
        root.right = self.buildTree(inorder[clip + 1:], postorder)
        root.left = self.buildTree(inorder[0:clip], postorder)
        return root
# 思路2：迭代
#	1、沿用104的思路，中序遍历为 left -> root -> right，后序遍历为 left -> right -> root。
#	2、所以当后序的值从末端开始遍历入栈时，栈中顺序为root -> right，那么中序也倒着遍历就为right -> root，这跟stack出栈顺序一致。所以inorder_index的初始值为size - 1
#	3、根据1、2，当stack[-1].val != inorder[inorder_index]，那么证明栈顶元素还有右子节点，所以stack[-1].right = node
#	4、当stack[-1].val == inorder[inorder_index]，证明右子节点构建完毕，开始pop
#	5、入栈node，重复1、2、3、4、5
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        root = TreeNode(postorder[-1])
        stack = [root]
        size = len(postorder)
        inorder_index = size - 1
        for i in range(size - 2, -1, -1):
            node = TreeNode(postorder[i])
            if stack[-1].val != inorder[inorder_index]:
                stack[-1].right = node
            else:
                temp = None
                while stack and stack[-1].val == inorder[inorder_index]:
                    temp = stack.pop()
                    inorder_index -= 1
                temp.left = node
            stack.append(node)
        return root
~~~

## 114.二叉树展开为链表

题目链接：[力扣-114.二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/)

### 思路1：使用递归

> 1. 创建一个全局变量res，再创建一个前驱节点pre。然后将res赋值给pre。[^1]
> 2. 使用前序遍历，在前序遍历中，将root地址赋值给pre，并让pre指针指向自己的右子节点。[^2]
> 3. 定义两个变量left和right，分别保存root节点的左右子节点，防止被下一层递归篡改。[^3]

#### 错误示范

> 在每一次使用完root时，未断开pre和root的链接，在下一层迭代时，root左右子节点地址被修改，造成错误结果

~~~python
class Solution:
    res = TreeNode()
    pre = res

    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        self.tranverse(root)
        root = self.res.right

    def tranverse(self, root):
        if not root:
            return
        self.pre.right = root  # 这里在下一层，相当把上一层的root的左子节点或右子节点赋值给root.right，即root.right = root.left
        self.pre = self.pre.right  # 这里相当于让self.pre = root，而且没有断开self.pre的左子节点
        self.tranverse(root.left)  # 下面两步都是直接在root上遍历左右子节点，但是在下一层时，root的左右子节点已经被修改了
        self.tranverse(root.right)
~~~

#### 正确示范

> 1. 在使用完root后，断开root和下层递归的连接。保证树递归的正确性
> 2. 断开pre和left的链接，保证不修改root，也保证了pre的单链表特性

~~~python
class Solution:
    res = TreeNode()
    pre = res
    aa = None

    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        self.tranverse(root)
        root = self.res.right

    def tranverse(self, root):
        if not root:
            return
        self.pre.right = root
        self.pre.left = None
        # self.aa = root
        self.pre = self.pre.right
        left = root.left
        right = root.right
        self.tranverse(left)
        self.tranverse(right)
~~~

### 思路2：利用树的前序遍历，非递归(morris算法)

> 1. 前序遍历的本质是根左右，那么可以让每个节点只有右节点，无左子节点。
> 2. 使用临时变量temp存储右子节点，然后让遍历到的节点pre的左子节点覆盖右子节点。即pre.right = pre.left
> 3. 让前驱节点[^ 4]node.right = temp
> 4. 断开pre节点的左子树，并让pre指向自己的右子节点
> 5. 重复1、2、3、4直到遍历到最后一个节点pre == None

~~~python
class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        pre = root
        while pre:
            forward = pre
            if pre.left:
                temp = pre.right
                pre.right = pre.left
                while forward.right:
                    forward = forward.right
                forward.right = temp
            pre.left = None
            pre = pre.right
~~~

### 思路3：反向思考，递归

> 1. 前序遍历，使用一个临时节点记录遍历过的node，在递归返回上一层时，将root.right = node。但这样做，会使得root的右子根节点断开，这样右子树就没法递归遍历。
> 2. 逆向思维，前序遍历为根左右，那么可以交换顺序倒着遍历，右左根，这样先遍历右左节点，最后考虑根节点。这样在离开左右节点时，root左右节点已经不影响遍历了，而且倒着建立单链表，最后返回的root就是正确的链表头节点。
> 3. 离开左右节点时，断开左子节点，让离开的root变为单链表

~~~python
class Solution:
    pre = None

    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        self.flatten(root.right)
        self.flatten(root.left)
        root.right = self.pre
        root.left = None
        self.pre = root
~~~

## 买卖股票的最佳时机

**注意**：`dp[1][i]`表示不持股时的最大利润，不够买股票也是不持股的一种状态，因此对于`dp[1][0]`来讲，其初始化值一定是 `0`

### 121.买卖股票的最佳时机 $\mathrm{I}$

题目链接：[力扣-121。买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/) 

> 思路：维护一个price最小值和一个卖出的最大值profit

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price = prices[0]
        max_profit = 0
        for price in prices:
            min_price = min(min_price, price)
            max_profit = max(max_profit, price - min_price)
        return max_profit
~~~

### 122.买卖股票的最佳时机 $\mathrm{II}$

题目链接：[力扣-122.买卖股票的最佳时机 $\mathrm{II}$](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

####  错误思路

> 思路：动态规划
>
> 1. 初始化状态：dp[i]表示遍历到i时，最大收益
>
>    + 子问题1：每天其实就三个状态，买入、卖出、啥也不干
>
>    * 子问题2：用dp[0]、dp[1]、dp[2]分别表示三个状态
>
> 2. 状态转移方程：
>
>    * `dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])`
>    * `dp[1][i] = dp[0][i - 1] + prices[i]`
>    * `dp[2][i] = max(dp[0][i - 1], dp[1][i - 1], dp[2][i - 1])`
>
> 3. 值初始化：
>
>    * `dp[0][0] = -prices[0]`
>    * `dp[0][1] = 0`
>    * `dp[0][2] = 0`
>
> 4. 运行顺序：从左到右
>
> 总结：
>
> 1. 状态`dp[2][i]`定义太模糊，该状态无法确认是持有股票还是未持有股票，因此未无效状态
> 2. 在买入和卖出更新状态时，发现用不到状态`dp[2][i]`，但是什么动作都不做这个状态肯定是存在的
> 3. 因此思路是错误的

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(3)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        dp[2][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])
            dp[1][i] = dp[0][i - 1] + prices[i]
            dp[2][i] = max(dp[0][i - 1], dp[1][i - 1], dp[2][i - 1])
        return max(dp[0][-1], dp[1][-1], dp[2][-1])
~~~

#### 正确思路

> 1. 初始化状态：
>    - 修正`dp[0][i]`状态为持股时所持最大金额，`dp[1][i]`状态为不持股所持最大金额
> 2. 状态转移方程：
>    - `dp[0][i] = max(dp[0][i - 1], dp[1][i] - prices[i])`   注意`dp[0][i - 1]`表示今天啥也不干，就保持昨天状态。
>    - `dp[1][i] = max(dp[1][i - 1], dp[0][i] + prices[i])`   注意`dp[1][i - 1]`表示今天啥也不干，就保持昨天状态。
> 3. 状态初始化：
>    + `dp[0][0] = -prices[0]`
>    + `dp[1][0]` = 0
> 4. 运行顺序：
>    + 从左到右
> 5. 从`2`可以看出，正确思路定义的状态是包含了啥也不干的状态的

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])
            dp[1][i] = max(dp[0][i - 1] + prices[i], dp[1][i - 1])
        return dp[1][-1]
~~~

### 123.买卖股票的最佳时机 $\mathrm{III}$

题目链接：[力扣-123.买卖股票的最佳时机$\mathrm{III}$](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/)

> 1. 初始化状态：
>    + `dp[0][i]`表示第一次持有股票时，存款最大金额
>    + `dp[1][i]`表示第一次不持股票时，存款最大金额
>    + `dp[2][i]`表示第二次持有股票时，存款最大金额
>    + `dp[3][i]`表示第二次不持股票时，存款最大金额
> 2. 动态转移方程：
>    + `dp[0][i] = max(dp[0][i - 1], -prices[i])`
>    + `dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prcies[i])`
>    + `dp[2][i] = max(dp[2][i - 1], dp[1][i - 1] - prices[i])`
>    + `dp[3][i] = max(dp[3][i - 1], dp[2][i - 1] + prices[i])`
> 3. 状态初始化：**有个隐含条件，当天买入可以当天卖出。**
>    + `dp[0][0] = -prices[0]`
>    + `dp[1][0] = 0`
>    + `dp[2][0] = -prices[0]`
>    + `dp[3][0] = 0`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(4)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        dp[2][0] = -prices[0]
        dp[3][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], -prices[i])
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])
            dp[2][i] = max(dp[2][i - 1], dp[1][i - 1] - prices[i])
            dp[3][i] = max(dp[3][i - 1], dp[2][i - 1] + prices[i])
        return dp[3][-1]
~~~

### 188.买卖股票的最佳时机 $\mathrm{IV}$

题目链接：[力扣-188.买卖股票的最佳时机 $\mathrm{IV}$](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

> 1. 初始化状态：
>    + 题目中要求最多交易次数为k，其实状态分析和123题分析是一样的。
>    + 按照`123`题分析，那么总共有 $2*k$ 个状态，记为`n`个状态。
>    + 那么可以写个循环，直接给n个状态赋值
>    + 当`j为偶数 j -> 0:n`，则表示持有股票的最大利润
>    + 当`j为奇数 j -> 0:n`，则表示不持有股票的最大利润
> 2. 状态转移方程：
>    + 当 `j == 0`时，`dp[0][i] = max(dp[0][i - 1], -prices[i])`
>    + 当`j % 2 == 1`时，`dp[j][i] = max(dp[j][i - 1], dp[j - 1][i - 1] + prices[i])` 
>    + 当`j % 2 == 0`时，`dp[j][i] = max(dp[j][i - 1], dp[j - 1][i - 1] - prices[i])` 
> 3. 初始化数组：
>    + 当`j % 2 == 0`时，`dp[j][0] = -prices[i]`
>    + 当`j % 2 == 1`时,`dp[j][0] = 0`
> 4. 执行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        size = len(prices)
        status_size = 2 * k
        dp = [[0] * size for _ in range(status_size)]
        for i in range(status_size):
            if i % 2 == 0:
                dp[i][0] = -prices[0]
            else:
                dp[i][0] = 0
        for i in range(1, size):
            k = 0
            while k < status_size:
                if k == 0:
                    dp[k][i] = max(dp[k][i - 1], - prices[i])
                elif k % 2 == 0:
                    dp[k][i] = max(dp[k][i - 1], dp[k - 1][i - 1] - prices[i])
                else:
                    dp[k][i] = max(dp[k][i - 1], dp[k - 1][i - 1] + prices[i])
                k += 1
        return dp[status_size - 1][-1]
~~~

### 309.买卖股票的最佳时机含冷冻期

题目链接：[力扣-309.买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

> 1. 初始化状态：
>    + 跟`123`题状态一致，只是多了一个冷冻期
>    + 当考虑冷冻期时，持有股票的状态只能从前天的状态转移过来
> 2. 状态转移方程：
>    + `dp[0][i] = max(dp[0][i - 1], dp[1][i - 2])`
>    + `dp[1][i] = max(dp[1][i - 1], dp[0][i - 1])`
>    + 注意`dp[0][i]`的状态方程较`123`题有所变化 
> 3. 数组初始化：
>    + `dp[0][0] = -prices[0]`
>    + `dp[1][0] = 0`
>    + `dp[0][1] = max(dp[0][0], -prices[1])`
>    + `dp[1][1] = max(dp[1][0], dp[0][0] + prices[1])`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        if size == 1:
            return 0
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        dp[0][1] = max(dp[0][0], -prices[1])
        dp[1][1] = max(dp[1][0], dp[0][0] + prices[1])
        for i in range(2, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 2] - prices[i])
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])
        return dp[1][-1]
~~~

### 714. 买卖股票的最佳时机含手续费

题目链接：[力扣-714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)

> 1. 初始化状态：
>    + 跟`123`定义的状态一致，只需要在购买时多减去所交的税即可
>    + 注意数组初始化时，定义的是不持股时的**最大**利润
>    + 当最后输出结果小于`0`时，可以选择不买入也不卖出，那么利润为`0`
> 2. 状态转移方程：
>    + `dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i] - fee)`
>    + `dp[1][i] = max(dp[1][i - 1]`, $\textcolor{red}{dp[0][i - 1] + prices[i]}$`)`
> 3. 数组初始化：
>    + `dp[0][0] = -prices[0] - fee`
>    + ~~`dp[1][0] = -fee`~~这里的初始化是错误的，`dp[1][i]`表示不持股时的最大利润，不够买股票也是不持股的一种状态，因此对于`dp[1][0]`来讲，其初始化值一定是 `0`
>    + `dp[1][0] = 0`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0] - fee
        dp[1][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i] - fee)
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])
        return dp[1][-1] if dp[1][-1] > 0 else 0
~~~

> 1. 考虑另外一种交税方式，在卖出时交税。这样在初始化数组时，就不用考虑`dp[1][0]`的特殊情况了
>
> 2. 状态转移方程：注意$\textcolor{red}{**红色部分的变化**}$
>
>    + `dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])`
>    + `dp[1][i] = max(dp[1][i - 1]`, $\textcolor{red}{dp[0][i - 1] + prices[i] - fee}$`)`
>
> 3. 状态初始化：
>
>    + `dp[0][0] = -prices[0]`
>
>    + `dp[1][0] = 0`

~~~python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i] - fee)
        return dp[1][-1] if dp[1][-1] > 0 else 0
~~~

## 124. 二叉树中的最大路径和

题目链接：[力扣-124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum)

>1. 思路：递归
>   + 题目明确要求是二叉树的最大路径和，且不能重复遍历。那么可以考虑在离开左右子树，回到父节点时，收集路径最大和
>   + 对于当前节点来讲，包含当前节点的最大路径和，即为左子树最大路径和`leftMax`，加上右子树最大路径和`rightMax`，加上当前节点值`root.val`。即`rootMax = leftMax + root.val + rightMax`
>   + 当`rootMax`小于`0`时，则应该舍弃，因为对于其父节点来讲，是负增益。因此将其置`0`，再返回给父节点，这样相当于其父节点断开这一子树
>   + 因为返回给父节点的值都是包含了当前节点的，因此不存在不连续的问题。
>2. 递归三步：
>   + 确定递归终止条件：
>     + 当`root == None`时，终止递归
>   + 确定参数和返回值：
>     + 参数：① 需要一个全局变量`self.res`收集当前节点的最大路径和`rootMax`。 ② 需要传入`root`节点，以便于向下左递归
>     + 返回值：每次返回包含当前节点值`root.val`的左右子树中，较大的路径最大和`max(leftMax, rightMax) + root.val`，这样能保证传给父节点的路径和是连续的节点值的和。
>   + 单层递归逻辑：① 使用`self.res`与当前节点的最大路径和左比较，更新`self.res`为两者之间的最大值。② 比较`leftMax`和`rightMax`，取二者中较大值与当前`root.val`的和返回给父节点。
>   + 如果`max(leftMax, rightMax) + root.val`小于零，则向父节点返回`0`

~~~python
class Solution:
    res = -1001

    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        self.tranverse(root)
        return self.res

    def tranverse(self, root):
        if not root:
            return 0
        left = self.tranverse(root.left)
        right = self.tranverse(root.right)
        total = left + right + root.val
        self.res = max(total, self.res)
        bigger = max(right, left) + root.val
        return bigger if bigger > 0 else 0
~~~

## 128.最长连续序列

题目链接：[力扣-128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence)

### 思路1：使用并查集

> 1. 并查集知识点链接：[并查集](https://suwanzi.cn/categories/数据结构/#并查集)
>
> 2. 使用字典来记录遍历过的`num`，若再次遇到直接跳过
>
> 3. 有两种写法：
>
>    + 使用字典存储父节点信息，集合计数也是用字典存储。
>
>      ~~~python
>      import collections
>      class UF:
>          def __init__(self, nums):
>              self.dic = {num: num for num in nums}
>              self.count = {num: 1 for num in nums}
>      
>          def find(self, x):
>              if x != self.dic[x]:
>                  self.dic[x] = self.find(self.dic[x])
>              return self.dic[x]
>      
>          def merge(self, p, q):
>              if self.dic[p] == self.dic[q]:
>                  return
>              root_p = self.find(p)
>              root_q = self.find(q)
>              self.dic[root_p] = root_q
>              self.count[root_q] += self.count[root_p]
>              
>      class Solution:
>          def longestConsecutive(self, nums: List[int]) -> int:
>              if not nums:
>                  return 0
>              uf = UF(nums)
>              had = collections.defaultdict(int)
>              for num in nums:
>                  if num not in had:
>                      if num + 1 in uf.dic:
>                          uf.merge(num, num + 1)
>                  had[num] = 1
>              return max(uf.count.values())
>      ~~~
>
>    + 使用数组存储数字的索引，让索引代表具体数值。
>
>      ~~~python
>      import collections
>      class UF:
>          def __init__(self, size):
>              self.dic = [i for i in range(size)]
>              self.count = [1 for _ in range(size)]
>      
>          def find(self, x):
>              if x != self.dic[x]:
>                  self.dic[x] = self.find(self.dic[x])
>              return self.dic[x]
>      
>          def merge(self, p, q):
>              if self.dic[p] == self.dic[q]:
>                  return
>              root_p = self.find(p)
>              root_q = self.find(q)
>              self.dic[root_p] = root_q
>              self.count[root_q] += self.count[root_p]
>              
>      class Solution:
>          def longestConsecutive(self, nums):
>              if not nums:
>                  return 0
>              size = len(nums)
>              uf = UF(size)
>              had = collections.defaultdict(int)
>              for i in range(size):
>                  if nums[i] not in had:
>                      if nums[i] + 1 in had:
>                          uf.merge(i, had[nums[i] + 1])
>                      if nums[i] - 1 in had:
>                          uf.merge(i, had[nums[i] - 1])
>                      had[nums[i]] = i
>              return max(uf.count)
>      ~~~
>
>    + 注意两种写法判断是否`union`的条件是不一样的。
>
>      + 对第一种写法来讲，因为是用的字典来模拟的树结构。其实已经将所有的num值存在了`self.dic`中了，因此只需要
>
>        `if num + 1 in uf.dic`这一个判断语句，就可以判断`num`是否有相邻节点`num + 1`。在遍历完`nums`过后，就可以把所有相邻的节点都整合到一个集合里。
>
>      + 对于第二种写法，是用的`nums`的下标`i`来表示的具体数值，因此在遍历到`i`时，我们是不知道`nums[i]`是有小于他，或者大于他的邻接节点的。因此需要做两次判断，只做`nums[i] + 1`或者`nums[i] - 1`的判断，会造成节点错漏。假设有节点`1,2,3`，如果按照顺序加入上方的`had`字典，那么`1`先加入`had`，这时候`nums[i] + 1 = 2` 是没在`had`中的，同理`2,3`的`num[i] + 1 = 3, 4`也都没加入`had`。因此一次`merge`都不会发生。

### 思路2：使用字典

> 1. 使用字典`dic`记录包含`key`在内的序列长度，变量`res`记录最大序列长度
> 2. 以`key`为出发点，判断`key - 1`和`key + 1`是否在`dic`中。若在，则取其值`left = dic[key - 1]`及`right = dic[key + 1]`
> 3. 则包含`key`在内的最大序列长度`res = max(res, left + right + 1)`
> 4. 更新包含`key`在内序列的边界，即`dic[key - left] = left + right + 1`、`dic[key + right] = left + right + 1`

~~~python
class Solution:
    def longestConsecutive(self, nums):
        if not nums:
            return 0
        dic = {}
        res = 0
        for num in nums:
            if num not in dic:
                dic[num] = 1
                left = dic.get(num - 1, 0)
                right = dic.get(num + 1, 0)
                length = left + right + 1
                res = max(res, length)
                dic[num - left] = length
                dic[num + right] = length
        return res
~~~

## 139.单词拆分：

题目链接：[力扣-139.单词拆分](https://leetcode.cn/problems/word-break/description/)

### 思路1：dfs

> 1. 使用字典`dic`记录`wordDict`里面的所有单词，记录一个起始节点`index`
> 2. 确定终止条件
>    + 如果`index == size`，那么证明所有单词已经匹配完毕，直接`return True`
> 3. 参数和返回值：
>    + `dfs`的参数需要什么就加什么，不固定
>    + 返回值为`boolean`类型，即是否能完全匹配
> 4. 单层递归逻辑：
>    + 如果`s[index:i + 1]`在`dic`中，那么更新`index`，并进入下一层递归。

~~~python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dic = {word: len(word) for word in wordDict}
        size = len(s)
        return self.dfs(s, dic, 0, size)

    def dfs(self, s, dic, index, size):
        if index == size:
            return True
        for i in range(size):
            word = s[index:i + 1]
            if word in dic and self.dfs(s, dic, i + 1, size):
                return True
        return False
~~~

> 注意：上面的代码只能通过部分样例，如果字符串中重复的字母过多，且`wordDict`中包含这些重复的字符，那么会造成重复递归判断。造成超时
>
> 例如：`s = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`，`wordDict = [a, aa, aaa]`。可以预见的是，每个`a`、`aa`、`aaa`都会被重复判断好多次
>
> ![递归的树形图](/assets/images/Snipaste_2024-08-14_19-57-47.png)
>
> 优化：
>
> + 使用带记忆的递归，即使用一个状态字典，记录判断过的子字符串。
>
>   ![带记忆的递归](/assets/images/Snipaste_2024-08-14_19-58-49.png)
>
> + 记录`wordDict`中最长单词的长度`word_max`，一旦`s[index:i+1]`长度超过`word_max`，那么立即停止单层遍历

~~~python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dic = {word: len(word) for word in wordDict}
        word_max = max(dic.values())
        size = len(s)
        status = [None] * size
        return self.dfs(s, dic, 0, size, status, word_max)

    def dfs(self, s, dic, index, size, status, word_max):
        if index == size:
            return True
        if status[index] != None:  # 如果status[index]有值，证明已经验证过以s[index]开头的字符串组成的单词不符合题意
            return status[index]
        for i in range(index, size):
            word = s[index:i + 1]
            if i - index + 1 > word_max:
                break
            if word in dic and self.dfs(s, dic, i + 1, size, status, word_max):
                # status[index] = True 这一步是完全不需要的，因为只有递归到index == size才会执行到这里
                return True
        status[index] = False  # 记录从以s[index]开头的字符串组成的单词，在wordDict中不存在 
        return False
~~~

### 思路2：动态规划

> 1. 初始化状态：
>    + `dp[i]`表示前`i`个元素`s[0:i]`能否被`wordDict`表示，注意前`i`个元素下标是`0,1,2,...,i - 1`，不是到`i`
>    + 定义`dp`数组时，将其长度定为`size + 1`，不然初始化必须要找到`s[0:i] in wordDict`才能完成初始化
>    + 设有分割点`j`分割前`i`个元素，则若`dp[i]`能被表示，必有`dp[j] = True and s[j:i] in wordDict`。这里的`s[j:i]`从`j`开始，是因为把空字符串`""`也看成了前`j`个元素之一，即`s = '' + s`。因此前`j`个元素是不包含`s[j]`的
> 2. 状态转移方程：
>    + `dp[i] = dp[j] and s[j:i] in wordDict`
> 3. 初始化状态：
>    + `dp[0] = True`   当为空串时，空串肯定能被`wordDict`表示
> 4. 运行顺序：
>    + 先遍历`i`，再遍历`j`
> 5. 优化：
>    + 若有`s[j:i] in wordDict`，那么必有`i - j <= max(len(word))`，`word`为`wordDict`中的元素。因此`j`遍历起始点为`i - max(len(word)`不为`0`
>    + 当找到`dp[i] = True`时，立即`break`，后序没必要再遍历了

~~~python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        size = len(s)
        dp = [False] * (size + 1)
        dp[0] = True
        word_max = len(max(wordDict, key=len))
        for i in range(1, size + 1):
            start = 0 if i <= word_max else i - word_max
            for j in range(start, i):
                if dp[j] and s[j:i] in wordDict:
                    dp[i] = True
                    break
        return dp[-1]
~~~

## 141.环形链表

> 思路1：使用字典或者数组存下遍历过的`node`，若遍历过的`node`再次出现再字典或数组中，返回`True`
>
> 思路2：快慢指针，快指针追上慢指针，则返回`True`

~~~python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        pre = ListNode()
        pre.next = head
        slow, fast = pre, pre.next
        while slow != fast:
            if not fast or not fast.next:
                return False
            slow = slow.next
            fast = fast.next.next
        return True
~~~

> 思考：为什么快指针不每次按照`3`倍，`4`倍，甚至`n`倍的速度去跑？
>
> + 假设当`slow`入环时，和`fast`指针相距距离`k`。设环长度为`r`，`slow`走了`h`步后被追上，若要`fast`追上`slow`，则有
>   $$
>   k + h + nr = mh \\
>   h = \frac{\left(k + nr\right)}{m - 1}
>   $$
>
> + 可以看到上面的公式，如果`m = 2`，那么$h = k + nr$，当`fast`走的步数为$k,k + r, ... , k + nr$时，会被追到。最短走$k$步就被追到。
> + 如果$m > 2$，则要看 $k + nr$ 和 $m - 1$ 成整数倍关系才能追上。特别注意的是，如果 $m$ 为奇数，那么 $k = mv - v$ 肯定为偶数，$v$ 为慢指针走的距离，$m - 1$ 也为偶数，所以 $h$ 一定有整数值使得公式成立。
>   + 另一个角度去理解：如果 $m >= 3$，那么快指针很容易跨过慢指针，也就是追慢指针时，很容易从慢指针头上跳过去。

## 142.环形链表 $\mathrm{II}$

题目链接：[力扣-142.环形链表](https://leetcode.cn/problems/linked-list-cycle/description/)

> 假设相遇时圈外走的长度为`d1`，圈内走的长度为`d2`，圈的周长为`r`，那么有:
>
> 
> $$
> slow = d1 + d2 + c_1r \\
> fast = d1 + d2 + c_2r \\
> 又有 \\
> fast = 2 * slow \\
> 那么 \\
> d1 + d2 + c_2r = 2(d1 + d2 + c_1r) \\
> 化简\\ 
> d1 = (c_2 - c_1)r - d2 \quad \Rightarrow \quad d1 = (c_2 - c_1 - 1)r + (r - d2) \\
> 而\quad r - d2\quad是相遇点回到入口剩下的距离
> $$
>
> + 从上面公式可以看出，如果让节点重新从头节点`head`开始出发，同时让`fast`从相遇点以`slow`的速度继续开始往下遍历，那么当`head`走到环入口处时，`fast`正好也走到入口点

~~~python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = ListNode()
        pre.next = head
        slow, fast = pre, pre.next  # 这里是为了让 slow != fast，让while进入循环
        while slow != fast:
            slow = slow.next
            if not fast or not fast.next:
                return None
            fast = fast.next.next
        fast = fast.next  # 这里是因为上面为了让while进入循环，fast多走了一步
        while fast != pre:
            fast = fast.next
            pre = pre.next
        return pre
~~~

> 对于代码中找到相遇点后，`fast`多走一步的解释：
> $$
> d1 + d2 + c_2r - 1 = 2(d1 + d2 + c_1r) \\
> d1 = (c_2 - c_1 - 1)r + (r - (d2 + 1))
> $$
> 从上面公式可以看出，`d1`为`d2`再向前走一步后，圈内剩下的步数

## 146.LRU缓存

题目链接：[力扣-146.LRU缓存](https://leetcode.cn/problems/lru-cache/description/)

> 1. 题目要求`get`和`put`都只有`O(1)`，那么首先想到的`get`就是字典，`put`能`O(1)`操作的就是双链表
> 2. 那么用字典`dic`的`key`存放输入的`key`，字典的`value`存放代表`(key,value)`在双链表中的，节点的地址
> 3. 在初始化双链表时，直接加虚拟头尾节点，这样在增删移动节点时，不需要判断前后条件是否存在。
> 4. `get()`过的节点需要移到链表头部，表示最近使用过，那么需要定义一个方法`moveToFirst`
> 5. `put()`进的节点肯定在链表头部，那么需要定义一个方法`addFirst`
> 6. 在操作完一个节点，或者`lru`达到最大容量时，需要删除最久没被用过的那个节点。因此需要定义一个方法`deleteNode`
> 7. `node`一定包含`key`和`value`两个值，不然在超出`lru`容量，需要删除最久未使用的节点时，在`dic`中会不知道删除哪个对应的`key`
> 8. 在下面的代码中，被注释掉的代码是因为，按照逻辑需要将移动的节点`node`在原地址删除，然后再移动。如果先移动，就算移动到头节点，原地址的前后节点还保存着对`node`的引用，这不符合双链表的逻辑。

~~~python
class double_list:
    def __init__(self, key, val):
        self.pre = None
        self.next = None
        self.key = key
        self.val = val


class LRUCache:

    def __init__(self, capacity: int):
        self.head = double_list(key=0, val=0)
        self.last = double_list(key=0, val=0)
        self.head.next = self.last
        self.last.pre = self.head
        self.cap = capacity
        self.count = 0
        self.lru = {}

    def get(self, key: int) -> int:
        if key not in self.lru:
            return -1
        self.moveToFirst(self.lru[key])
        return self.lru[key].val

    def put(self, key: int, value: int) -> None:
        if key not in self.lru:
            node = double_list(key=key, val=value)
            self.addFirst(node)
            self.lru[key] = node
            if self.cap < self.count:
                self.lru.pop(self.last.pre.key)
                self.deleteNode(self.last.pre)
        else:
            self.lru[key].val = value
            self.moveToFirst(self.lru[key])

    def addFirst(self, node):
        after = self.head.next
        self.head.next = node
        node.pre = self.head
        node.next = after
        after.pre = node
        self.count += 1

    def moveToFirst(self, node):
        # pre = node.pre
        # next = node.next
        self.deleteNode(node)
        self.addFirst(node)
        # pre.next = next
        # next.pre = pre

    def deleteNode(self, node):
        pre = node.pre
        after = node.next
        pre.next = after
        after.pre = pre
        node.next = None
        node.pre = None
        self.count -= 1
~~~

## 148.排序链表

题目链接：[力扣-148.排序链表](https://leetcode.cn/problems/sort-list/description/)

---

> 1. 复杂度为$n\log_2n$，那么考虑归并排序
> 2. 设置快慢指针，当`fast`跑到链表末端时，`slow`正好在链表中间
> 3. 将链表截断，分治进行合并
> 4. 注意`fast`停止的条件
>    + 因为链表是单向的，`slow`没办法回退上一个节点，若想让链表正确二分，则`slow`要在二分节点的前一个节点停下来，不然链表没法在中间断开
>    + 因此为了让`slow`少跑一步，则要增加判断条件`head.next.next != None`

~~~python
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        slow, fast = head, head
        while fast and fast.next and fast.next.next:
            fast = fast.next.next
            slow = slow.next
        half = slow.next
        slow.next = None
        return self.merge(self.sortList(head), self.sortList(half))

    def merge(self, list1, list2):
        pre = ListNode()
        head = pre
        while list1 and list2:
            if list1.val < list2.val:
                head.next = ListNode(list1.val)
                list1 = list1.next
            else:
                head.next = ListNode(list2.val)
                list2 = list2.next
            head = head.next
        head.next = list1 if list1 else list2
        return pre.next
~~~

## 155.最小栈

题目链接：[力扣-155.最小栈](https://leetcode.cn/problems/min-stack/description/)

> 1. 要求常数时间返回最小值，那么在初始化时就定义一个变量`self.minValue`保存最小值
> 2. 在栈中存储入栈数值和`self.minValue`的差值`diff`，这样在`pop()`和`push()`时能够还原所有数值
>    + 为什么要存入差值，不存入入栈时的原数值。是因为在`self.minValue`被`pop()`操作后，无法判断哪个数值是最小值了
>    + 而若存入差值，只有当`diff < 0`出现时，才需要更新`self.minValue`，而且能通过`diff`还原出新的最小值

~~~python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_value = 0

    def push(self, val: int) -> None:
        if self.stack:
            diff = val - self.min_value
            self.stack.append(diff)
            self.min_value = self.min_value if diff >= 0 else val
        else:
            self.stack.append(0)
            self.min_value = val

    def pop(self) -> None:
        diff = self.stack.pop()
        self.min_value = self.min_value if diff >= 0 else self.min_value - diff

    def top(self) -> int:
        return self.min_value if self.stack[-1] <= 0 else self.min_value + self.stack[-1]

    def getMin(self) -> int:
        return self.min_value
~~~

## 160.相交链表

> + 思路1：字典
>
>   + 存入链表`A`中每个节点的地址，然后遍历另一条链表`B`，若发现`B`中的节点在字典中存在，则返回该节点
>
> + 思路2：遍历相同长度的链表
>
>   + 先求出两条链表的长度，找出两只链表之间的长度差`diff`
>   + 让长的那支链表先跑`diff`步，然后同时遍历两只链表。遇到相等的节点，就返回该节点
>
> + 思路3：数学问题
>
>   + 假设相交节点到节点末尾的长度为`c`，链表`A`到相交节点的距离为`a`，链表`B`到相交节点的距离为`b`。
>
>   + 那么想让两条链表跑相同的距离再相遇，就让两条链表都跑`a + b + c`步。即让`A`跑完接着跑`B`，`B`跑完接着跑`A`，这样两条链表会在`a + b + c`处相遇
>
>   + 特别注意的是，如果两条链表都跑了`a + b + c`后，还没有相交节点，那么就证明两条链表不相交。因此两条链表都需要一个`None`节点来停止循环。
>
>   + 下面这种写法是错误的，因为如果遇到不相交的链表，`preA`和`preB`一直会被`headA`和`headB`赋值进入死循环。所以需要`preA == preB == None`这个条件来停下来
>
>     ~~~python
>     preA = preA.next if preA.next else headB
>     preB = preB.next if preB.next else headA
>     ~~~
>
>     

~~~python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        preA, preB = headA, headB
        while preA != preB:
            preA = preA.next if preA else headB
            preB = preB.next if preB else headA
        return preA
~~~

## 169.多数元素

> 1. 思路1：字典
>    + 字典记录每个元素的`count`，超过一半直接返回该元素
> 2. 思路2：兑子游戏
>    + 即只要不相同的元素，就互相兑子，`count`减一
>    + 当`count`为`0`时，更新被兑子的元素，并将`count`置`1`

~~~python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 1
        more = nums[0]
        size = len(nums)
        for i in range(1, size):
            if nums[i] != more:
                if count > 0:
                    count -= 1
                if count == 0:
                    more = nums[i]
                    count = 1
            else:
                count += 1
        return more
~~~

## 打家劫舍

### 198.打家劫舍 $\mathrm{I}$

题目链接：[力扣-198.打家劫舍 $\mathrm{I}$](https://leetcode.cn/problems/house-robber/description/)

> 1. 初始化状态：
>    + `dp[i]`表示打劫到第 `i` 家能打劫到的最多的钱
>    + 若打劫第`i`家，则第`i - 1`家显然不能偷，那么只能由`dp[i - 2]`和`nums[i]`决定
>    + 若不打劫第`i`家，则状态由`dp[i - 1]`决定
> 2. 状态转移方程：
>    + `dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])`
> 3. 数组初始化：
>    + `dp[0] = nums[0]`
>    + `dp[1] = max(nums[0] ,nums[1])`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def rob(self, nums: List[int]) -> int:
        size = len(nums)
        if size == 1:
            return nums[0]
        dp = [0] * size
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, size):
            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])
        return dp[-1]
~~~

### 213.打家劫舍 $\mathrm{II}$

题目链接：[力扣-213.打家劫舍$\mathrm{II}$](https://leetcode.cn/problems/house-robber-ii/description/)

> 1. 和打家劫舍$\mathrm{I}$一样定义状态，只是用两个数组来分别考虑取`nums[0]`和`nums[-1]`的两种情况
> 2. 状态转移方程：
>    + `dp[0][i] = max(dp[0][i - 2] + nums[i], dp[0][i - 1])`
>    + `dp[1][i] = max(dp[1][i - 2] + nums[i], dp[1][i - 1])`
> 3. 初始化数组：
>    + `dp[0][0] = nums[0]`
>    + `dp[0][1] = max(nums[0], nums[1])`
>    + `dp[1][0] = 0`
>    + `dp[1][1] = nums[1]`
> 4. 运行顺序：
>    + 从左到右
> 5. 注意：
>    + 在返回最终结果比较最大值是，是比较的` max(dp[0][size - 2], dp[1][-1])`，而不是` max(dp[0][-1], dp[1][-1])`

~~~python
class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        size = len(nums)
        if size < 3:
            return max(nums)
        dp = [[0]*size for _ in range(2)]
        dp[0][0] = nums[0]
        dp[0][1] = max(nums[0], nums[1])
        dp[1][1] = nums[1]
        for i in range(2, size):
            dp[0][i] = max(dp[0][i - 2] + nums[i], dp[0][i - 1])
            dp[1][i] = max(dp[1][i - 2] + nums[i], dp[1][i - 1])
        return max(dp[0][size - 2], dp[1][-1])
~~~

### 337.打家劫舍 $\mathrm{III}$

#### 思路一：动态规划

>1. 初始化状态：
>
>   + 跟前两个打家劫舍类似，使用一个变量记录遍历到当前节点能打劫到的最多的钱。
>
>   + 那么遍历到当前节点就只有两种状态，一种是打劫当前节点，另一种是不打劫当前节点。那么自然可以想到使用一个长度为`2`的数组来记录两种状态。考虑到是二叉树，那么就使用数组`left`记录左子树返回的两种状态，同样用`right`记录右子树
>   + 如果打劫当前节点，那么就不能打劫两个子节点，即打劫当前节点的状态只能由孙子节点决定，也就是说是不打劫子节点的那个变量决定。`stolen = left[1] + right[1] + root.val`
>   + 如果不打劫当前节点，那么孙子节点打不打劫都是可以的，即`nostolen = max(left) + max(right)`
>
>2. 状态转移方程：
>
>   + `stolen = left[1] + right[1] + root.val`
>   + `nostolen = max(left) + max(right)`
>
>3. 初始化状态：
>
>   + 当`root == None`时，返回`[0, 0]`
>
>4. 运行顺序：
>
>   + 自底向上，离开双节点时更新状态，即后序遍历

~~~python
class Solution:
    def rob(self, root):
        return max(self.traverse(root))
    
    def traverse(self, root):
        if not root:
            return [0, 0]
        left = self.traverse(root.left)
        right = self.traverse(root.right)
        stolen = left[1] + right[1] + root.val
        nostolen = max(left) + max(right)
        return [stolen, nostolen]
~~~

#### 思路二：暴力递归遍历

> 1. 既然相邻层不能偷，那么当前节点能偷到的最多的钱有两种情况
>    + 偷当前节点，那么只能偷当前节点和孙子节点。
>    + 不偷当前节点，那么偷儿子节点
>    + 比较种情况中的最大值，则为当前节点能偷到的最大值
> 2. 在离开左右子节点时做最大值的判断，即后序遍历。
> 3. 递归三部曲：
>    + 终止条件：当`root == None`时，啥也偷不到，终止。
>    + 参数和返回值：
>      + 参数：传入根节点`root`
>      + 返回值：返回当前节点能到的最大的钱
>    + 单层递归逻辑：比较第`1`点中两种情况，获取最大值然后返回给上一层

~~~python
class Solution:
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        return self.traverse(root)

    def traverse(self, root):
        if not root:
            return 0
        grandSonLeft = 0
        grandSonRight = 0
        if root.left:
            grandSonLeft = self.traverse(root.left.left) + self.traverse(root.left.right)
        if root.right:
            grandSonRight = self.traverse(root.right.left) + self.traverse(root.right.right)
        grandFather = root.val
        son = self.traverse(root.left) + self.traverse(root.right)
        return max(son, grandFather + grandSonLeft + grandSonRight)
~~~

> 1. 上面的代码只通过了部分样例，在遇到树深的样例时运行超时
> 2. 优化：
>    + 可以看到在从上往下进行遍历时，每个节点有三种身份。即`grandFather`节点，`son`节点，`grandson`节点。因此在向上返回时，只要返回到该节点的祖先节点，该节点的这三个身份都会被重新计算一遍
>    + 因此可以定义一个带记忆的递归，记录遍历到当前节点时所能偷到的最大值，再次遍历到该节点时，直接返回。因为是树结构，因此直接考虑字典，`key`为节点地址，`value`为能偷到的最大值

~~~python
class Solution:
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.dic = {}
        return self.traverse(root)

    def traverse(self, root):
        if not root:
            return 0
        if root in self.dic:
            return self.dic[root]
        grandSonLeft = 0
        grandSonRight = 0
        if root.left:
            grandSonLeft = self.traverse(root.left.left) + self.traverse(root.left.right)
        if root.right:
            grandSonRight = self.traverse(root.right.left) + self.traverse(root.right.right)
        grandFather = root.val
        son = self.traverse(root.left) + self.traverse(root.right)
        max_stolen = max(son, grandFather + grandSonLeft + grandSonRight)
        self.dic[root] = max_stolen
        return max_stolen
~~~

### 2560.打家劫舍 $\mathrm{IV}$

题目链接：[力扣-2560.打家劫舍$\mathrm{IV}$](https://leetcode.cn/problems/house-robber-iv/description/)

>1. 要使得小偷某次偷窃行动结束后，能够偷窃的单个房间的最大值，在所有偷窃方案中的单个房间偷窃的最大值中最小
>   + 小偷有多种偷窃方案$p_1,p_2,p_3,...,p_n$，在每种偷窃方案中的单个房价能偷到的最大值为$v_1,v_2,v_3,...,v_n$
>   + 那么所求的就是在这些方案中，找出方案$p_i$使得$v_j$最小
>2. 题目加了一个约束条件，即能偷的最小房间个数不得小于`k`。而对于小偷来讲，$v_j$越小则能偷的房间数就越小，是正比关系
>3. 那么我们就可以通过能偷到的最大房间数来逼近`k`。自然，其能偷的房间会一起被约束。而能偷到的最大房间数我们是可以转化成`dp`问题的
>   + 初始化状态：
>     + `dp[i]`表示偷到第`i`个房间时，能偷的最大房间数。我们可以用`dp[i]`的值来逼近`k`，`dp[i]`值越接近`k`，证明能偷的最大值$v_j$越小
>   + 状态转移方程：
>     + `dp[i] = dp[i - 1]`	当`nums[i] > `$v_j$时，因为约束条件，房间`i`是不能偷的，因此`dp[i]`状态取决于`dp[i - 1]`
>     + `dp[i] = max(dp[i - 1], dp[i - 2] + 1)`         当`nums[i] <= `$v_j$时，房间`i`可偷，因此就是经典的打家劫舍问题了
>   + 初始化状态：
>     + `dp[0] = 1`	当`nums[0] <= `$v_j$时，房间`0`可偷
>     + ~~`dp[1] = 1`        当`nums[1] <= `$v_j$时，房间`1`可偷，为`1`。房间`0`可偷，也只能偷一个房间，为`1`。房间`0`不可偷，房间`1`可偷，为`1`~~
>     + `dp[1] = 1 if nums[1] <= `$v_j$`or dp[0] == 1`，上面删除线部分未考虑当`nums[1] >` $v_j$时，房间`i`可偷的情况
>   + 运行顺序：从左到右
>4. 对于`2`，既然要搜寻一个合适的$v_j$，来使得能偷的房间数逼近`k`，那么可考虑使用二分查找加速搜索过程。（经典的最大值最小化问题）
>5. 那么二分查找出来的数值，会不会不存在于数组`nums`中呢？
>   + 设答案为 `ans`，那么当最大金额为 `ans `时，可以偷至少 `k`间房子。如果 `ans `不在 `nums `中，那么当最大金额为 `ans−1` 时，也可以偷至少 `k`间房子，假如`ans - 1`也不在`nums`中，那么`ans - 2`也可以偷`k`间房子，一次类推到`nums[i]`在`nums`中。那么有`nums[i] =< res <= ans`这个区间的答案都符合题意，这与二分算法相矛盾：根据视频中讲的[红蓝染色法](https://www.bilibili.com/video/BV1AP41137w7/?vd_source=cb427266333ff90bbe3b3969c8065151)，循环结束时，`ans `和 `ans−1` 的颜色必然是不同的，即 `ans `可以满足题目要求，而 `ans − 1` 不满足题目要求（其实更新完`left`和`right`时，要么在`target`左边界，要么在右边界，终止的`left`和`right`是不可能处在边界中间的）。所以，二分出来的答案，一定在 `nums`中。

~~~python
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        return self.findMinMax(nums, k, 0, max(nums), self.dpFuc)

    def findMinMax(self, nums, target, left, right, func):
        while left <= right:
            mid = left + (right - left) // 2
            if func(maxVal=mid, nums=nums) >= target:
                right = mid - 1
            else:
                left = mid + 1
        return right + 1

    def dpFuc(self, maxVal, nums):
        size = len(nums)
        dp = [0] *  size
        if nums[0] <= maxVal:
            dp[0] = 1
        if nums[1] <= maxVal:
            dp[1] = 1

        for i in range(2, size):
            if nums[i] > maxVal:
                dp[i] = dp[i - 1]
            else:
                dp[i] = max(dp[i - 2] + 1, dp[i - 1])
        return dp[-1]
~~~



---



[^1]: pre和res都是在class中定义，使用self.pre和self.res调用
[^2]: 这里值得注意的是，需要将pre的左子节点断开，再将pre指向右子节点。这里断开左子节点是上一层root的左子节点，因为self.pre保存的是上一层root的值。有两个意思：一是pre必须为单链表，不能有左子节点，二是如果pre继续存在左子节点，那么在递归返回遍历right时，会因为root存在错误的左子节点，造成重复遍历。
[^3]: 因为在下一轮递归的时候，root的右子树会被改变，相当于让root的右子树直接被自己的左子树覆盖，所以需要在这一层保存正确的地址，确认遍历的是正确的树结构。之所以能保证正确，是因为root左右子树是在下一层才会被修改，而当前层root的左右子树是正确的地址，所以left和right其实是在被修改前就拿到了正确的未被修改的地址的（领先self.pre修改root就拿到了正确地址）

[^4]: 前驱节点指的二叉树遍历（前序、中序、后序）中，挨着根节点的那个节点。
