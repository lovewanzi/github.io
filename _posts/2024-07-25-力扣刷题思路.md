---
layout: post
title: "力扣刷题思路"
date: 2024-07-25 12:00
categories: leetcode
background_image: "/assets/images/background.jpg"
tags: [leetcode, 刷题思路]
toc: true
author: 麻辣烫
---

##  31.下一个排列

题目链接[**力扣-31.下一个排列**](https://leetcode.cn/problems/next-permutation/description/)

思路

```python
# 整体思路：
# 1、倒序寻找第一个升序所在的位置 i
# 2、然后从倒序遍历过的数字中，找出刚好大于位置 i 的数字，位置记为 j
# 3、交换i, j位置上的数字，因为原数组nums[i] > nums[j + 1]，那么交换位置后，数组nums[i+1:size]，也为降序
# 4、因为交换位置后，数组组成的数字高位已经变大很多，为了寻找下一个排列，则需要将交换后，i 位置往后的数字降序排列
```

## 32.最长有效括号

题目链接[力扣-32.最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

思路: 值得注意的是，在子问题3中，已经讨论了`s[i]`连续为`n`个`)`的问题，当为连续`n`个`)`时，遍历过的`dp[i - 1]，dp[i - 2] ... dp[i - n`]都已经在遍历时讨论过了

```python
# 1 初始化状态：
#   dp[i]表示以 i 为结尾的有效括号个数
# 1.1 子问题1，当s[i]为 ( 时，dp[i] = 0
# 1.2 子问题2，当s[i]为 ) 时，s[i - 1]为 ( ，那么dp[i]状态与dp[i - 2]有关
# 1.3 子问题3，当s[i]为 ( 时，s[i - 1]为 ) ，那么dp[i]状态与dp[i - 1] 和 s[i - dp[i - 1] - 1] 及 dp[i - dp[i - 1] - 2]有关
# 2、状态转移方程：
#   dp[i] = dp[i - 2] + 2   当s[i]为 ) 时，s[i - 1]为 (
#   dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2   当s[i] = ) 且 s[i - 1] = ) 且 s[i - dp[i - 1] -1] = ( 时
# 3、初始化：
#   当s[i] 为 (，dp[i] = 0
#               dp[0] = 0
# 4、运行顺序：
#   从左到右
```

