---
layout: post
title: "力扣刷题思路"
date: 2024-07-25 12:00
categories: leetcode
background_image: "/assets/images/background.jpg"
tags: [leetcode, 刷题思路]
toc: true
author: 麻辣烫
---

## 1.两数之和

题目链接：[力扣-1. 两数之和](https://leetcode.cn/problems/two-sum)

> 思路：字典
>
> 1. 将数值和对应的索引填入字典`dic`，`key`为数值`num`，`value`为`i`
> 2. 若`targe - num`在字典`dic`中，返回`[dic[target - num], i]`

~~~python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for i, num in enumerate(nums):
            diff = target - num
            if diff in dic:
                return [dic[diff], i]
            else:
                dic[num] = i
        return []
~~~

## 2.两数相加

题目链接：[力扣-2. 两数相加](https://leetcode.cn/problems/add-two-numbers)

> 思路：加法

~~~python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        head = ListNode()
        pre = head
        add = 0
        while l1 and l2:
            val_sum = l1.val + l2.val + add
            add = 1 if val_sum > 9 else 0
            val = val_sum % 10
            pre.next = ListNode(val)
            pre = pre.next
            l1 = l1.next
            l2 = l2.next
        l3 = l1 if l1 else l2
        if add == 1:
            while l3 and add == 1:
                val_sum = add + l3.val
                val = val_sum % 10
                add = 1 if val_sum > 9 else 0
                pre.next = ListNode(val)
                pre = pre.next
                l3 = l3.next
        if add == 1:
            pre.next = ListNode(1)
        else:
            pre.next = l3
        return head.next
~~~

> 思路二：简便写法，不考虑效率

~~~python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        head = ListNode()
        pre = head
        add = 0
        while l1 or l2:
            val_l1 = l1.val if l1 else 0
            val_l2 = l2.val if l2 else 0
            val_sum = val_l1 + val_l2 + add
            add = 1 if val_sum > 9 else 0
            val = val_sum % 10
            pre.next = ListNode(val)
            pre = pre.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        if add == 1:
            pre.next = ListNode(1)
        return head.next
~~~

## 3.无重复字符的最长字串

题目链接：[力扣-3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters)

> 思路：字典 + 滑动窗口
>
> 1. 使用字典`dic_s`记录遍历过的子串，如果遍历到字典中出现过的字符`s[i]`，则开始计算不重复子串的长度
> 2. 使用变量`left`记录字符串左边边界，当做完`res`与`i - left`的比较后，在字典`dic_s`中除去`left`到`key`为`s[i]`的字母，并更新`left`的位置
> 3. 返回结果时需要判断`res`与`size - left`的大小，因为按照`1,2`思路，当遇到重复字符串时才会更新`res`，如果直到遍历不结束都不出现重复字符，`res`不会被更新

~~~python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        size = len(s)
        left = 0
        dic_s = collections.defaultdict(int)
        res = 0
        for i in range(size):
            ele = s[i]
            if dic_s[ele] != 1:
                dic_s[ele] = 1
            else:
                count = i - left
                if count > res:
                    res = count
                while s[left] != ele:
                    dic_s[s[left]] -= 1
                    left += 1
                left += 1
        return res if res > size - left else size - left
~~~

## 4.寻找两个正序数组的中位数

题目链接：[力扣-4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays)

> 思路：二分查找
>
> 1. 中位数意味着必须找到位次排在中间的数字，而两个数组都是有序的，那么拿一条线来切割两个数组。只需要保证线左边的个数和右边的个数一样，并且第一个数组线左边的数字小于第二个数组线右边的数字，且第二个数组线左边的数字小于第一个数组线右边的数字。
> 2. 统计两个数组的个数为`total`，则记`half = total // 2`，假设`nums1`提供了`mid`个数字，那么`nums2`则应该提供`b = half - mid`个数字。
>    + `mid`就是我们二分查找的数字的个数，表示`nums1`应该取`mid`个数
>      + 讨论`nums1[mid - 1] > nums2[b]`时，需要确认`mid > 0`也就是`nums1`必须取至少一个。而`size_a <= size_b`，就算`nums1`一个都不取，`b`也绝不可能越界。
>        + 当出现`nums1[mid - 1] > nums2[b]`时，证明`nums1`中划线的位置太靠右了，需要将数`nums1[mid - 1]`减小，因此划线需要左移，即`right = mid - 1`
>      + 讨论`nums1[mid] < nums2[b - 1]`时，需要确认`mid < size_a`即可，因为在`size_a <= size_b`的情况下，`b`至少会取一个
>        + 当出现`nums1[mid] < nums2[b - 1]`时，证明`nums1`中划线的位置太靠左了，需要将数`nums1[mid]`增大，因此划线需要右移，即`left = mid + 1`
>    + 当`mid`满足`nums1[mid - 1] < nums2[b]`并且`nums1[mid] > nums2[b - 1]`时，证明已经将`nums1`和`nums2`正确划分，接下来就是找到正确的中位数
>      + 如果`total`为奇数，那么中位数只有一个。而`half = total // 2`，因此中位数必定在划线的右半边。因此分情况讨论
>        + 当`nums1`一个都不取，即`mid == 0`时，`nums2`一定有`total - half`个数字被划分到右边，因此中位数为：
>          + `res = min(nums1[mid], nums2[b])`    `size_a < size_b`
>          + ~~~`res = nums2[b]`    `size_a == size_b`~~  错误点在于，`total`为奇数时，不可能出现相等的情况
>        + 当`nums1`取`size_a`个，即`mid == size_a`，因为`nums1`个数小于`nums2`的关系，因此`nums2`也至少会被取一个，因此中位数为：
>          + `res = nums2[b]`
>        + 剩下`nums1`必须至少取一个的情况
>          + `res = min(nums1[mid], nums2[b])`
>      + 如果`total`为偶数，那么中位数有两个，分别在划线的两边。
>        + 当`mid == 0`时
>          + `res = (nums2[b - 1] + min(nums1[mid], nums2[b])) / 2`     `size_a < size_b`
>          + `res = (nums1[mid] + nums2[b - 1]) / 2`    `size_a == size_b`
>        + 当`mid == size_a`时
>          + `res = (max(nums1[mid - 1], nums2[b - 1]) + nums2[b]) / 2`    `size_a < size_b`
>          + `res = (nums1[mid - 1] + nums2[b]) / 2`    `size_a == size_b`
>        + 其他情况时
>          + `res = (max(nums1[mid - 1], nums2[b - 1]) + min(nums1[mid], nums2[b])) / 2` 

~~~python
from typing import List
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        size_a = len(nums1)
        size_b = len(nums2)
        if size_a > size_b:
            return self.findMedianSortedArrays(nums2, nums1)
        total = size_a + size_b
        half = total // 2
        is_odd = total % 2
        if not size_a or not size_b:
            return nums2[half] if is_odd else (nums2[half] + nums2[half - 1]) / 2
        left = 0
        right = size_a
        while left <= right:
            mid = left + (right - left) // 2
            b = half - mid
            if mid > 0 and nums1[mid - 1] > nums2[b]:
                right = mid - 1
            elif mid < size_a and nums1[mid] < nums2[b - 1]:
                left = mid + 1
            else:
                res = 0
                if is_odd:
                    res = nums2[b] if mid == size_a else min(nums2[b], nums1[mid])
                else:
                    if mid == 0:
                        res = (min(nums1[mid], nums2[b]) + nums2[b - 1]) / 2 if size_a != size_b else (nums1[mid] + nums2[b - 1]) / 2
                    elif mid == size_a:
                        res = (max(nums2[b - 1], nums1[-1]) + nums2[b]) / 2 if size_a != size_b else (nums1[-1] + nums2[0]) / 2
                    else:
                        res = (max(nums1[mid - 1] , nums2[b - 1]) + min(nums1[mid], nums2[b])) / 2
                return res
~~~

## 5.最长回文字符串

题目链接：[力扣-5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring)

> 思路一：分别讨论单双中心点，然后往两边扩散

~~~python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res = ''
        size = len(s)
        for i in range(size):
            left = i - 1
            right = i + 1
            while left >=0 and right < size and s[left] == s[right]:
                left -= 1
                right += 1
            res = res if len(res) >= right - left - 1 else s[left + 1:right]
            if i < size - 1 and s[i] == s[i + 1]:
                left  =  i - 1
                right = i + 2
                while left >= 0 and right < size and s[left] == s[right]:
                    left -= 1
                    right += 1
                res = res if len(res) >= right - left - 1 else s[left + 1:right]
        return res
~~~

> 思路一优化：其实不需要使用`if`判断`s[i] == s[i + 1]`，因为对于判断回文字符串长度来讲，中心字符不一定非得是一个或者两个。而中心字符个数越多，那么回文字符串肯定是越长的。
>
> 改进：
>
> 1. 先找到字符相等的左右边界，然后再开始比较中心字符左右两边是否相等
> 2. 找到相等字符的左右边界后，可以直接将下个回文字符串的中心字符直接定位在目前相等字符的右边界的下一个字符。因为目前相等字符的任意一个子字符作为中心点的回文字符串长度，不可能超过以当前相等字符作为中心点的回文字符串的长度

~~~python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res = ''
        size = len(s)
        i = 0
        while i < size:
            left = i - 1
            right = i + 1
            is_equal = True if i < size - 1 and s[i] == s[right] else False
            while right < size and s[i] == s[right]:
                right += 1
            i = right if is_equal else i + 1
            while left >= 0 and right < size and s[left] == s[right]:
                left -= 1
                right += 1
            res = res if len(res) >= right - left - 1 else s[left + 1:right]
        return res
~~~

## 10.正则表达式匹配

题目链接：[力扣-10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching)

> 思路：动态规划
>
> 1. 定义状态：
>    + `dp[i][j]`表示`s[0:i]`与`p[0:j]`是否匹配
>    + 当`a <= p[j] <= z`，那么`dp[i][j]`状态只与`dp[i - 1][j - 1] and s[i] == p[j]`有关
>    + 当`p[j] == .`，那么`dp[i][j]`状态只与`dp[i - 1][j - 1]`有关
>    + 当`p[j] == *`，需要进行分情况讨论，假设`p[j - 1]`为`a`
>      + 当`*`与`p[j - 1]`组成空串时，`dp[i][j]`与`dp[i][j - 2]`有关
>      + 当`*`与`p[j - 1]`组成字符`a`时，`dp[i][j]`与`dp[i - 1][j - 2] and s[i] == p[j - 1]`有关
>      + 当`*`与`p[j - 1]`组成字符`aa`时，`dp[i][j]`与`dp[i - 2][j - 2] and s[i] == s[i - 1] == p[j - 1]`有关
>      + 当`*`与`p[j - 1]`组成字符`aaa`时，`dp[i][j]`与`dp[i - 3][j - 2] and s[i] == s[i - 1] == s[i - 2] == p[j - 1]`有关
>      + 。。。
>      + 当`*`与`p[j - 1]`组成字符`k*a`时，`dp[i][j]`与`dp[i - k][j - 2] and s[i] == s[i - 1] == s[i-k+1] == p[j - 1]`有关
>      + 令`i = i - 1`有：
>        + 当`*`与`p[j - 1]`组成空串时，`dp[i - 1][j]`与`dp[i - 1][j - 2]`有关
>        + 当`*`与`p[j - 1]`组成字符`a`时，`dp[i - 1][j]`与`dp[i - 2][j - 2] and s[i - 1] == p[j - 1]`有关
>        + 当`*`与`p[j - 1]`组成字符`aa`时，`dp[i - 1][j]`与`dp[i - 3][j - 2] and s[i - 1] == s[i - 2] == p[j - 1]`有关
>        + 当`*`与`p[j - 1]`组成字符`aaa`时，`dp[i - 1][j]`与`dp[i - 4][j - 2] and s[i - 1] == s[i - 2] == s[i - 3] == p[j - 1]`有关
>        + 。。。
>        + 当`*`与`p[j - 1]`组成字符`k*a`时，`dp[i - 1][j]`与`dp[i - 1 - (k - 1)][j - 2] and s[i - 1] == s[i - 2] == s[i - 1 - (k - 1) + 1] == p[j - 1]`有关。化简得：`dp[i - 1][j]`与`dp[i - k][j - 2] and s[i - 1] == s[i - 2] == s[i - k + 1] == p[j - 1]`有关。
>          + 这里`k`被替换成`k - 1`是因为`i`被减了`1`，而`i - k`必须大于等于`0`，因此最大扩展项只能扩展到`k - 1`项
>          + 将`dp[i - 1 - (k - 1)][j - 2]`化简，得`dp[i - k][j - 2]`
>          + 将`s[i - 1 - (k - 1) + 1]`化简，得`s[i - k + 1]` 
>      + 观察`i`被替换前后的表达式，发现`dp[i - 1][j]`的拓展式跟`dp[i][j]`的拓展式，后`k - 1`项是一样的，只差了一个相等元素`s[i]`。因此`dp[i][j]`的拓展式可以收敛为：
>        + `dp[i][j]`与`dp[i - 1][j] and s[i] == p[j - 1] or dp[i][j - 2]`
>      + 特殊情况：当`p[j - 1] == '.'`时，`s[i] == p[j - 1]`是恒成立的，因此最终拓展式收敛为：
>        + `dp[i][j]`与`dp[i - 1][j] and (s[i] == p[j - 1] or p[j - 1] == '.') or dp[i][j - 2]`有关
> 2. 状态转移方程：
>    + 当`p[j - 1]`为字母时：
>      + `dp[i][j] = dp[i - 1][j - 1] and s[i] == p[j]`
>    + 当`p[j - 1]`为`.`时：
>      + `dp[i][j] = dp[i - 1][j - 1]`
>    + 当`p[j - 1]`为`*`时：
>      + `dp[i][j] = dp[i - 1][j] and (s[i] == p[j - 1] or p[j - 1] == '.') or dp[i][j - 2]`
> 3. 状态初始化：
>    + 根据题意，空串也是一种有效的字符串。因此需要在字符`s`和字符`p`之前加上一个空串。则`dp`矩阵维度为`(len(s) + 1) x (len(p) + 1)`
>    + 根据以上分析：
>      + `dp[0][0] = True`
>      + `dp[0][j] = dp[0][j - 2] and p[j] == '*'`
> 4. 运行顺序：
>    + 先列后行

~~~python
                                                                                                                                          class Solution:
    def isMatch(self, s: str, p: str) -> bool:
    	m, n = len(s), len(p)
        dp =  [False for _ in range(n + 1)]
        dp[0] = True
        for j in range(1, n + 1):
            if p[j - 1] == '*':
                dp[j] = dp[j - 2]
        for i in range(1, m + 1):
            temp = [False for _ in range(n + 1)]
            for j in range(1, n + 1):
                if 'a' <= p[j - 1] <= 'z':
                    temp[j] = dp[j - 1] and s[i - 1] == p[j - 1]
                elif p[j - 1] == '.':
                    temp[j] = dp[j - 1]
                else:
                    temp[j] = dp[j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.') or temp[j - 2]
            dp = temp
        return dp[-1]
~~~

> 空间优化：二维循环中，`dp[i][j]`状态只与正上方和左边的状态有关，那么可以简化空间

~~~python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)
        dp =  [False for _ in range(n + 1)]
        dp[0] = True
        for j in range(1, n + 1):
            dp[j] = dp[j - 2] and p[j - 1] == '*'
        for i in range(1, m + 1):
            temp = [False for _ in range(n + 1)]
            for j in range(1, n + 1):
                if 'a' <= p[j - 1] <= 'z':
                    temp[j] = dp[j - 1] and s[i - 1] == p[j - 1]
                elif p[j - 1] == '.':
                    temp[j] = dp[j - 1]
                else:
                    temp[j] = dp[j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.') or temp[j - 2]
            dp = temp
        return dp[-1]
~~~

## 11.盛最多水的容器

题目链接：[力扣-11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water)

> 思路：两头往中间逼近
>
> 1. 定义左边界`left`和右边界`right`，计算左右边界中间能装的水`area = min(height[left], height[right]) * (right - left)`
> 2. 当左边的高度大于右边的高度时，更新右边界。因为只有找到更大的边界，装水的容积才会变大
> 3. 跟`1`相反，当右边的高度大于左边的高度时，更新左边界

~~~python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        size = len(height)
        left, right = 0, size - 1
        ans = 0
        while left < right:
            area = min(height[left], height[right]) * (right - left)
            ans = ans if ans >= area else area
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        return ans             
~~~

## 15.三数之和

题目链接：[力扣-15. 三数之和](https://leetcode.cn/problems/3sum)

> 思路：三指针 + 排序
>
> 1. 先给数组按照从小到大进行排序
> 2. 指针`1`为从左到右按序遍历的数组元素
> 3. 固定指针`1`，指针`2`从指针`1`的下一位开始遍历，指针`3`从数组结尾向前遍历
> 4. 判断三个指针所指数字的和是否为`0`
>    + 如果为`0`，收集三个指针所指数字进`res`。然后判断三个指针的各自的重复性，如果指针`1`右边的数字和其重复，那么指针`1`直接跳至不重复的第一个数字所在。同样判断指针`2`右边和指针`3`左边的重复数字。这样是为了防止`res`中收集到重复答案。
>    + 如果不为`0`，和大于`0`证明需要减小和逼近`0`，因此指针`3`左移。相反指针`2`右移
> 5. 剪枝
>    + 当指针`1`遍历到大于`0`的元素时，终止遍历，因为往后的元素不可能再大于零
>    + 当指针`1`和指针`2`的和大于`0`时，终止遍历，因为往后遍历不可能大于零

~~~python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        size = len(nums)
        res = []
        i = 0
        while i < size:
            if nums[i] > 0 or i < size - 1 and nums[i] + nums[i + 1] > 0      :
                break
            left = i + 1
            right = size - 1
            while left < right:
                if nums[i] + nums[left] > 0:
                    break
                add = nums[i] + nums[left] + nums[right]
                if add == 0:
                    res.append([nums[i], nums[left], nums[right]])
                    while i + 1 < size and nums[i + 1] == nums[i]:
                        i += 1
                    while left + 1 < size and nums[left + 1] == nums[left]:
                        left += 1
                    while right - 1 > -1 and nums[right - 1] == nums[right]:
                        right -= 1
                    left += 1
                    right -= 1
                elif add < 0:
                    left += 1
                else:
                    right -= 1
            i += 1
        return res
~~~

## 17.电话号码的字母组合

题目链接：[力扣-17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number)

> 思路：回溯
>
> 1. 递归终止条件：遍历到数字串最后一位
> 2. 单层递归逻辑：
>    + 从数字字符串`digits`中取出其数字对应的字母组合`eles`
>    + 单层遍历`eles`里面的元素`ele`，将其组合
> 3. 参数与返回值：
>    + 参数：按需添加
>    + 返回值：组合问题无返回值

~~~python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        dic = {
            '2' : 'abc',
            '3' : 'def',
            '4' : 'ghi',
            '5' : 'jkl',
            '6' : 'mno',
            '7' : 'pqrs',
            '8' : 'tuv',
            '9' : 'wxyz'
        }
        index = 0
        res = []
        size = len(digits)
        self.back_tracking(index, '', res, size, dic, digits)
        return res

    def back_tracking(self, index, path, res, length, dic, digits):
        if index == length:
            res.append(path)
            return
        eles = dic[digits[index]]
        for ele in eles:
            self.back_tracking(index + 1, path + ele, res, length, dic, digits)
~~~

## 19.删除链表的倒数第N个节点

题目链接：[力扣-19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

> 思路：快慢指针
>
> 1. 快指针`fast`先跑`N`步，慢指针`slow`随后跟着一起跑。
> 2. 当慢指针`fast.next == None`时，令`fast.next = fast.next.next`
> 3. 给链表加上前置节点，防止只有一个节点时，删除节点的代码出错

~~~python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        pre = ListNode()
        pre.next = head
        slow = pre
        fast = pre
        while fast.next:
            fast = fast.next
            if n:
                n -= 1
            else:
                slow = slow.next
        slow.next = slow.next.next
        return pre.next
~~~

## 20.有效的括号	

题目链接：[力扣-20. 有效的括号](https://leetcode.cn/problems/valid-parentheses)

> 思路一：栈
>
> 1. 使用字典`dic`存放三种右左括号的对应关系，`key`为右括号，`value`为左括号
> 2. 遇到左括号，入栈
> 3. 遇到右括号，出栈。并比较在`dic`中，当前右括号为`key`对应的`value`是否等于出栈的左括号。相等继续往下遍历，不相等返回`False`
> 4. 结束遍历后，栈为空返回`True`，不为空返回`Fasle`
> 5. 不能用括号所在的奇偶性判断有效性，因为正负括号都可能在奇偶的位置
>    + `({[]})`这个样例中，`{`出现在了偶数位，`}`出现在了奇数位
> 6. 对于代码`s[i] in ']})'`或者`s[i] in dic.values()`的取舍：
>    + 代码1的 `s[i] in '({['` 是对**固定字符串**的直接查找；
>    + 代码2的 `s[i] in dic.values()` 是对**动态生成对象**的查找。
>    + 尽管两者的时间复杂度都近似为 $O(1)$（因括号类型有限），但代码1避免了动态对象的生成，**整体性能更高**。

~~~python
class Solution:
    def isValid(self, s: str) -> bool:
        size = len(s)
        if size % 2 == 1:
            return False
        stack = []
        dic = {')': '(',
               ']': '[',
               '}': '{'
               }
        for i in range(size):
            if s[i] in ']})':
                if not stack or stack and stack.pop() != dic[s[i]]:
                    return False
            else:
                stack.append(s[i])
        return True if not stack else False
~~~

> ~~思路二：计数~~
>
> 1. ~~使用变量`count`记录左括号个数~~
> 2. ~~遇到左括号`count`加一，反之减一。如果遇到右括号时，`count == 0`，证明遇到了多余的右括号，返回`False`。~~
> 3. ~~结束遍历时，`count`不等于零，则证明左括号多余。`return count == 0`~~
> 4. 这个思路是错误的，解决不了两个左右括号不匹配的问题，例如`s = (]`，会返回`True`

## 21.合并两个有序链表

题目链接：[力扣-21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

> 思路：单向遍历
>
> 1. 前置节点`head`用处很大，可以避免空样例报错。

~~~python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        head = ListNode()
        pre = head
        while list1 and list2:
            if list1.val >= list2.val:
                pre.next = ListNode(list2.val)
                list2 = list2.next
            else:
                pre.next = ListNode(list1.val)
                list1 = list1.next
            pre = pre.next
        pre.next = list1 if list1 else list2
        return head.next
~~~

## 22.括号生成

> 思路：DFS
>
> 1. 终止条件：
>    + 当右括号生成数量大于左括号生成数量时，终止
>    + 当右括号`right == n`时，证明括号生成完毕，可以终止递归
> 2. 参数和返回值：
>    + 参数：按需设定
>    + 返回值：无返回值
> 3. 单层递归逻辑：
>    + 当左括号数量`left < n`时，可生成左括号
>    + 当右括号数量`right < left`时，可生成右括号

~~~python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        left, right = 0, 0
        self.dfs('', res, left, right, n)
        return res

    def dfs(self, path, res, left, right, n):
        if right > left:
            return
        if right == n:
            res.append(path)
            return
        if left < n:
            self.dfs(path + '(', res, left + 1, right, n)
        if left > right:
            self.dfs(path + ')', res, left, right + 1, n)
~~~

## 23.合并K个升序链表

题目链接：[力扣-23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

> 思路1：分治
>
> 1. 将`K`个升序链表分别合并（归并思想）
> 2. 返回合并好的链表

~~~python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        size = len(lists)
        if size <= 1:
            return None if size == 0 else lists[0]
        half = size // 2
        left = lists[0:half]
        right  = lists[half:]
        return self.merge(self.mergeKLists(left), self.mergeKLists(right))

    def merge(self, list1, list2):
        head = ListNode()
        pre = head
        while list1 and list2:
            if list1.val >= list2.val:
                pre.next = ListNode(list2.val)
                list2 = list2.next
            else:
                pre.next = ListNode(list1.val)
                list1 = list1.next
            pre = pre.next
        pre.next = list1 if list1 else list2
        return head.next
~~~

> 思路2：利用堆
>
> 1. 遍历数组中每一个链表，将头节点的地址加入堆中，按照节点值做比较依据
> 2. 维护一个最小堆，每次循环出堆的值为最小值所对应节点`node`，同时建立新的链表节点。其值为刚出堆的节点值
> 3. 令`node = node.next`，将新的`node`加入堆并更新堆

~~~python
class Heap:
    def __init__(self, count, nums, size):
        self.count = count
        self.nums = nums
        self.size  = size

    def up(self, index):
        while index > 0 and (index - 1) // 2 >= 0:
            if self.nums[index].val < self.nums[(index - 1) // 2].val:
                self.nums[index], self.nums[(index - 1) // 2] = self.nums[(index - 1) // 2], self.nums[index]
            index = (index - 1) // 2

    def down(self, end):
        start = 0
        while 2 * start + 1 <= end:
            index = 2 * start + 1
            if index + 1 <= end and self.nums[index].val > self.nums[index + 1].val:
                index += 1
            if self.nums[start].val <= self.nums[index].val:
                break
            self.nums[index], self.nums[start] = self.nums[start], self.nums[index]
            start = index

    def push(self, node):
        if self.count < self.size:
            self.nums[self.count] = node
        else:
            self.nums.append(node)
        self.up(self.count)
        self.count += 1
        self.size += 1

    def pop(self):
        if not self.count:
            return None
        val = self.nums[0]
        if self.count > 1:
            self.nums[0] = self.nums[self.count - 1]
            if self.count > 2:
                self.down(self.count - 2)
        self.count -= 1
        return val

    def build(self):
        end = self.size
        for i in range(end):
            self.up(i)

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        size = len(lists)
        nums = []
        for i in range(size):
            if lists[i]:
                nums.append(lists[i])
        count = len(nums)
        heap = Heap(count, nums, count)
        heap.build()									
        head = ListNode()
        pre = head
        while heap.count:
            node = heap.pop()
            pre.next = ListNode(node.val)
            node = node.next
            if node:
                heap.push(node)
            pre = pre.next
        return head.next 
~~~



##   31.下一个排列

题目链接[力扣-31.下一个排列](https://leetcode.cn/problems/next-permutation/description/)

> 思路 ：倒序查找
>
> 1. 我们希望下一个数比当前数大，这样才满足**下一个排列**的定义。因此只需要 将后面的**「大数」**与前面的**「小数」**交换，就能得到一个更大的数。比如 `123456`，将 `5`和 `6` 交换就能得到一个更大的数 `123465`。
> 2. 我们还希望下一个数增加的幅度尽可能的小，这样才满足**下一个排列与当前排列紧邻**的要求。为了满足这个要求，我们需要：
>    + 在 **尽可能靠右的低位** 进行交换，需要 **从后向前** 查找
>    + 将一个 **尽可能小的「大数」** 与前面的**「小数」**交换。比如 `123465`，下一个排列应该把 `5` 和 `4` 交换而不是把 `6` 和 `4` 交换
>      将**「大数」**换到前面后，需要将**「大数」**后面的所有数 **重置为升序**，升序排列就是最小的排列。以 `123465` 为例：首先按照上一步，交换 `5` 和 `4`，得到 `123564`；然后需要将 `5` 之后的数重置为升序，得到 `123546`。显然 `123546` 比 `123564` 更小，`123546` 就是 `123465` 的下一个排列
> 3. 倒序寻找第一个降序所在的位置 `i`
> 4. 然后从倒序遍历过的数字中，找出刚好大于位置 `i` 的数字，位置记为 `j`
> 5. 交换`i`, `j`位置上的数字，因为原数组`nums[i] > nums[j + 1]`，那么交换位置后，数组`nums[i+1:size]`，也为降序
> 6. 因为交换位置后，数组组成的数字高位已经变大很多，为了寻找下一个排列，则需要将交换后，`i` 位置往后的数字升序排列
>    + 因为需要找到第一个降序的数字，所以遍历过的数字**一定是升序的**

```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        size = len(nums)
        index = -1
        for i in range(size - 1, -1, -1):
            if i - 1 > -1 and nums[i] > nums[i - 1]:
                index = i - 1
                break
        if index > -1:
            for i in range(size - 1, -1 , -1):
                if nums[i] > nums[index]:
                    nums[i], nums[index] = nums[index], nums[i]
                    break
        left = index + 1
        right = size - 1
        while left < right:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
            right -= 1
```

## 32.最长有效括号

题目链接[力扣-32.最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

> 思路: 动态规划
>
> 1. 初始化状态：`dp[i]`表示以 `i` 为结尾的有效括号个数
>    + 当`s[i]`为 `(` 时，`dp[i] = 0`
>    + 当`s[i]`为 `)` 时，`s[i - 1]`为 `(` ，那么`dp[i]`状态与`dp[i - 2]`有关
>    + 当`s[i]`为 `(` 时，`s[i - 1]`为 `)` ，那么`dp[i]`状态与`dp[i - 1] `和 `s[i - dp[i - 1] - 1]` 及 `dp[i - dp[i - 1] - 2]`有关
> 2. 状态转移方程：
>    + `dp[i] = dp[i - 2] + 2`   当`s[i]`为 `)`时，`s[i - 1]`为 `(`
>    + `dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2`   当`s[i] = ) `且` s[i - 1] = )`且 `s[i - dp[i - 1] -1] = (`时
> 3. 初始化：
>    + 当`s[i]`为 `(`，`dp[i] = 0`
>    + `dp[0] = 0`
> 4. 运行顺序：从左到右
>
> **注意:** 在子问题`3`中，已经讨论了`s[i]`连续为`n`个`)`的问题，当为连续`n`个`)`时，遍历过的`dp[i - 1]，dp[i - 2] ... dp[i - n`]都已经在遍历时讨论过了

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        if not s:
            return 0
        size = len(s)
        dp = [0] * size
        for i in range(1, size):
            if s[i] == ')':
                if s[i - 1] == '(':
                    dp[i] = dp[i - 2] + 2
                else:
                    if i - dp[i - 1] - 1  >= 0 and s[i - dp[i - 1] - 1] == '(':
                        dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]
        return max(dp)
```

## 33.搜索螺旋排序数组

题目链接[力扣-33.搜索螺旋排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)

> 思路：二分查找
>
> 1. 在二分查找时，无论怎么分，一定有一半数组是有序数组
> 2. 即然能确定一般数组是有序的数组，那么就可以确定`target`是否在这半边有序数组中。有则左右边界`left`和`right`收敛为有序数组。没有则收敛为另一半旋转数组。这样每循环一次，数组规模就会减小一半，跟有序数组的二分法效率一致
>
> 注意：`elif nums[mid] >= nums[left]:`这一步写成`>=`更好

~~~python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        size = len(nums)
        left = 0
        right = size - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] >= nums[left]:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1·	`                             
~~~

## 34.在排序数组中查找元素的第一个和最后一个位置

题目链接[力扣-34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

> 思路：因为更新`right`时，右边界`right`总是在减小，所以合并`nums[mid] == target`这个条件，会逐渐逼近左边界。同理`left`逼近右边界
>
> 1. 当nums[mid] == target时，与搜索条件nums[mid] < target合并。那么左边界left会不停的逼近nums中等于target值的右边界
> 2. 当nums[mid] == target时，与搜索条件nums[mid] > target合并。那么右边界right会不停的逼近nums中等于target值的左边界

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        size = len(nums)
        left = 0
        right = size - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] >= target:
                right = mid - 1
            else:
                left = mid + 1
        left1 = 0
        right1 = size - 1
        while left1 <= right1:
            mid = left1 + (right1 - left1) // 2
            if nums[mid] > target:
                right1 = mid - 1
            else:
                left1 = mid + 1
        return [right + 1, left1 - 1] if left1 - 1 >= right + 1 else [-1, -1]
```

## 39.组合总和

题目链接[力扣-39.组合总和](https://leetcode.cn/problems/combination-sum/)

> 思路：回溯
>
> 1. 终止条件：`target == 0`。使用`path`收集遍历过的`nums[i]`，等满足终止条件时，将`path`加入`res`
> 2. 返回值：因为时组合问题，不需要返回值。
> 3. 遍历数组`candidates`

```python
# 回溯
# 1、
# 2、终止条件：终止条件为target == 0。
# 3、单层递归逻辑：遍历数组nums，同时target -= nums[i]。如果小于0，直接continue到下一个nums[j]，大于0则进入下一层递归。为了避免重复值，下层的 #    startIndex需要从i开始。从零开始会造成重复答案
```

## 42.接雨水

题目链接[力扣-42.接雨水](https://leetcode.cn/problems/trapping-rain-water/)

> 思路：双指针法，纵向直接一步到位求出`index`对应的水位有多深。
>
> 1. 记录`index`位置左右两边的最大值，那么与左右两边最大值中的较小值的差，为该`index`位置的水位。
> 2. 将水位求和，那么就是蓄水大小
> 3. 因为水池中，可能会有砖头，石块。意思就是相邻比`index`位置大的位置，可能就是水池的砖头和石块，并不是池子的边界。所以需要index左右两边的最大值

~~~python
class Solution:
    def trap(self, height: List[int]) -> int:
        size = len(height)
        left_max = [0] * size
        right_max = [0] * size
        left_max[0] = height[0]
        right_max[size - 1] = height[size - 1]
        for i in range(1, size):
            left_max[i] = max(left_max[i - 1], height[i])
            index = size - 1 - i
            right_max[index] = max(right_max[index + 1], height[index])
        area = 0
        for i in range(1, size - 1):
            area += min(left_max[i], right_max[i]) - height[i]
        return area
~~~

>  思路：单调栈是横向求出一个池塘不同水位能装多少水，然后累加起来求总和
>
> 1. 维护一个单调递减栈，这样能保证`index`左右两边水位比`index`水位高。
> 2. 在右边遇到一个比栈顶大的值，那么可以求出这层水位的含水量.

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        size = len(height)
        stack = collections.deque()
        res = 0
        for i in range(size):
            while stack and height[stack[-1]] <= height[i]:
                bottom = stack.pop()
                if stack:
                    h = min(height[stack[-1]], height[i]) - height[bottom]
                    w = i - stack[-1] - 1
                    area = h * w
                    res += area
            stack.append(i)
        return res
```

## 46.全排列

题目链接[力扣-46.全排列](https://leetcode.cn/problems/permutations/description/)

> 思路：回溯
>
> 1. 如果不考虑数组遍历范围，那么res里面相同的数字会出现多次
> 2. 如果使用`index`自增，那么小于`index`的数组值无法被取到
> 3. 综上，只能改变`nums`，在下一次迭代之前将已加入`path`的`nums`值直接剔除

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        size = len(nums)
        res = []
        path = []
        count = 0
        self.dfs(size, nums, res, path, count)
        return res
    
    def dfs(self, size, nums, res, path, count):
        if count == size:
            res.append(copy.deepcopy(path))
            return
        for i in range(len(nums)):
            path.append(nums[i])
            self.dfs(size, nums[:i] + nums[i + 1:], res, path, count + 1)
            path.pop()
```

## 48.旋转图像

### 1.旋转矩阵的基本方法

1. **90° 顺时针旋转**：
   - **步骤1**：将矩阵转置（行列互换）。
   - **步骤2**：反转每一行。
2. **90° 逆时针旋转**：
   - **步骤1**：将矩阵转置。
   - **步骤2**：反转每一列。
3. **180° 旋转**：
   - 直接将矩阵中的元素对称交换。
4. **270° 顺时针旋转**（即90° 逆时针旋转）：
   - 可以通过90°顺时针旋转三次实现，或者按逆时针旋转的步骤进行。

### 2.旋转算法实现

以下是Python代码实现不同角度的矩阵旋转。

#### 2.1 90° 顺时针旋转

```python
def rotate_90_clockwise(matrix):
    n = len(matrix)
    # 矩阵转置
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # 每行反转
    for i in range(n):
        matrix[i].reverse()
    return matrix
```

#### 2.2 90° 逆时针旋转

```python
def rotate_90_counterclockwise(matrix):
    n = len(matrix)
    # 矩阵转置
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # 每列反转
    for j in range(n):
        for i in range(n // 2):
            matrix[i][j], matrix[n - 1 - i][j] = matrix[n - 1 - i][j], matrix[i][j]
    return matrix
```

#### 2.3 180° 旋转

```python
def rotate_180(matrix):
    n = len(matrix)
    for i in range(n):
        for j in range(n):
            if i < n // 2 or (i == n // 2 and j < n // 2):
                matrix[i][j], matrix[n - 1 - i][n - 1 - j] = matrix[n - 1 - i][n - 1 - j], matrix[i][j]
    return matrix
```

### 3.示例

假设我们有一个3x3的矩阵：

```python
python复制代码matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# 顺时针旋转90°
print(rotate_90_clockwise(matrix))

# 逆时针旋转90°
print(rotate_90_counterclockwise(matrix))

# 旋转180°
print(rotate_180(matrix))
```

### 4.旋转角度依据

- **90° 顺时针**：元素 `(i,j)` 移动到 `(j, n − 1 − i)`。

  ① 转置：`(i, j) → (j, i)`

  ② 反转：`(j, i) → (j, n - 1 - i)`

  综上，从`(i, j)`移动到`(j, n - 1 -i)`，只需转置和反转两步

- **90° 逆时针**：元素 `(i, j)` 移动到 `(n − 1 − j, i)`。

- **180°**：元素 `(i,j)`移动到`(n − 1 − i,n − 1 − j)`。

## 49.字母异位词分组

> 思路1：将数组中的每个字符串排序，然后作为字典的key。value为一个接收相同key值的字符串数组，遇到相同key就append
>         思路2：计数字符串，然后将字符串中每个字符和其计数组合成新字符串，例如a1b2c3，作为key

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        dic = collections.defaultdict(list)
        for str in strs:
            dic[self.count(str)].append(str)
        return list(dic.values())

    def count(self, cs):
        arr = [0] * 26
        for c in cs:
            index = ord(c) - ord('a')
            arr[index] += 1
        key = ''
        for i in range(26):
            if arr[i]:
                key = key + str(arr[i]) + chr(i + ord('a'))
        return key
```

## 53.最大子数组和

题目链接[力扣-53.最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

> 思路：动态规划
>
> 1. 初始化状态：`dp[i]`表示以`nums[i]`结束的连续序列的最大值
>    + 子问题：那么题目要求连续，那么状态只有两种，一种是`nums[i]`和`index`小于`i`的序列组合成和更大的序列。另一种是不和之前的序列组合，`nums[i]`单独成一个序列的起始位置
> 2. 状态转移方程：
>    + `dp[i] = max(dp[i - 1] + nums[i], nums[i])`
> 3. 初始化状态：
>    + `dp[0] = nums[0]`
> 4. 运行顺序：从左到右

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        size = len(nums)
        dp = [-10001] * size
        dp[0] = nums[0]
        for i in range(1, size):
            dp[i] = nums[i] if dp[i - 1] < 0 else nums[i] + dp[i - 1]
        return max(dp)
```

## 55.跳跃游戏

题目链接[力扣-55.跳跃游戏](https://leetcode.cn/problems/jump-game/description/)

> 思路1：动态规划
>
> 1. 初始化状态：`dp[i]`表示能否跳跃到当前位置
>    + 子问题1：`dp[i]`状态与`dp[0 : i-1]`有关
> 2. 状态转移方程：`dp[i] = dp[j] and nums[j] >= (i - j)  j=0,1,...,i-1`
> 3. 初始值：`dp[0] = True`
> 4. 运行顺序：从左到右。补充：如果`j`遍历从左到右，那么会出现超时的情况。因此将`j`从右到左遍历，增大找到使`dp[i] = true`的`j`的概率，提交通过

~~~python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        size = len(nums)
        dp = [False] * size
        dp[0] = True
        for i in range(1, size):
            for j in range(i - 1, -1, -1):
                dp[i] = dp[j] and j + nums[j] >= i
                if dp[i]:
                    break
        return dp[-1]
~~~

> 思路2：使用贪心算法
>
> 1. 设置一个变量`loc_max`，记录遍历过的位置所能达到的最远位置。
> 2. 如果最远位置`loc_max`小于当前位置`i`，那么表示最远也不可能达到当前位置`i`，直接返回`false`

~~~python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        size = len(nums)
        loc_max = 0
        for i in range(size):
            if loc_max < i:
                return False
            loc_max = max(loc_max, i + nums[i])
        return True
~~~

## 56.合并区间

题目链接[力扣-56.合并区间](https://leetcode.cn/problems/merge-intervals/description/)

> 思路：排序 + 遍历合并
>
> 1. 按照左边界进行排序
> 2. 设立两个变量`left`, `right`分别记录合并后的左右边界，遍历`intervals`，更新右边界
> 3. 当`intervals[i]`的左边界大于`right`时，记录下`left`, `right`。并更新`intervals[i]`记录的值为`left`和`right`

~~~python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        size = len(intervals)
        self.quick_sort(intervals, 0, size - 1)
        res = []
        left = intervals[0][0]
        right = intervals[0][1]
        for i in range(1, size):
            if right < intervals[i][0]:
                res.append([left, right])
                left = intervals[i][0]
                right = intervals[i][1]
            else:
                right = right if right >= intervals[i][1] else intervals[i][1]
        res.append([left, right])
        return res

    def quick_sort(self, nums, left, right):
        if left >= right:
            return
        L, R = left, right
        mid = nums[left]
        while L < R:
            while L < R and nums[R][0] >= mid[0]:
                R -= 1
            if L < R:
                nums[L] = nums[R]
            while L < R and nums[L][0] <= mid[0]:
                L += 1
            if L < R:
                nums[R] = nums[L]
            if L == R:
                nums[L] = mid
        self.quick_sort(nums, left, R - 1)
        self.quick_sort(nums, L + 1, right)
~~~

## 62.不同路径

题目链接[力扣-62.不同路径](https://leetcode.cn/problems/unique-paths/description/)

~~~python
# 1、初始化状态：
#   dp[i][j] 表示从左上角到当前格子有多少条路径
# 1.1 子问题1：
#   dp[i][j]来源只能来自左边和上边，且 i == 0 时，只能来自左边
# 2、状态转移方程：
#   dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
# 3、状态初始化：
#   dp[0][j] = 1, dp[i][0] = 1
# 4、运行顺序：
#   先m，后n
~~~

## 75.颜色分类

题目链接[力扣-75.颜色分类](https://leetcode.cn/problems/sort-colors/description/)

~~~python
# 双指针，数字0的指针index0，指向1序列的第一个位置，
# 数字1的指针index1指向1序列结束的下一个位置（即遍历到的最新的nums[i])
# 值得注意的是，判断nums[i]为0、1、2时，要用if elif，单独用if时，会造成二次交换
~~~

## 76.最小覆盖子串

题目链接[力扣-76.最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/)

~~~python
# 思路：滑动窗口
# 1、两个字典，一个字典A记录目标字符串t的字符计数情况。另一个字典B记录遍历过的字符的计数情况
# 2、设置变量match,left，假如字典B中某个字符subs计数B[subs] == A[subs]，那么match加一。
# 3、如果match == len(A)，那么表示完全匹配，计算i - left + 1的值与已记录符合题意子串长度作比较，记录较小子串
# 4、更新left
# 值得注意的是，当match == len(A)，更新left时，要注意B[subs] > A[subs]的情况。所以更新结束条件为while match == len(A)
~~~

## 78.子集

题目链接[力扣-78.子集](https://leetcode.cn/problems/subsets/description/)

~~~python
# 思路：回溯
# 注意下一层回溯起始位置为当前层遍历的位置 i + 1
~~~

## 79.单词搜索

题目链接[力扣-79.单词搜索](https://leetcode.cn/problems/word-search/description/)

> 思路：深度优先搜索题
>
> 1. 定义四个方向，和一个记录搜索路径的状态数组`record`。注意`record`记录的是当前层某一个方向A向下dfs时被搜索过的记录，当这个方向`A`搜索完成时，需要恢复`record`的状态。因为在该层换方向`B`向下搜索时，该位置只要不是上一层被搜索过且设置为`True`，在方向B向下搜索时是可以被搜索的。
>
> 2. 不能直接返回递归调用的状态，因为这项相当于直接中断每一层的遍历
>
> 3. 带返回值的递归，可以在当前层遍历完成后，再决定返回什么样的状态

~~~python
class Solution:
    def exist(self, board, word):
        m, n = len(board), len(board[0])
        to = [[-1, 0], [1, 0], [0, 1], [0, -1]]
        size = len(word)
        for i in range(m):
            for j in range(n):
                if board[i][j] == word[0]:
                    index = 1
                    record = [[False] * n for _ in range(m)]
                    record[i][j] = True
                    if self.dfs(record, to, size, index, board, word, m, n, i, j):
                        return True
        return False

    def dfs(self, record, to, size, index, board, word, m, n, i, j):
        if index == size:
            return True
        for direction in to:  # 每一层遍历的方向
            x = i + direction[0]
            y = j + direction[1]
            if x < m and x > -1 and y > -1 and y < n and not record[x][y] and board[x][y] == word[index]:
                record[x][y] = True  # 表示当前方向往下dfs时，这个位置不能被检索了
                if self.dfs(record, to, size, index + 1, board, word, m, n, x, y):  # 这里不能直接return，不然中断方向的遍历
                    return True
                record[x][y] = False  # 记得恢复状态，因为换个方向往下搜索是可以搜这个格子的
        return False  # 每一层方向遍历完成后，决定返回什么状态
~~~

## 84.柱状图中的最大矩形

题目链接[力扣-84.柱状图中的最大矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

> 思路1：暴力搜索，将每一个`nums[i]`向两边遍历，直到遇到比自己小的`nums[left]`和`nums[right]`才停止。`w = right - left + 1, h = nums[i]`
>
> 思路2：单调栈，定义一个单调递增栈。思路和思路`1`差不多，只不过单调栈会把遍历过的数字存储起来，不需要遍历第二遍
>
> 1. 碰到比`stack[-1]`小的数字开始出栈，`index = stack.pop()，h = height[index], w = i - stack[-1] - 1`
>
> 2. 值得注意的是，`w = i - index`是不正确的，因为假如`index`和`stack[-1]`不为相邻元素，那么`w`会被减小
>
> 3. 单调递增栈的出栈条件是遇到比栈顶更小的元素，如果数组为单调递增数组，那么无法出栈，所以可以在原数组末端`nums.append(0)`，保证出栈。
>
> 4. 当栈中只剩下一个元素时，`stack.pop()`后，`w = i - stack[-1] - 1` 无法执行，所以可以在头位置加一个元素`0`，或者做一个`else`判断，为空则 `w = i`。
>    + 因为`pop`之前`stack`中是有值的，而且这个值一定是数组中目前遍历到i位置的最小值，所以其宽度能直接扩展到`i`。

~~~python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights.append(0)
        size = len(heights)
        stack = []
        res = 0
        for i in range(size):
            while stack and heights[stack[-1]] > heights[i]:
                index = stack.pop()
                h = heights[index]
                if stack:
                    # 这里不能写w = i - index，因为index和stack[-1]可能不是连在一起的，如果不连在一起，会导致从stack[-1]到index之间的w没被计算到，导致结果变小
                    w = i - stack[-1] - 1
                else:
                    # stack为空，那么肯定栈中元素都是大于零的，因为最后一个元素为0，如果前面有0元素，那么不会出栈
                    w = i
                res = max(res, w * h)
            stack.append(i)
        return res
~~~

## 85.最大矩形

题目链接[力扣-85.最大矩形](https://leetcode.cn/problems/maximal-rectangle/description/)

~~~python
# 思路：将matrix前i行都看做一个柱状图，沿用84题的思路。遍历每一行，将前i行的每一列值累加起来，就是84题中的高度。
# 1、当某一个matrix[i][j] == 0时，这一行的高度重置为0
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        m, n = len(matrix), len(matrix[0])
        heights = [0] * n
        res = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    heights[j] += 1
                else:
                    heights[j] = 0
            res = max(res, self.max_rec(copy.deepcopy(heights)))
        return res

    def max_rec(self, heights):
        max_res = 0
        stack = []
        heights.append(0)
        size = len(heights)
        for i in range(size):
            while stack and heights[stack[-1]] > heights[i]:
                index = stack.pop()
                h = heights[index]
                if stack:
                    w = i - stack[-1] - 1
                else:
                    w = i
                max_res = max(max_res, w * h)
            stack.append(i)
        return max_res
~~~

## 94.二叉树的种类

### 1. 普通二叉树 (Binary Tree)

**图示**：

```markdown
     1
    / \
   2   3
  / \   \
 4   5   6
```

**注意事项**：

- 每个节点最多有两个子节点。
- 节点的子节点可以是空的。

------

### 2. 满二叉树 (Full Binary Tree)

**图示**：

```markdown
     1
    / \
   2   3
  / \ / \
 4  5 6  7
```

**注意事项**：

- 每个节点要么没有子节点，要么有两个子节点。
- 完全填满每一层。

------

### 3. 完全二叉树 (Complete Binary Tree)

**图示**：

```markdown
     1
    / \
   2   3
  / \ / 
 4  5 6  
```

**注意事项**：

- 除了最后一层外，所有层上的节点都达到最大数目。
- 最后一层的节点尽可能地靠左排列。

------

### 4. 平衡二叉树 (Balanced Binary Tree)

**图示**：

```markdown
     3
    / \
   2   4
  /     \
 1       5
```

**注意事项**：

- 任意节点的左右子树高度差不超过1。
- 需要平衡操作来保持树的平衡。

------

### 5. 二叉搜索树 (Binary Search Tree, BST)

**图示**：

```markdown
     4
    / \
   2   6
  / \ / \
 1  3 5  7
```

**注意事项**：

- 对于树中的任意节点，其左子树上所有节点的值都小于该节点的值，其右子树上所有节点的值都大于该节点的值。
- 插入和删除操作需要保持这个性质。

------

### 6. 平衡二叉搜索树 (Balanced Binary Search Tree)

**图示**：

```markdown
     4
    / \
   2   6
  / \ / \
 1  3 5  7
```

**注意事项**：

- 同时满足平衡二叉树和二叉搜索树的性质。
- 常见的平衡二叉搜索树有AVL树和红黑树。

------

### 7. AVL树 (AVL Tree)

**图示**：

```markdown
     3
    / \
   2   4
  /     \
 1       5
```

**注意事项**：

- 任意节点的左右子树高度差不超过1。
- 插入和删除操作后可能需要进行旋转操作来保持平衡。

------

### 8. 红黑树 (Red-Black Tree)

**图示**：

```markdown
     4(B)
    /   \
   2(R)  6(R)
  / \   / \
 1(B) 3(B) 5(B) 7(B)
```

**注意事项**：

- 每个节点要么是红色，要么是黑色。
- 根节点是黑色。
- 红色节点不能有红色子节点（即红色节点的两个子节点必须是黑色）。
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
- 插入和删除操作后可能需要进行旋转和重新着色操作来保持红黑树性质。

------

### 9. 伸展树 (Splay Tree)

**图示**：

```markdown
     4
    / \
   2   5
  / \
 1   3
```

**注意事项**：

- 最近访问的节点会被旋转到根部。
- 伸展操作通过旋转将节点移动到根部，以加速后续访问。

------

### 10. Treap

**图示**：

```markdown
     5
    / \
   2   6
  / \
 1   3
```

**注意事项**：

- 同时满足二叉搜索树和堆的性质。
- 每个节点有一个优先级，优先级满足堆的性质（即父节点的优先级大于子节点的优先级）。

------

### 11. 堆 (Heap)

**图示**：

```markdown
    1
   / \
  2   3
 / \ / \
4  5 6  7
```

**注意事项**：

- 堆分为最大堆和最小堆。
- 最大堆：每个节点的值都大于或等于其子节点的值。
- 最小堆：每个节点的值都小于或等于其子节点的值。

------

### 12. 二叉堆 (Binary Heap)

**图示**：

```markdown
    1
   / \
  3   2
 / \ / \
7  6 5  4
```

**注意事项**：

- 一种堆结构，常用于实现优先队列。
- 满足完全二叉树的性质，节点按堆的性质排列。

------

### 13. 霍夫曼树 (Huffman Tree)

**图示**：

```markdown
      *
     / \
    *   E
   / \
  A   *
     / \
    B   C
```

**注意事项**：

- 用于霍夫曼编码，生成最优二叉树以实现数据压缩。
- 权重较小的节点离根较远。

------

### 14. 线段树 (Segment Tree)

**图示**：

```markdown
      18
    /   \
   7    11
  / \   / \
 3   4 5   6
```

**注意事项**：

- 用于解决区间查询问题。
- 可以高效地进行区间更新和区间查询。

------

### 15. 范例树 (Fenwick Tree/Binary Indexed Tree)

**图示**：

```markdown
       15
      / \
     7   8
    / \
   3   4
```

**注意事项**：

- 用于快速更新和查询前缀和。
- 通过维护部分和来实现高效查询和更新。

这些图示和注意事项涵盖了各类二叉树的基本概念和用途。具体应用中，选择合适的二叉树结构对于实现高效算法和数据处理非常重要。

## 96.不同的二叉搜索树

题目链接[力扣-96.不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)

~~~python
class Solution:
    def numTrees(self, n: int) -> int:
        """
        :param n:
        :return:
        思路：动态规划
        1、初始化状态：dp[n]表示n个节点能组成多少个搜素二叉树
        1.1、子问题1：当有n个节点时，从1 -> n 的每个节点分别当做根节点，
             肯定是不同的二叉树（节点值为1 -> n，所以根节点值肯定不同）
        1.2、子问题2：令F(i)表示以数字 i 为根节点的不同二叉搜索树的个数，则有G(n) = F(1) + F(2) + ... + F(n)
        1.3、子问题3：令 i 表示根节点，则F(i) = G(i - 1) * G(n - i)。G(i - 1)表示根节点为i的
             左子树有i - 1个节点，右子树有n - i个节点，那么左子树的种类肯定有G(i - 1)个，而树的个数
             与节点值无关，只与节点个数有关，所以右子树种类有G(n - i)个。那么两边子树组合种类为G(n - i) * G(i - 1)
        1.4、子问题4：结合1.3,1.2有G(n) = G(0)*G(n - 1) + G(1)*G(n - 2) + ... + G(n - 1)*G(0)
        2、状态转移方程：dp[i] = dp[0]*dp[i - 1] + dp[1]*dp[i - 2] + ... + dp[i - 1]*dp[0]
        2.1、据上式可以看出:
            1、当i - 1为偶数
            dp[i] = 2(dp[0]*dp[i - 1] + dp[1]*dp[i - 2] + ... + dp[(i - 1) // 2][(i - 1) // 2])
            2、当i - 1为奇数
            dp[i] = 2(dp[0]*dp[i - 1] + dp[1]*dp[i - 2] + ... + dp[(i - 2) // 2][(i - 2) // 2]) + dp[(i - 2) // 2 + 1][(i - 2) // 2 + 1]
        3、边界条件：当i为0表示无节点，1表示只有一个节点，那么这两种情况自然只有一种组合
            dp[0] = 1, dp[1] = 1
        4、运行顺序：0 -> n
        """
        dp = [0] * (n + 1)  # 不能预设为1，如果为1，每个dp[i]自加的时候都会多加1
        dp[0] = dp[1] = 1
        for i in range(2, n + 1):
            k = i // 2
            for j in range(1, k + 1):
                dp[i] += 2 * dp[j - 1] * dp[i - j]
            if i % 2 == 1:
                dp[i] += dp[i - k - 1] * dp[i - k - 1]

        return dp[-1]
~~~

## 98.验证二叉搜索树

题目链接[力扣-96.验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/solutions/)

中序遍历

~~~python
# 思路1：设置变量val，记录上一个节点的值，比较当前节点root.val和val的值，如果出现root.val <= val 那么返回False
# 思路2：设置前驱节点pre，用pre记录前一个节点的地址，比较前一个节点pre.val和当前节点root.val的值，如果出现root.val <= pre.val，那么返回False
# 思路1
class Solution:
    val = float('-inf')

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        left = self.isValidBST(root.left)
        if root.val > self.val:
            self.val = root.val
        else:
            return False
        right = self.isValidBST(root.right)
        return left and right
# 思路2   
class Solution:
    pre = None

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        left = self.isValidBST(root.left)
        if self.pre:
            if self.pre.val >= root.val:
                return False
        self.pre = root
        right = self.isValidBST(root.right)
        return left and right
~~~

## 101.对称二叉树

题目链接[力扣-101.对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)

~~~python
# 思路1：递归
# 	1、两棵相同的树一起遍历，第一棵树向左第二棵树向右
#	2、在前序的位置比较树的节点值情况
#	3、当两棵树节点值相等时，不能直接返回True，应该继续向下递归，比较子节点的值情况
# 思路2：层序遍历，层序判断是否为对称数组
~~~

~~~python
# 思路1：
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        return self.traverse(root, root)

    def traverse(self, root1, root2):
        if not root1 and not root2:
            return True
        elif not root1 or not root2:
            return False
        else:
            if root1.val != root2.val:
                return False
            left = self.traverse(root1.left, root2.right)
            right = self.traverse(root1.right, root2.left)
            return True if left and right else False

# 思路2
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        stack = [root]
        while stack:
            level = []
            temp_stack = []
            size = len(stack)
            for i in range(size):
                if stack[i]:
                    level.append(stack[i].val)
                    if stack[i].left:
                        temp_stack.append(stack[i].left)
                    else:
                        temp_stack.append(None)
                    if stack[i].right:
                        temp_stack.append(stack[i].right)
                    else:
                        temp_stack.append(None)
                else:
                    level.append(None)
            left, right = 0, size - 1
            while left <= right:
                if level[left] != level[right]:
                    return False
                left += 1
                right -= 1
            stack = temp_stack
        return True
# 思路2的写法2：画个二叉树的图就好理解。
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

            # Initialize a deque with the left and right children of the root
        queue = deque([(root.left, root.right)])

        while queue:
            left, right = queue.popleft()

            # If both are None, continue to the next pair
            if not left and not right:
                continue

            # If one is None and the other is not, it's not symmetric
            if not left or not right:
                return False

            # If the values are different, it's not symmetric
            if left.val != right.val:
                return False

            # Enqueue the children in the order that they should be compared
            queue.append((left.left, right.right))
            queue.append((left.right, right.left))

        return True
~~~

## 102.二叉树的遍历

### 二叉树的层序遍历

题目链接[力扣-102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

~~~python
# 思路：借助栈
# 1、节点入栈stack
# 2、遍历栈stack，建立一个临时栈temp，判断栈中的左子节点和右子节点分别存不存在，存在则入栈temp。
# 3、收集节点值，将临时栈赋值给stack
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        res = []
        stack = [root]
        while stack:
            sub_res = []
            temp_stack = []
            size = len(stack)
            for i in range(size):
                node = stack[i]
                if node.left:
                    temp_stack.append(node.left)
                if node.right:
                    temp_stack.append(node.right)
                sub_res.append(node.val)
            res.append(sub_res)
            stack = temp_stack
        return res
~~~

### 前中后遍历，非递归写法

#### 借助栈

> 1. 使用辅助栈，模拟递归调用的过程。
> 2. 特别注意的是终止循环条件，栈和节点有一个不为空就可以。因为在遍历到前驱节点的后一个节点时，栈肯定为空，但是树还有一半是没有遍历完的

> **前序遍历**

~~~python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []
        while stack or root:
            if root:
                res.append(root.val)
                stack.append(root)
                root = root.left
            else:
                temp = stack.pop()
                root = temp.right
        return res
~~~

> **中序遍历**

~~~python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                temp = stack.pop()
                res.append(temp.val)
                root = temp.right
        return res
~~~

> **后续遍历**
>
> 1. 特殊之处在于需要确认右子节点被访问过后，再访问根节点。
> 2. 设定一个变量跟踪访问过的节点（从stack里pop出来的，表示已经访问过了）

~~~python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []
        last_visit = None
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                if stack[-1].right and stack[-1].right != last_visit:
                    root = stack[-1].right
                else:
                    last_visit = stack.pop()
                    res.append(last_visit.val)
        return res
~~~

#### morris算法

> 1. morris算法其实是将二叉树变为单链表的一个过程，按照前中后遍历的顺序，将左子树整体移动到父节点的左边或者右边。
> 2. 对每个节点重复这个过程。
> 3. 下图就是一个中序遍历时，右子树整体挪到前驱节点 `5` 的一个过程

<img src="/assets/images/Snipaste_2024-08-09_16-57-08.png" alt="morris中序" style="zoom:80%;" />

> **前序遍历**
>
> 1. 顺序 root -> left -> right
> 2. 那么先取根节点，然后将左子树移动到右子树，再将右子树赋值给前驱节点`5`

~~~python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        while root:
            res.append(root.val)
            pre = root
            if root.left:
                temp = root.right
                root.right = root.left
                while pre.right:
                    pre = pre.right
                pre.right = temp
            root.left = None
            root = root.right
        return res
~~~

> **中序遍历**
>
> 1. 顺序 root -> left -> right
> 2. 将包含根节点在内的右边节点移动到前驱节点 `5`
> 3. 接着节点持续左移，直到遇到无左子节点，然后开始收集结果，并开始遍历右节点。其实当无左子节点时，左子树已经形成单链表了。
> 4. 接着开始收集左子树的单链表
> 5. 直到遇到右子树中具有左孩子的节点，又开始1、2、3、4，最终完成遍历

~~~python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        while root:
            pre = root
            if pre.left:
                pre = pre.left
                temp = pre
                while pre.right:
                    pre = pre.right
                pre.right = root
                root.left = None
                root = temp
            else:
                res.append(root.val)
                root = root.right
        return res
~~~

> **后续遍历**：太复杂了，仅作参考。一般Morris算法只做前中序遍历
>
> [Morris后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/solutions/431066/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/)

## 105.从前序遍历和中序遍历构造二叉树

> 题目链接[力扣-105.从前序和中序序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

~~~python
# 思路1：递归 + 分治
# 	1、对于前序遍历而言，当前节点A后一个值一定是当前节点A的左子节点值或者右子节点值。因为前序遍历顺序为 root -> left -> right
#	2、对于中序遍历而言，以前序遍历中节点值A做切割点，那么切割点A左边的序列形成A节点的左子树，右边的序列形成右子树
#	3、通过以上两点，可以用中序遍历做辅助，判断节点A是否有左右节点即可。如果以节点A做切割的中序遍历左边序列为空，那么A.left = None，如果不为空则将前序遍历A节点值的后一个值赋值给A.left
class Solution:
    index = 0

    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not inorder:
            return None
        res = TreeNode(preorder[self.index])
        root_val = preorder[self.index]
        clip = inorder.index(root_val)
        self.index += 1
        res.left = self.buildTree(preorder, inorder[0:clip])
        res.right = self.buildTree(preorder, inorder[clip + 1:])
        return res
# 思路二：做辅助栈
# 1、遍历preorder序列，将prorder[0]入栈
# 2、栈中入栈未添加右子节点的父节点，设置变量index记录中序遍历序列里节点的位置
# 3、判断栈顶节点值是否和中序遍历序列inorder[index]相等
# 	3.1 如果不相等，证明该前序遍历的节点值preorder[stack[-1]]左子节点为inorder[index]
#	3.2 如果相等，那证明stack[-1]对应的节点已经无左子节点了，因为如果有左子节点，其子节点组成的序列一定在inorder[stack[-1]]节点的左边。
# 	3.3 当相等后，开始出栈stack.pop()，直到preorder[stack[-1]] != inorder[index]。那么表示找到了最后一个pop出的节点的右子节点node
#	3.4 对于3.3，因为如果遍历到的node为出栈的 preorder[stack[-1]] == inorder[index] 除最后一个出栈节点之外的其他节点的右子节点，那么表示最后一个出栈的右子节点还有左孙子节点（左子树）没有遍历构建完成。但是在中序遍历中，从preorder[stack[-1]] == inorder[index]开始pop，直到最后一个pop出的节点，都能看出来已经没有左子孙节点能够构建了。所以node一定是最后一个pop出节点的右子节点。
# 4、将node入栈，继续构建右边子树，从node开始重复1、2、3步骤
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        root = TreeNode(preorder[0])
        stack = [root]
        inorder_index = 0
        for i in range(1, len(preorder)):
            node = TreeNode(preorder[i])
            if stack[-1].val != inorder[inorder_index]:
                stack[-1].left = node
            else:
                temp = None
                while stack and stack[-1].val == inorder[inorder_index]:
                    temp = stack.pop()
                    inorder_index += 1
                temp.right = node
            stack.append(node)
        return root
~~~

## 106.从中序遍历和后续遍历构造二叉树

题目链接：[力扣-106.从中序遍历和后续遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

~~~python
# 思路1：递归
# 	1、跟105不同点在于，后续遍历根节点放在了序列末端，那么我们需要倒序遍历后序序列。
#	2、寻找倒序遍历节点在中序序列中的index，以此做切割中序序列。
#	3、因为是后续遍历，所以节点左边的序列值为先为右子节点，再为左子节点。那么先构造右子树，再构造左子树。
#	4、当2中切割的左右序列为空，则返回None
#	5、重复1、2、3、4
class Solution:
    index = 0
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not inorder:
            return None
        root = TreeNode(postorder[-1])
        clip = inorder.index(postorder[-1])
        postorder.pop()
        root.right = self.buildTree(inorder[clip + 1:], postorder)
        root.left = self.buildTree(inorder[0:clip], postorder)
        return root
# 思路2：迭代
#	1、沿用104的思路，中序遍历为 left -> root -> right，后序遍历为 left -> right -> root。
#	2、所以当后序的值从末端开始遍历入栈时，栈中顺序为root -> right，那么中序也倒着遍历就为right -> root，这跟stack出栈顺序一致。所以inorder_index的初始值为size - 1
#	3、根据1、2，当stack[-1].val != inorder[inorder_index]，那么证明栈顶元素还有右子节点，所以stack[-1].right = node
#	4、当stack[-1].val == inorder[inorder_index]，证明右子节点构建完毕，开始pop
#	5、入栈node，重复1、2、3、4、5
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        root = TreeNode(postorder[-1])
        stack = [root]
        size = len(postorder)
        inorder_index = size - 1
        for i in range(size - 2, -1, -1):
            node = TreeNode(postorder[i])
            if stack[-1].val != inorder[inorder_index]:
                stack[-1].right = node
            else:
                temp = None
                while stack and stack[-1].val == inorder[inorder_index]:
                    temp = stack.pop()
                    inorder_index -= 1
                temp.left = node
            stack.append(node)
        return root
~~~

## 114.二叉树展开为链表

题目链接：[力扣-114.二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/)

### 思路1：使用递归

> 1. 创建一个全局变量res，再创建一个前驱节点pre。然后将res赋值给pre。[^1]
> 2. 使用前序遍历，在前序遍历中，将root地址赋值给pre，并让pre指针指向自己的右子节点。[^2]
> 3. 定义两个变量left和right，分别保存root节点的左右子节点，防止被下一层递归篡改。[^3]

#### 错误示范

> 在每一次使用完root时，未断开pre和root的链接，在下一层迭代时，root左右子节点地址被修改，造成错误结果

~~~python
class Solution:
    res = TreeNode()
    pre = res

    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        self.tranverse(root)
        root = self.res.right

    def tranverse(self, root):
        if not root:
            return
        self.pre.right = root  # 这里在下一层，相当把上一层的root的左子节点或右子节点赋值给root.right，即root.right = root.left
        self.pre = self.pre.right  # 这里相当于让self.pre = root，而且没有断开self.pre的左子节点
        self.tranverse(root.left)  # 下面两步都是直接在root上遍历左右子节点，但是在下一层时，root的左右子节点已经被修改了
        self.tranverse(root.right)
~~~

#### 正确示范

> 1. 在使用完root后，断开root和下层递归的连接。保证树递归的正确性
> 2. 断开pre和left的链接，保证不修改root，也保证了pre的单链表特性

~~~python
class Solution:
    res = TreeNode()
    pre = res
    aa = None

    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        self.tranverse(root)
        root = self.res.right

    def tranverse(self, root):
        if not root:
            return
        self.pre.right = root
        self.pre.left = None
        # self.aa = root
        self.pre = self.pre.right
        left = root.left
        right = root.right
        self.tranverse(left)
        self.tranverse(right)
~~~

### 思路2：利用树的前序遍历，非递归(morris算法)

> 1. 前序遍历的本质是根左右，那么可以让每个节点只有右节点，无左子节点。
> 2. 使用临时变量temp存储右子节点，然后让遍历到的节点pre的左子节点覆盖右子节点。即pre.right = pre.left
> 3. 让前驱节点[^ 4]node.right = temp
> 4. 断开pre节点的左子树，并让pre指向自己的右子节点
> 5. 重复1、2、3、4直到遍历到最后一个节点pre == None

~~~python
class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        pre = root
        while pre:
            forward = pre
            if pre.left:
                temp = pre.right
                pre.right = pre.left
                while forward.right:
                    forward = forward.right
                forward.right = temp
            pre.left = None
            pre = pre.right
~~~

### 思路3：反向思考，递归

> 1. 前序遍历，使用一个临时节点记录遍历过的node，在递归返回上一层时，将root.right = node。但这样做，会使得root的右子根节点断开，这样右子树就没法递归遍历。
> 2. 逆向思维，前序遍历为根左右，那么可以交换顺序倒着遍历，右左根，这样先遍历右左节点，最后考虑根节点。这样在离开左右节点时，root左右节点已经不影响遍历了，而且倒着建立单链表，最后返回的root就是正确的链表头节点。
> 3. 离开左右节点时，断开左子节点，让离开的root变为单链表

~~~python
class Solution:
    pre = None

    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        self.flatten(root.right)
        self.flatten(root.left)
        root.right = self.pre
        root.left = None
        self.pre = root
~~~

## 买卖股票的最佳时机

**注意**：`dp[1][i]`表示不持股时的最大利润，不够买股票也是不持股的一种状态，因此对于`dp[1][0]`来讲，其初始化值一定是 `0`

### 121.买卖股票的最佳时机 $\mathrm{I}$

题目链接：[力扣-121。买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/) 

> 思路：维护一个price最小值和一个卖出的最大值profit

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price = prices[0]
        max_profit = 0
        for price in prices:
            min_price = min(min_price, price)
            max_profit = max(max_profit, price - min_price)
        return max_profit
~~~

### 122.买卖股票的最佳时机 $\mathrm{II}$

题目链接：[力扣-122.买卖股票的最佳时机 $\mathrm{II}$](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

####  错误思路

> 思路：动态规划
>
> 1. 初始化状态：dp[i]表示遍历到i时，最大收益
>
>    + 子问题1：每天其实就三个状态，买入、卖出、啥也不干
>
>    * 子问题2：用dp[0]、dp[1]、dp[2]分别表示三个状态
>
> 2. 状态转移方程：
>
>    * `dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])`
>    * `dp[1][i] = dp[0][i - 1] + prices[i]`
>    * `dp[2][i] = max(dp[0][i - 1], dp[1][i - 1], dp[2][i - 1])`
>
> 3. 值初始化：
>
>    * `dp[0][0] = -prices[0]`
>    * `dp[0][1] = 0`
>    * `dp[0][2] = 0`
>
> 4. 运行顺序：从左到右
>
> 总结：
>
> 1. 状态`dp[2][i]`定义太模糊，该状态无法确认是持有股票还是未持有股票，因此未无效状态
> 2. 在买入和卖出更新状态时，发现用不到状态`dp[2][i]`，但是什么动作都不做这个状态肯定是存在的
> 3. 因此思路是错误的

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(3)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        dp[2][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])
            dp[1][i] = dp[0][i - 1] + prices[i]
            dp[2][i] = max(dp[0][i - 1], dp[1][i - 1], dp[2][i - 1])
        return max(dp[0][-1], dp[1][-1], dp[2][-1])
~~~

#### 正确思路

> 1. 初始化状态：
>    - 修正`dp[0][i]`状态为持股时所持最大金额，`dp[1][i]`状态为不持股所持最大金额
> 2. 状态转移方程：
>    - `dp[0][i] = max(dp[0][i - 1], dp[1][i] - prices[i])`   注意`dp[0][i - 1]`表示今天啥也不干，就保持昨天状态。
>    - `dp[1][i] = max(dp[1][i - 1], dp[0][i] + prices[i])`   注意`dp[1][i - 1]`表示今天啥也不干，就保持昨天状态。
> 3. 状态初始化：
>    + `dp[0][0] = -prices[0]`
>    + `dp[1][0]` = 0
> 4. 运行顺序：
>    + 从左到右
> 5. 从`2`可以看出，正确思路定义的状态是包含了啥也不干的状态的

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])
            dp[1][i] = max(dp[0][i - 1] + prices[i], dp[1][i - 1])
        return dp[1][-1]
~~~

### 123.买卖股票的最佳时机 $\mathrm{III}$

题目链接：[力扣-123.买卖股票的最佳时机$\mathrm{III}$](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/)

> 1. 初始化状态：
>    + `dp[0][i]`表示第一次持有股票时，存款最大金额
>    + `dp[1][i]`表示第一次不持股票时，存款最大金额
>    + `dp[2][i]`表示第二次持有股票时，存款最大金额
>    + `dp[3][i]`表示第二次不持股票时，存款最大金额
> 2. 动态转移方程：
>    + `dp[0][i] = max(dp[0][i - 1], -prices[i])`
>    + `dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prcies[i])`
>    + `dp[2][i] = max(dp[2][i - 1], dp[1][i - 1] - prices[i])`
>    + `dp[3][i] = max(dp[3][i - 1], dp[2][i - 1] + prices[i])`
> 3. 状态初始化：**有个隐含条件，当天买入可以当天卖出。**
>    + `dp[0][0] = -prices[0]`
>    + `dp[1][0] = 0`
>    + `dp[2][0] = -prices[0]`
>    + `dp[3][0] = 0`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(4)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        dp[2][0] = -prices[0]
        dp[3][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], -prices[i])
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])
            dp[2][i] = max(dp[2][i - 1], dp[1][i - 1] - prices[i])
            dp[3][i] = max(dp[3][i - 1], dp[2][i - 1] + prices[i])
        return dp[3][-1]
~~~

### 188.买卖股票的最佳时机 $\mathrm{IV}$

题目链接：[力扣-188.买卖股票的最佳时机 $\mathrm{IV}$](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

> 1. 初始化状态：
>    + 题目中要求最多交易次数为k，其实状态分析和123题分析是一样的。
>    + 按照`123`题分析，那么总共有 $2*k$ 个状态，记为`n`个状态。
>    + 那么可以写个循环，直接给n个状态赋值
>    + 当`j为偶数 j -> 0:n`，则表示持有股票的最大利润
>    + 当`j为奇数 j -> 0:n`，则表示不持有股票的最大利润
> 2. 状态转移方程：
>    + 当 `j == 0`时，`dp[0][i] = max(dp[0][i - 1], -prices[i])`
>    + 当`j % 2 == 1`时，`dp[j][i] = max(dp[j][i - 1], dp[j - 1][i - 1] + prices[i])` 
>    + 当`j % 2 == 0`时，`dp[j][i] = max(dp[j][i - 1], dp[j - 1][i - 1] - prices[i])` 
> 3. 初始化数组：
>    + 当`j % 2 == 0`时，`dp[j][0] = -prices[i]`
>    + 当`j % 2 == 1`时,`dp[j][0] = 0`
> 4. 执行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        size = len(prices)
        status_size = 2 * k
        dp = [[0] * size for _ in range(status_size)]
        for i in range(status_size):
            if i % 2 == 0:
                dp[i][0] = -prices[0]
            else:
                dp[i][0] = 0
        for i in range(1, size):
            k = 0
            while k < status_size:
                if k == 0:
                    dp[k][i] = max(dp[k][i - 1], - prices[i])
                elif k % 2 == 0:
                    dp[k][i] = max(dp[k][i - 1], dp[k - 1][i - 1] - prices[i])
                else:
                    dp[k][i] = max(dp[k][i - 1], dp[k - 1][i - 1] + prices[i])
                k += 1
        return dp[status_size - 1][-1]
~~~

### 309.买卖股票的最佳时机含冷冻期

题目链接：[力扣-309.买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

> 1. 初始化状态：
>    + 跟`123`题状态一致，只是多了一个冷冻期
>    + 当考虑冷冻期时，持有股票的状态只能从前天的状态转移过来
> 2. 状态转移方程：
>    + `dp[0][i] = max(dp[0][i - 1], dp[1][i - 2] - prices[i])`
>    + `dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])`
>    + 注意`dp[0][i]`的状态方程较`123`题有所变化 
> 3. 数组初始化：
>    + `dp[0][0] = -prices[0]`
>    + `dp[1][0] = 0`
>    + `dp[0][1] = max(dp[0][0], -prices[1])`
>    + `dp[1][1] = max(dp[1][0], dp[0][0] + prices[1])`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        if size == 1:
            return 0
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        dp[0][1] = max(dp[0][0], -prices[1])
        dp[1][1] = max(dp[1][0], dp[0][0] + prices[1])
        for i in range(2, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 2] - prices[i])
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])
        return dp[1][-1]
~~~

### 714. 买卖股票的最佳时机含手续费

题目链接：[力扣-714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)

> 1. 初始化状态：
>    + 跟`123`定义的状态一致，只需要在购买时多减去所交的税即可
>    + 注意数组初始化时，定义的是不持股时的**最大**利润
>    + 当最后输出结果小于`0`时，可以选择不买入也不卖出，那么利润为`0`
> 2. 状态转移方程：
>    + `dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i] - fee)`
>    + `dp[1][i] = max(dp[1][i - 1]`, $\textcolor{red}{dp[0][i - 1] + prices[i]}$`)`
> 3. 数组初始化：
>    + `dp[0][0] = -prices[0] - fee`
>    + ~~`dp[1][0] = -fee`~~这里的初始化是错误的，`dp[1][i]`表示不持股时的最大利润，不够买股票也是不持股的一种状态，因此对于`dp[1][0]`来讲，其初始化值一定是 `0`
>    + `dp[1][0] = 0`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0] - fee
        dp[1][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i] - fee)
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i])
        return dp[1][-1] if dp[1][-1] > 0 else 0
~~~

> 1. 考虑另外一种交税方式，在卖出时交税。这样在初始化数组时，就不用考虑`dp[1][0]`的特殊情况了
>
> 2. 状态转移方程：注意$\textcolor{red}{**红色部分的变化**}$
>
>    + `dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])`
>    + `dp[1][i] = max(dp[1][i - 1]`, $\textcolor{red}{dp[0][i - 1] + prices[i] - fee}$`)`
>
> 3. 状态初始化：
>
>    + `dp[0][0] = -prices[0]`
>
>    + `dp[1][0] = 0`

~~~python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        size = len(prices)
        dp = [[0] * size for _ in range(2)]
        dp[0][0] = -prices[0]
        dp[1][0] = 0
        for i in range(1, size):
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i])
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i] - fee)
        return dp[1][-1] if dp[1][-1] > 0 else 0
~~~

## 124. 二叉树中的最大路径和

题目链接：[力扣-124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum)

>1. 思路：递归
>   + 题目明确要求是二叉树的最大路径和，且不能重复遍历。那么可以考虑在离开左右子树，回到父节点时，收集路径最大和
>   + 对于当前节点来讲，包含当前节点的最大路径和，即为左子树最大路径和`leftMax`，加上右子树最大路径和`rightMax`，加上当前节点值`root.val`。即`rootMax = leftMax + root.val + rightMax`
>   + 当`rootMax`小于`0`时，则应该舍弃，因为对于其父节点来讲，是负增益。因此将其置`0`，再返回给父节点，这样相当于其父节点断开这一子树
>   + 因为返回给父节点的值都是包含了当前节点的，因此不存在不连续的问题。
>2. 递归三步：
>   + 确定递归终止条件：
>     + 当`root == None`时，终止递归
>   + 确定参数和返回值：
>     + 参数：① 需要一个全局变量`self.res`收集当前节点的最大路径和`rootMax`。 ② 需要传入`root`节点，以便于向下左递归
>     + 返回值：每次返回包含当前节点值`root.val`的左右子树中，较大的路径最大和`max(leftMax, rightMax) + root.val`，这样能保证传给父节点的路径和是连续的节点值的和。
>   + 单层递归逻辑：① 使用`self.res`与当前节点的最大路径和左比较，更新`self.res`为两者之间的最大值。② 比较`leftMax`和`rightMax`，取二者中较大值与当前`root.val`的和返回给父节点。
>   + 如果`max(leftMax, rightMax) + root.val`小于零，则向父节点返回`0`

~~~python
class Solution:
    res = -1001

    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        self.tranverse(root)
        return self.res

    def tranverse(self, root):
        if not root:
            return 0
        left = self.tranverse(root.left)
        right = self.tranverse(root.right)
        total = left + right + root.val
        self.res = max(total, self.res)
        bigger = max(right, left) + root.val
        return bigger if bigger > 0 else 0
~~~

## 128.最长连续序列

题目链接：[力扣-128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence)

### 思路1：使用并查集

> 1. 并查集知识点链接：[并查集](https://suwanzi.cn/categories/数据结构/#并查集)
>
> 2. 使用字典来记录遍历过的`num`，若再次遇到直接跳过
>
> 3. 有两种写法：
>
>    + 使用字典存储父节点信息，集合计数也是用字典存储。
>
>      ~~~python
>      import collections
>      class UF:
>          def __init__(self, nums):
>              self.dic = {num: num for num in nums}
>              self.count = {num: 1 for num in nums}
>      
>          def find(self, x):
>              if x != self.dic[x]:
>                  self.dic[x] = self.find(self.dic[x])
>              return self.dic[x]
>      
>          def merge(self, p, q):
>              if self.dic[p] == self.dic[q]:
>                  return
>              root_p = self.find(p)
>              root_q = self.find(q)
>              self.dic[root_p] = root_q
>              self.count[root_q] += self.count[root_p]
>              
>      class Solution:
>          def longestConsecutive(self, nums: List[int]) -> int:
>              if not nums:
>                  return 0
>              uf = UF(nums)
>              had = collections.defaultdict(int)
>              for num in nums:
>                  if num not in had:
>                      if num + 1 in uf.dic:
>                          uf.merge(num, num + 1)
>                  had[num] = 1
>              return max(uf.count.values())
>      ~~~
>
>    + 使用数组存储数字的索引，让索引代表具体数值。
>
>      ~~~python
>      import collections
>      class UF:
>          def __init__(self, size):
>              self.dic = [i for i in range(size)]
>              self.count = [1 for _ in range(size)]
>      
>          def find(self, x):
>              if x != self.dic[x]:
>                  self.dic[x] = self.find(self.dic[x])
>              return self.dic[x]
>      
>          def merge(self, p, q):
>              if self.dic[p] == self.dic[q]:
>                  return
>              root_p = self.find(p)
>              root_q = self.find(q)
>              self.dic[root_p] = root_q
>              self.count[root_q] += self.count[root_p]
>              
>      class Solution:
>          def longestConsecutive(self, nums):
>              if not nums:
>                  return 0
>              size = len(nums)
>              uf = UF(size)
>              had = collections.defaultdict(int)
>              for i in range(size):
>                  if nums[i] not in had:
>                      if nums[i] + 1 in had:
>                          uf.merge(i, had[nums[i] + 1])
>                      if nums[i] - 1 in had:
>                          uf.merge(i, had[nums[i] - 1])
>                      had[nums[i]] = i
>              return max(uf.count)
>      ~~~
>
>    + 注意两种写法判断是否`union`的条件是不一样的。
>
>      + 对第一种写法来讲，因为是用的字典来模拟的树结构。其实已经将所有的num值存在了`self.dic`中了，因此只需要
>
>        `if num + 1 in uf.dic`这一个判断语句，就可以判断`num`是否有相邻节点`num + 1`。在遍历完`nums`过后，就可以把所有相邻的节点都整合到一个集合里。
>
>      + 对于第二种写法，是用的`nums`的下标`i`来表示的具体数值，因此在遍历到`i`时，我们是不知道`nums[i]`是有小于他，或者大于他的邻接节点的。因此需要做两次判断，只做`nums[i] + 1`或者`nums[i] - 1`的判断，会造成节点错漏。假设有节点`1,2,3`，如果按照顺序加入上方的`had`字典，那么`1`先加入`had`，这时候`nums[i] + 1 = 2` 是没在`had`中的，同理`2,3`的`num[i] + 1 = 3, 4`也都没加入`had`。因此一次`merge`都不会发生。

### 思路2：使用字典

> 1. 使用字典`dic`记录包含`key`在内的序列长度，变量`res`记录最大序列长度
> 2. 以`key`为出发点，判断`key - 1`和`key + 1`是否在`dic`中。若在，则取其值`left = dic[key - 1]`及`right = dic[key + 1]`
> 3. 则包含`key`在内的最大序列长度`res = max(res, left + right + 1)`
> 4. 更新包含`key`在内序列的边界，即`dic[key - left] = left + right + 1`、`dic[key + right] = left + right + 1`

~~~python
class Solution:
    def longestConsecutive(self, nums):
        if not nums:
            return 0
        dic = {}
        res = 0
        for num in nums:
            if num not in dic:
                dic[num] = 1
                left = dic.get(num - 1, 0)
                right = dic.get(num + 1, 0)
                length = left + right + 1
                res = max(res, length)
                dic[num - left] = length
                dic[num + right] = length
        return res
~~~

## 139.单词拆分：

题目链接：[力扣-139.单词拆分](https://leetcode.cn/problems/word-break/description/)

### 思路1：dfs

> 1. 使用字典`dic`记录`wordDict`里面的所有单词，记录一个起始节点`index`
> 2. 确定终止条件
>    + 如果`index == size`，那么证明所有单词已经匹配完毕，直接`return True`
> 3. 参数和返回值：
>    + `dfs`的参数需要什么就加什么，不固定
>    + 返回值为`boolean`类型，即是否能完全匹配
> 4. 单层递归逻辑：
>    + 如果`s[index:i + 1]`在`dic`中，那么更新`index`，并进入下一层递归。

~~~python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dic = {word: len(word) for word in wordDict}
        size = len(s)
        return self.dfs(s, dic, 0, size)

    def dfs(self, s, dic, index, size):
        if index == size:
            return True
        for i in range(size):
            word = s[index:i + 1]
            if word in dic and self.dfs(s, dic, i + 1, size):
                return True
        return False
~~~

> 注意：上面的代码只能通过部分样例，如果字符串中重复的字母过多，且`wordDict`中包含这些重复的字符，那么会造成重复递归判断。造成超时
>
> 例如：`s = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`，`wordDict = [a, aa, aaa]`。可以预见的是，每个`a`、`aa`、`aaa`都会被重复判断好多次
>
> ![递归的树形图](/assets/images/Snipaste_2024-08-14_19-57-47.png)
>
> 优化：
>
> + 使用带记忆的递归，即使用一个状态字典，记录判断过的子字符串。
>
>   ![带记忆的递归](/assets/images/Snipaste_2024-08-14_19-58-49.png)
>
> + 记录`wordDict`中最长单词的长度`word_max`，一旦`s[index:i+1]`长度超过`word_max`，那么立即停止单层遍历

~~~python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dic = {word: len(word) for word in wordDict}
        word_max = max(dic.values())
        size = len(s)
        status = [None] * size
        return self.dfs(s, dic, 0, size, status, word_max)

    def dfs(self, s, dic, index, size, status, word_max):
        if index == size:
            return True
        if status[index] != None:  # 如果status[index]有值，证明已经验证过以s[index]开头的字符串组成的单词不符合题意
            return status[index]
        for i in range(index, size):
            word = s[index:i + 1]
            if i - index + 1 > word_max:
                break
            if word in dic and self.dfs(s, dic, i + 1, size, status, word_max):
                # status[index] = True 这一步是完全不需要的，因为只有递归到index == size才会执行到这里
                return True
        status[index] = False  # 记录从以s[index]开头的字符串组成的单词，在wordDict中不存在 
        return False
~~~

### 思路2：动态规划

> 1. 初始化状态：
>    + `dp[i]`表示前`i`个元素`s[0:i]`能否被`wordDict`表示，注意前`i`个元素下标是`0,1,2,...,i - 1`，不是到`i`
>    + 定义`dp`数组时，将其长度定为`size + 1`，不然初始化必须要找到`s[0:i] in wordDict`才能完成初始化
>    + 设有分割点`j`分割前`i`个元素，则若`dp[i]`能被表示，必有`dp[j] = True and s[j:i] in wordDict`。这里的`s[j:i]`从`j`开始，是因为把空字符串`""`也看成了前`j`个元素之一，即`s = '' + s`。因此前`j`个元素是不包含`s[j]`的
> 2. 状态转移方程：
>    + `dp[i] = dp[j] and s[j:i] in wordDict`
> 3. 初始化状态：
>    + `dp[0] = True`   当为空串时，空串肯定能被`wordDict`表示
> 4. 运行顺序：
>    + 先遍历`i`，再遍历`j`
> 5. 优化：
>    + 若有`s[j:i] in wordDict`，那么必有`i - j <= max(len(word))`，`word`为`wordDict`中的元素。因此`j`遍历起始点为`i - max(len(word)`不为`0`
>    + 当找到`dp[i] = True`时，立即`break`，后序没必要再遍历了

~~~python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        size = len(s)
        dp = [False] * (size + 1)
        dp[0] = True
        word_max = len(max(wordDict, key=len))
        for i in range(1, size + 1):
            start = 0 if i <= word_max else i - word_max
            for j in range(start, i):
                if dp[j] and s[j:i] in wordDict:
                    dp[i] = True
                    break
        return dp[-1]
~~~

## 141.环形链表

> 思路1：使用字典或者数组存下遍历过的`node`，若遍历过的`node`再次出现再字典或数组中，返回`True`
>
> 思路2：快慢指针，快指针追上慢指针，则返回`True`

~~~python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        pre = ListNode()
        pre.next = head
        slow, fast = pre, pre.next
        while slow != fast:
            if not fast or not fast.next:
                return False
            slow = slow.next
            fast = fast.next.next
        return True
~~~

> 思考：为什么快指针不每次按照`3`倍，`4`倍，甚至`n`倍的速度去跑？
>
> + 假设当`slow`入环时，和`fast`指针相距距离`k`。设环长度为`r`，`slow`走了`h`步后被追上，若要`fast`追上`slow`，则有
>   $$
>   \begin{aligned}
>                                                         
>   k + h + nr = mh \\
>   h = \frac{\left(k + nr\right)}{m - 1}
>                                                         
>   \end{aligned}
>   $$
>   
> + 可以看到上面的公式，如果`m = 2`，那么$h = k + nr$，当`fast`走的步数为$k,k + r, ... , k + nr$时，会被追到。最短走$k$步就被追到。
> + 如果$m > 2$，则要看 $k + nr$ 和 $m - 1$ 成整数倍关系才能追上。特别注意的是，如果 $m$ 为奇数，那么 $k = mv - v$ 肯定为偶数，$v$ 为慢指针走的距离，$m - 1$ 也为偶数，所以 $h$ 一定有整数值使得公式成立。
>   + 另一个角度去理解：如果 $m >= 3$，那么快指针很容易跨过慢指针，也就是追慢指针时，很容易从慢指针头上跳过去。

## 142.环形链表 $\mathrm{II}$

题目链接：[力扣-142.环形链表](https://leetcode.cn/problems/linked-list-cycle/description/)

> 假设相遇时圈外走的长度为`d1`，圈内走的长度为`d2`，圈的周长为`r`，那么有:
>
>
> $$
> \begin{aligned}
> slow = d1 + d2 + c_1r \\
> fast = d1 + d2 + c_2r \\
> \text{又有} \\
> fast = 2 * slow \\
> \text{那么} \\
> d1 + d2 + c_2r = 2(d1 + d2 + c_1r) \\
> \text{化简}\\ 
> d1 = (c_2 - c_1)r - d2 \quad \Rightarrow \quad d1 = (c_2 - c_1 - 1)r + (r - d2) \\
> \text{而}\quad r - d2\quad\text{是相遇点回到入口剩下的距离}
> \end{aligned}
> $$
>
> + 从上面公式可以看出，如果让节点重新从头节点`head`开始出发，同时让`fast`从相遇点以`slow`的速度继续开始往下遍历，那么当`head`走到环入口处时，`fast`正好也走到入口点

~~~python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = ListNode()
        pre.next = head
        slow, fast = pre, pre.next  # 这里是为了让 slow != fast，让while进入循环
        while slow != fast:
            slow = slow.next
            if not fast or not fast.next:
                return None
            fast = fast.next.next
        fast = fast.next  # 这里是因为上面为了让while进入循环，fast多走了一步
        while fast != pre:
            fast = fast.next
            pre = pre.next
        return pre
~~~

> 对于代码中找到相遇点后，`fast`多走一步的解释：
> $$
> \begin{aligned}
> d1 + d2 + c_2r - 1 = 2(d1 + d2 + c_1r) \\
> d1 = (c_2 - c_1 - 1)r + (r - (d2 + 1))
> \end{aligned}
> $$
> 从上面公式可以看出，`d1`为`d2`再向前走一步后，圈内剩下的步数

## 146.LRU缓存

题目链接：[力扣-146.LRU缓存](https://leetcode.cn/problems/lru-cache/description/)

> 1. 题目要求`get`和`put`都只有`O(1)`，那么首先想到的`get`就是字典，`put`能`O(1)`操作的就是双链表
> 2. 那么用字典`dic`的`key`存放输入的`key`，字典的`value`存放代表`(key,value)`在双链表中的，节点的地址
> 3. 在初始化双链表时，直接加虚拟头尾节点，这样在增删移动节点时，不需要判断前后条件是否存在。
> 4. `get()`过的节点需要移到链表头部，表示最近使用过，那么需要定义一个方法`moveToFirst`
> 5. `put()`进的节点肯定在链表头部，那么需要定义一个方法`addFirst`
> 6. 在操作完一个节点，或者`lru`达到最大容量时，需要删除最久没被用过的那个节点。因此需要定义一个方法`deleteNode`
> 7. `node`一定包含`key`和`value`两个值，不然在超出`lru`容量，需要删除最久未使用的节点时，在`dic`中会不知道删除哪个对应的`key`
> 8. 在下面的代码中，被注释掉的代码是因为，按照逻辑需要将移动的节点`node`在原地址删除，然后再移动。如果先移动，就算移动到头节点，原地址的前后节点还保存着对`node`的引用，这不符合双链表的逻辑。

~~~python
class double_list:
    def __init__(self, key, val):
        self.pre = None
        self.next = None
        self.key = key
        self.val = val


class LRUCache:

    def __init__(self, capacity: int):
        self.head = double_list(key=0, val=0)
        self.last = double_list(key=0, val=0)
        self.head.next = self.last
        self.last.pre = self.head
        self.cap = capacity
        self.count = 0
        self.lru = {}

    def get(self, key: int) -> int:
        if key not in self.lru:
            return -1
        self.moveToFirst(self.lru[key])
        return self.lru[key].val

    def put(self, key: int, value: int) -> None:
        if key not in self.lru:
            node = double_list(key=key, val=value)
            self.addFirst(node)
            self.lru[key] = node
            if self.cap < self.count:
                self.lru.pop(self.last.pre.key)
                self.deleteNode(self.last.pre)
        else:
            self.lru[key].val = value
            self.moveToFirst(self.lru[key])

    def addFirst(self, node):
        after = self.head.next
        self.head.next = node
        node.pre = self.head
        node.next = after
        after.pre = node
        self.count += 1

    def moveToFirst(self, node):
        # pre = node.pre
        # next = node.next
        self.deleteNode(node)
        self.addFirst(node)
        # pre.next = next
        # next.pre = pre

    def deleteNode(self, node):
        pre = node.pre
        after = node.next
        pre.next = after
        after.pre = pre
        node.next = None
        node.pre = None
        self.count -= 1
~~~

## 148.排序链表

题目链接：[力扣-148.排序链表](https://leetcode.cn/problems/sort-list/description/)

---

> 1. 复杂度为$n\log_2n$，那么考虑归并排序
> 2. 设置快慢指针，当`fast`跑到链表末端时，`slow`正好在链表中间
> 3. 将链表截断，分治进行合并
> 4. 注意`fast`停止的条件
>    + 因为链表是单向的，`slow`没办法回退上一个节点，若想让链表正确二分，则`slow`要在二分节点的前一个节点停下来，不然链表没法在中间断开
>    + 因此为了让`slow`少跑一步，则要增加判断条件`head.next.next != None`

~~~python
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        slow, fast = head, head
        while fast and fast.next and fast.next.next:
            fast = fast.next.next
            slow = slow.next
        half = slow.next
        slow.next = None
        return self.merge(self.sortList(head), self.sortList(half))

    def merge(self, list1, list2):
        pre = ListNode()
        head = pre
        while list1 and list2:
            if list1.val < list2.val:
                head.next = ListNode(list1.val)
                list1 = list1.next
            else:
                head.next = ListNode(list2.val)
                list2 = list2.next
            head = head.next
        head.next = list1 if list1 else list2
        return pre.next
~~~

## 155.最小栈

题目链接：[力扣-155.最小栈](https://leetcode.cn/problems/min-stack/description/)

> 1. 要求常数时间返回最小值，那么在初始化时就定义一个变量`self.minValue`保存最小值
> 2. 在栈中存储入栈数值和`self.minValue`的差值`diff`，这样在`pop()`和`push()`时能够还原所有数值
>    + 为什么要存入差值，不存入入栈时的原数值。是因为在`self.minValue`被`pop()`操作后，无法判断哪个数值是最小值了
>    + 而若存入差值，只有当`diff < 0`出现时，才需要更新`self.minValue`，而且能通过`diff`还原出新的最小值

~~~python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_value = 0

    def push(self, val: int) -> None:
        if self.stack:
            diff = val - self.min_value
            self.stack.append(diff)
            self.min_value = self.min_value if diff >= 0 else val
        else:
            self.stack.append(0)
            self.min_value = val

    def pop(self) -> None:
        diff = self.stack.pop()
        self.min_value = self.min_value if diff >= 0 else self.min_value - diff

    def top(self) -> int:
        return self.min_value if self.stack[-1] <= 0 else self.min_value + self.stack[-1]

    def getMin(self) -> int:
        return self.min_value
~~~

## 160.相交链表

> + 思路1：字典
>
>   + 存入链表`A`中每个节点的地址，然后遍历另一条链表`B`，若发现`B`中的节点在字典中存在，则返回该节点
>
> + 思路2：遍历相同长度的链表
>
>   + 先求出两条链表的长度，找出两只链表之间的长度差`diff`
>   + 让长的那支链表先跑`diff`步，然后同时遍历两只链表。遇到相等的节点，就返回该节点
>
> + 思路3：数学问题
>
>   + 假设相交节点到节点末尾的长度为`c`，链表`A`到相交节点的距离为`a`，链表`B`到相交节点的距离为`b`。
>
>   + 那么想让两条链表跑相同的距离再相遇，就让两条链表都跑`a + b + c`步。即让`A`跑完接着跑`B`，`B`跑完接着跑`A`，这样两条链表会在`a + b + c`处相遇
>
>   + 特别注意的是，如果两条链表都跑了`a + b + c`后，还没有相交节点，那么就证明两条链表不相交。因此两条链表都需要一个`None`节点来停止循环。
>
>   + 下面这种写法是错误的，因为如果遇到不相交的链表，`preA`和`preB`一直会被`headA`和`headB`赋值进入死循环。所以需要`preA == preB == None`这个条件来停下来
>
>     ~~~python
>     preA = preA.next if preA.next else headB
>     preB = preB.next if preB.next else headA
>     ~~~
>
>     

~~~python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        preA, preB = headA, headB
        while preA != preB:
            preA = preA.next if preA else headB
            preB = preB.next if preB else headA
        return preA
~~~

## 169.多数元素

> 1. 思路1：字典
>    + 字典记录每个元素的`count`，超过一半直接返回该元素
> 2. 思路2：兑子游戏
>    + 即只要不相同的元素，就互相兑子，`count`减一
>    + 当`count`为`0`时，更新被兑子的元素，并将`count`置`1`

~~~python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 1
        more = nums[0]
        size = len(nums)
        for i in range(1, size):
            if nums[i] != more:
                if count > 0:
                    count -= 1
                if count == 0:
                    more = nums[i]
                    count = 1
            else:
                count += 1
        return more
~~~

## 打家劫舍

### 198.打家劫舍 $\mathrm{I}$

题目链接：[力扣-198.打家劫舍 $\mathrm{I}$](https://leetcode.cn/problems/house-robber/description/)

> 1. 初始化状态：
>    + `dp[i]`表示打劫到第 `i` 家能打劫到的最多的钱
>    + 若打劫第`i`家，则第`i - 1`家显然不能偷，那么只能由`dp[i - 2]`和`nums[i]`决定
>    + 若不打劫第`i`家，则状态由`dp[i - 1]`决定
> 2. 状态转移方程：
>    + `dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])`
> 3. 数组初始化：
>    + `dp[0] = nums[0]`
>    + `dp[1] = max(nums[0] ,nums[1])`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def rob(self, nums: List[int]) -> int:
        size = len(nums)
        if size == 1:
            return nums[0]
        dp = [0] * size
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, size):
            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])
        return dp[-1]
~~~

### 213.打家劫舍 $\mathrm{II}$

题目链接：[力扣-213.打家劫舍$\mathrm{II}$](https://leetcode.cn/problems/house-robber-ii/description/)

> 1. 和打家劫舍$\mathrm{I}$一样定义状态，只是用两个数组来分别考虑取`nums[0]`和`nums[-1]`的两种情况
> 2. 状态转移方程：
>    + `dp[0][i] = max(dp[0][i - 2] + nums[i], dp[0][i - 1])`
>    + `dp[1][i] = max(dp[1][i - 2] + nums[i], dp[1][i - 1])`
> 3. 初始化数组：
>    + `dp[0][0] = nums[0]`
>    + `dp[0][1] = max(nums[0], nums[1])`
>    + `dp[1][0] = 0`
>    + `dp[1][1] = nums[1]`
> 4. 运行顺序：
>    + 从左到右
> 5. 注意：
>    + 在返回最终结果比较最大值是，是比较的` max(dp[0][size - 2], dp[1][-1])`，而不是` max(dp[0][-1], dp[1][-1])`

~~~python
class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        size = len(nums)
        if size < 3:
            return max(nums)
        dp = [[0]*size for _ in range(2)]
        dp[0][0] = nums[0]
        dp[0][1] = max(nums[0], nums[1])
        dp[1][1] = nums[1]
        for i in range(2, size):
            dp[0][i] = max(dp[0][i - 2] + nums[i], dp[0][i - 1])
            dp[1][i] = max(dp[1][i - 2] + nums[i], dp[1][i - 1])
        return max(dp[0][size - 2], dp[1][-1])
~~~

### 337.打家劫舍 $\mathrm{III}$

#### 思路一：动态规划

>1. 初始化状态：
>
>     + 跟前两个打家劫舍类似，使用一个变量记录遍历到当前节点能打劫到的最多的钱。
>
>
>     + 那么遍历到当前节点就只有两种状态，一种是打劫当前节点，另一种是不打劫当前节点。那么自然可以想到使用一个长度为`2`的数组来记录两种状态。考虑到是二叉树，那么就使用数组`left`记录左子树返回的两种状态，同样用`right`记录右子树
>                                                                                        
>     + 如果打劫当前节点，那么就不能打劫两个子节点，即打劫当前节点的状态只能由孙子节点决定，也就是说是不打劫子节点的那个变量决定。`stolen = left[1] + right[1] + root.val`
>                                                                                        
>     + 如果不打劫当前节点，那么孙子节点打不打劫都是可以的，即`nostolen = max(left) + max(right)`
>
>
>2. 状态转移方程：
>
>     + `stolen = left[1] + right[1] + root.val`
>
>     + `nostolen = max(left) + max(right)`
>
>
>3. 初始化状态：
>     + 当`root == None`时，返回`[0, 0]`
>
>
>4. 运行顺序：
>     + 自底向上，离开双节点时更新状态，即后序遍历
>

~~~python
class Solution:
    def rob(self, root):
        return max(self.traverse(root))
    
    def traverse(self, root):
        if not root:
            return [0, 0]
        left = self.traverse(root.left)
        right = self.traverse(root.right)
        stolen = left[1] + right[1] + root.val
        nostolen = max(left) + max(right)
        return [stolen, nostolen]
~~~

#### 思路二：暴力递归遍历

> 1. 既然相邻层不能偷，那么当前节点能偷到的最多的钱有两种情况
>    + 偷当前节点，那么只能偷当前节点和孙子节点。
>    + 不偷当前节点，那么偷儿子节点
>    + 比较种情况中的最大值，则为当前节点能偷到的最大值
> 2. 在离开左右子节点时做最大值的判断，即后序遍历。
> 3. 递归三部曲：
>    + 终止条件：当`root == None`时，啥也偷不到，终止。
>    + 参数和返回值：
>      + 参数：传入根节点`root`
>      + 返回值：返回当前节点能到的最大的钱
>    + 单层递归逻辑：比较第`1`点中两种情况，获取最大值然后返回给上一层

~~~python
class Solution:
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        return self.traverse(root)

    def traverse(self, root):
        if not root:
            return 0
        grandSonLeft = 0
        grandSonRight = 0
        if root.left:
            grandSonLeft = self.traverse(root.left.left) + self.traverse(root.left.right)
        if root.right:
            grandSonRight = self.traverse(root.right.left) + self.traverse(root.right.right)
        grandFather = root.val
        son = self.traverse(root.left) + self.traverse(root.right)
        return max(son, grandFather + grandSonLeft + grandSonRight)
~~~

> 1. 上面的代码只通过了部分样例，在遇到树深的样例时运行超时
> 2. 优化：
>    + 可以看到在从上往下进行遍历时，每个节点有三种身份。即`grandFather`节点，`son`节点，`grandson`节点。因此在向上返回时，只要返回到该节点的祖先节点，该节点的这三个身份都会被重新计算一遍
>    + 因此可以定义一个带记忆的递归，记录遍历到当前节点时所能偷到的最大值，再次遍历到该节点时，直接返回。因为是树结构，因此直接考虑字典，`key`为节点地址，`value`为能偷到的最大值

~~~python
class Solution:
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.dic = {}
        return self.traverse(root)

    def traverse(self, root):
        if not root:
            return 0
        if root in self.dic:
            return self.dic[root]
        grandSonLeft = 0
        grandSonRight = 0
        if root.left:
            grandSonLeft = self.traverse(root.left.left) + self.traverse(root.left.right)
        if root.right:
            grandSonRight = self.traverse(root.right.left) + self.traverse(root.right.right)
        grandFather = root.val
        son = self.traverse(root.left) + self.traverse(root.right)
        max_stolen = max(son, grandFather + grandSonLeft + grandSonRight)
        self.dic[root] = max_stolen
        return max _stolen
~~~

### 2560.打家劫舍 $\mathrm{IV}$

题目链接：[力扣-2560.打家劫舍$\mathrm{IV}$](https://leetcode.cn/problems/house-robber-iv/description/)

>1. 要使得小偷某次偷窃行动结束后，能够偷窃的单个房间的最大值，在所有偷窃方案中的单个房间偷窃的最大值中最小
>   + 小偷有多种偷窃方案$p_1,p_2,p_3,...,p_n$，在每种偷窃方案中的单个房价能偷到的最大值为$v_1,v_2,v_3,...,v_n$
>   + 那么所求的就是在这些方案中，找出方案$p_i$使得$v_j$最小
>2. 题目加了一个约束条件，即能偷的最小房间个数不得小于`k`。而对于小偷来讲，$v_j$越小则能偷的房间数就越小，是正比关系
>3. 那么我们就可以通过能偷到的最大房间数来逼近`k`。自然，其能偷的房间会一起被约束。而能偷到的最大房间数我们是可以转化成`dp`问题的
>   + 初始化状态：
>     + `dp[i]`表示偷到第`i`个房间时，能偷的最大房间数。我们可以用`dp[i]`的值来逼近`k`，`dp[i]`值越接近`k`，证明能偷的最大值$v_j$越小
>   + 状态转移方程：
>     + `dp[i] = dp[i - 1]`	当`nums[i] > `$v_j$时，因为约束条件，房间`i`是不能偷的，因此`dp[i]`状态取决于`dp[i - 1]`
>     + `dp[i] = max(dp[i - 1], dp[i - 2] + 1)`         当`nums[i] <= `$v_j$时，房间`i`可偷，因此就是经典的打家劫舍问题了
>   + 初始化状态：
>     + `dp[0] = 1`	当`nums[0] <= `$v_j$时，房间`0`可偷
>     + ~~`dp[1] = 1`        当`nums[1] <= `$v_j$时，房间`1`可偷，为`1`。房间`0`可偷，也只能偷一个房间，为`1`。房间`0`不可偷，房间`1`可偷，为`1`~~
>     + `dp[1] = 1 if nums[1] <= `$v_j$`or dp[0] == 1`，上面删除线部分未考虑当`nums[1] >` $v_j$时，房间`i`可偷的情况
>   + 运行顺序：从左到右
>4. 对于`2`，既然要搜寻一个合适的$v_j$，来使得能偷的房间数逼近`k`，那么可考虑使用二分查找加速搜索过程。（经典的最大值最小化问题，知识点：[最大化最小值问题](https://suwanzi.cn/categories/数据结构/#最大化最小值或最小化最大值)）
>5. 那么二分查找出来的数值，会不会不存在于数组`nums`中呢？ 2
>   + 设答案为 `ans`，那么当最大金额为 `ans `时，可以偷至少 `k`间房子。如果 `ans `不在 `nums `中，那么当最大金额为 `ans−1` 时，也可以偷至少 `k`间房子，假如`ans - 1`也不在`nums`中，那么`ans - 2`也可以偷`k`间房子，一次类推到`nums[i]`在`nums`中。那么有`nums[i] =< res <= ans`这个区间的答案都符合题意，这与二分算法相矛盾：根据视频中讲的[红蓝染色法](https://www.bilibili.com/video/BV1AP41137w7/?vd_source=cb427266333ff90bbe3b3969c8065151)，循环结束时，`ans `和 `ans−1` 的颜色必然是不同的，即 `ans `可以满足题目要求，而 `ans − 1` 不满足题目要求（其实更新完`left`和`right`时，要么在`target`左边界，要么在右边界，终止的`left`和`right`是不可能处在边界中间的）。所以，二分出来的答案，一定在 `nums`中。

~~~python
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        return self.findMinMax(nums, k, 0, max(nums), self.dpFuc)

    def findMinMax(self, nums, target, left, right, func):
        while left <= right:
            mid = left + (right - left) // 2
            if func(maxVal=mid, nums=nums) >= target:
                right = mid - 1
            else:
                left = mid + 1
        return right + 1

    def dpFuc(self, maxVal, nums):
        size = len(nums)
        dp = [0] *  size
        if nums[0] <= maxVal:
            dp[0] = 1
        if nums[1] <= maxVal:
            dp[1] = 1

        for i in range(2, size):
            if nums[i] > maxVal:
                dp[i] = dp[i - 1]
            else:
                dp[i] = max(dp[i - 2] + 1, dp[i - 1])
        return dp[-1]
~~~

## 200.岛屿数量

题目链接：[力扣-200.岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)

> 思路1：DFS
>
> + 四个方向搜索，使用状态数组记录搜索过的节点
> + 当新一轮的搜索开始时，岛屿计数加一

~~~python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        guides = [[1, 0], [-1, 0], [0, -1], [0, 1]]
        m, n = len(grid), len(grid[0])
        status = [[False] * n for _ in range(m)]
        count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1' and not status[i][j]:
                    count += 1
                    self.dfs(grid, guides, status, m, n, i, j)
        return count
    
    def dfs(self, grid, guides, status, m, n, i, j):
        status[i][j] = True
        for guide in guides:
            x = guide[0] + i
            y = guide[1] + j
            if x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == '1' and not status[x][y]:
                self.dfs(grid, guides, status, m, n, x, y)
~~~

> 思路2：并查集
>
> + 并查集知识点链接：[并查集](https://suwanzi.cn/categories/数据结构/#并查集)
>
> 1. 将坐标转换为字符串作为节点值
>    + 字符串不能直接使用`str(i) + str(j)`这种作为节点值，比如`str(1) + str(11)`与`str(11) + str(1)`会长生相同的节点值。因此使用`str(i) + '|' + str(j)`
> 2. 经典遍历矩阵时的四个方向`[[1, 0], [-1, 0], [0, 1], [0, -1]]`，如果新坐标为`1`那么`merge`
> 3. 最后再将所有节点`find`碾平一次，保证每个集合的树深为`2`
> 4. 将表示节点树的字典`dic`的值装入`set`，`set`中有多少值就有多找个岛屿

~~~python
class UF:
    def __init__(self, grid, m, n):
        self.dic = {}
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    self.dic[str(i) + '|' + str(j)] = str(i) + '|' + str(j)

    def find(self, x):
        if self.dic[x] != x:
            self.dic[x] = self.find(self.dic[x])
        return self.dic[x]

    def merge(self, p, q):
        rootp = self.find(p)
        rootq = self.find(q)
        if rootp == rootq:
            return
        if p == rootp:
            self.dic[rootp] = rootq
        else:
            self.dic[rootq] = rootp

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0])
        uf = UF(grid, m, n)
        guides = [[1, 0], [-1, 0], [0, 1], [0, -1]]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    for guide in guides:
                        x = guide[0] + i
                        y = guide[1] + j
                        if x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == '1':
                            uf.merge(str(i) + '|' + str(j), str(x) + '|' + str(y))
        for key in uf.dic.keys():
            uf.find(key)
        return len(set(uf.dic.values()))
~~~

> 并查集优化：
>
> 1. 不需要遍历四个方向，如果遍历`[-1, 0], [0, -1]`相当于往回走了，这是重复遍历。
> 2. 当使用`str(i) + '|' + str(j)`会有字符串的操作，可以直接使用元组作为节点值`(i, j)`
> 3. `UF`函数设置一个变量`self.count`，在初始化节点值时，每个为`1`的节点都是一个单独的岛屿，所以`self.count`初始化为`1`的个数。当进行一次合并时`self.count`减一，最后返回`self.count`
> 4. 既然不需要`[-1, 0], [0, -1]`那么判断条件就不需要`x >= 0`和`y >= 0`了

~~~python
class UF:
    def __init__(self, grid, m, n):
        self.dic = {}
        self.count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    self.dic[(i, j)] = (i, j)
                    self.count += 1

    def find(self, x):
        if self.dic[x] != x:
            self.dic[x] = self.find(self.dic[x])
        return self.dic[x]

    def merge(self, p, q):
        rootp = self.find(p)
        rootq = self.find(q)
        if rootp == rootq:
            return
        self.dic[rootp] = rootq
        self.count -= 1

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0])
        uf = UF(grid, m, n)
        guides = [[1, 0], [0, 1]]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    for guide in guides:
                        x = guide[0] + i
                        y = guide[1] + j
                        if  x < m and  y < n and grid[x][y] == '1':
                            uf.merge((i, j), (x, y))
        return uf.count
~~~

## 206.反转链表

### 单链表

题目链接：[力扣-206.反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)

> 1. 用临时节点`temp`存储头节点的`next`
> 2. 让`head`节点的下一个 节点等于当前节点
> 3. 更新当先节点为`head`
> 4. 更新`head`为`1`中的`temp`

~~~python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = None
        while head:
            temp = head.next
            head.next = pre
            pre = head
            head = temp
        return pre
~~~

### 双链表

> 1. `pre`更新为当前节点的`next`
> 2. 其余更新`next`步骤和单链表一样

~~~python
class Solution:
    def reverseList(self, head):
        pre = None
        while head:
            temp = head.next  # 1、保存当前节点的下一个节点信息，便于遍历head和反转当前节点的pre指针
            head.next = pre  # 当前节点的next指针指向上一个节点
            head.pre = temp  # 当前节点的pre指针指向next节点，完成反转
            pre = head  # 将新链表的头节点变为当前节点
            head = temp
        return pre
~~~

## 课程表

### 207.课程表 $\mathrm{I}$

题目链接：[力扣-207. 课程表](https://leetcode.cn/problems/course-schedule)

> 思路1：DFS
>
> 1. 使用字典`dic`创建图，`key`为节点，`value`为子节点组成的数组
>
> 2. 遍历`prerequisites`，以其`prerequisites[i][1]`为起点，以`prerequisites[i][0]`为终点。如果从图中`prerequisites[i][1]`出发，能达到`prerequisites[i][0]`，则证明能学到课程`prerequisites[i][0]`
>
> 3. 使用字典`status`记录遍历过的节点，如果一个节点遇到两次则存在环，终止`DFS`
>
> 4. 如果遍历完`prerequisites`还未返回`False`，则证明课程能全部学完，返回`True`
>
>    + ~~~python
>      class Solution:
>          def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
>              graph = {}
>              size = len(prerequisites)
>              for i in range(size):
>                  prerequisite = prerequisites[i]
>                  if graph.get(prerequisite[1]):
>                      graph[prerequisite[1]].append(prerequisite[0])
>                  else:
>                      graph[prerequisite[1]] = [prerequisite[0]]
>                                                  
>              for i in range(size):
>                  status = {}
>                  prerequisite = prerequisites[i]
>                  status[prerequisite[1]] = False
>                  if not self.dfs(graph, prerequisite[1], prerequisite[0], status):
>                      return False
>              return True
>                                                      
>          def dfs(self, graph, start, end, status):
>              if start == end:
>                  return True
>              if status[start]:
>                  return False
>              sons = graph[start]
>              for son in sons:
>                  if son not in status or not status[son]:
>                      status[son] = True
>                      if self.dfs(graph, son, end, status):
>                          return True
>                      status[son] = False
>              return False
>
> 5. 错因：上述关于遍历`prerequisites`和使用`status`的思路是错误的
>
>    + 以`prerequisites[i][1]`为起点，以`prerequisites[i][0]`为终点，没有考虑到这两个点正好在环上的情况
>      + 如果正好在环上，以`start == end`来判断是否返回`True`会得到错误结果
>      + 如果不以`start == end`作为判断依据，那么想不到用什么做判断依据了
>    + 以`status`作为记录状态，每次判断`prerequisites[i]`便会重新创建状态，那遍历过的状态会消失。假如起始点和终点都在环上，那么丢失的状态可能会导致检测不出环
>
> 6. 修正：
>
>    + 以字典创建图`graph`，遍历以`0 -> numCourse - 1`节点为起始节点（记为节点`k`）的路径。如果无论从哪个节点出发，都不会有循环，则证明不存在环。那么意味着每个课程之间没有相互作为前置条件，则都能学习
>
>    + 使用状态数组`status`记录访问过的节点。
>
>      + `status[i] == 0`，表示该节点未被访问
>      + `status[i] == 1`，表示遍历从`k`节点出发的这轮遍历，经过了`i`节点
>      + `status[i] == -1`，表示从`i`节点开始遍历图，不存在环，从别的节点遍历过来就不需要继续往下遍历了，减少遍历次数
>
>    + 递归遍历的三部曲：
>
>      + 终止递归条件：
>        + 当发现`status[i] == 1`，那么证明从节点`k`出发的遍历出现了环，`retrun False` 
>        + 当发现`status[i] == -1`，那么表示从节点`k`出发的遍历遇到了确认不会出现换的节点，`return True`
>      + 参数和返回值：`DFS`按需添加参数，返回值为布尔值
>      + 单层递归逻辑：
>        + 在进入节点`i`，判断是否终止递归后，将`status[i]`标记为`1`。
>        + 遍历节点`i`的子节点，判断是否存在环，存在则`return Fasle`
>        + 如果子节点递归返回时，都返回`True`，那么证明从节点`i`开始往后遍历，都不存在环。那么在离开节点`i`时，将`status`标记为`-1`
>        + 结束单层遍历后，发现无环，那么向上层返回`True`
>
>    + 在单层遍历中，不能判断某个子节点无环就返回`True`
>
>      + 这样即使某个子节点有环，而另一个子节点无环也会返回`True`。因为只要有一条路返回`True`那么节点`i`队递归返回时就为`True`
>
>      + 状态数组`status`也无法标记为`-1`，如果标记为`-1`的话，单层遍历结束表示子节点全部有环，才会执行到这一步。
>
>      + 即下面的写法是错误的：
>
>        ~~~python
>        for son in sons:
>            if self.dfs(graph, son, status):
>                return True
>        status[index] = -1
>        return False
>        ~~~

~~~python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = {}
        size = len(prerequisites)
        for i in range(size):
            prerequisite = prerequisites[i]
            if graph.get(prerequisite[1]):
                graph[prerequisite[1]].append(prerequisite[0])
            else:
                graph[prerequisite[1]] = [prerequisite[0]]
        status = [0] * numCourses
        for i in range(numCourses):
            if i in graph:
                if not self.dfs(graph, i, status):
                    return False
        return True

    def dfs(self, graph, index, status):
        if status[index] == 1:
            return False
        if status[index] == -1 or index not in graph:
            return True
        status[index] = 1
        sons = graph[index]
        for son in sons:
            if not self.dfs(graph, son, status):
                return False
        status[index] = -1
        return True
~~~

> 思路2：BFS
>
> 1. 使用字典创建图`graph`，并使用另一个字典记录每个节点的入度`indegrees`
> 2. 入栈入度为`0`的节点，当这些节点出栈时，其子节点的入度减一
> 3. 循环操作`2`，直到栈为空。
> 4. 遍历`indegrees`，如果有节点入度不为`0`，那么返回`Fasle`

**注意：**使用`queue`相较于`collections`的`deque`会比较慢，因为`queue`有加锁操作，比较慢。而`deque`底层是双链表，操作复杂度为`O(1)`

~~~python
# import queue
# from typing import List
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = {}
        indegrees = {}
        size = len(prerequisites)
        for i in range(size):
            prerequisite = prerequisites[i]
            if graph.get(prerequisite[1]):
                graph[prerequisite[1]].append(prerequisite[0])
            else:
                graph[prerequisite[1]] = [prerequisite[0]]

            if indegrees.get(prerequisite[0]):
                indegrees[prerequisite[0]] += 1
            else:
                indegrees[prerequisite[0]] = 1

        # que = queue.Queue()
        que = collections.deque()
        for key in graph.keys():
            if key not in indegrees.keys():
                # que.put(key)
                que.append(key)
        # while not que.empty():
        while que:
            # pre = que.get()
            pre = que.pop()
            if pre in graph:
                for son in graph[pre]:
                    indegrees[son] -= 1
                    if indegrees[son] == 0:
                        # que.put(son)
                        que.append(son)
        for val in indegrees.values():
            if val > 0:
                return False
        return True
~~~

### 210.课程表 $\mathrm{II}$

题目链接：[力扣-210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii)

> 思路：BFS
>
> 1. 创建图`graph`和入度表`indegrees`
> 2. 将入度为`0`的节点入栈`que`，然后出栈。
> 3. 在出栈时，将出栈节点的子节点入度减一，并用`res`收集出栈的节点。重复`2、3`过程，直到栈空
> 4. 判断入度标`indegrees`是否还有节点度不为`0`，如果不为零则表示有环，按题意返回`[]`
> 5. 遍历`0 -> numCourse - 1`，如果`res`不包含`0 -> numCourse - 1`里的数，那么添加进`res`

~~~python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = {}
        indegrees = {}
        res = []
        for x, y in prerequisites:
            if graph.get(y):
                graph[y].append(x)
            else:
                graph[y] = [x]
            if indegrees.get(x):
                indegrees[x] += 1
            else:
                indegrees[x] = 1
        que = collections.deque()
        for key in graph.keys():
            if key not in indegrees:
                que.append(key)
        while que:
            pre = que.pop()
            res.append(pre)
            if pre in graph:
                for son in graph[pre]:
                    indegrees[son] -= 1
                    if indegrees[son] == 0:
                        que.append(son)
        for val in indegrees.values():
            if val > 0:
                return []
        for i in range(numCourses):
            if i not in res:
                res.append(i)
        return res
~~~

> 优化：
>
> 1. 可以考虑使用数组来作为入度表，给每个节点初始化一个为`0`的入度。简化后序根据入读表判断是否有环和`res`中缺少课程号的过程
> 2. 使用`collections`的`defaultDict`，这样就不用考虑`key`是否存在的问题

~~~python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = collections.defaultdict(list)
        indegrees = [0] * numCourses
        res = []
        for x, y in prerequisites:
            graph[y].append(x)
            indegrees[x] += 1
        que = collections.deque()
        for i in range(numCourses):
            if indegrees[i] == 0:
                que.append(i)
        while que:
            pre = que.pop()
            res.append(pre)
            for son in graph[pre]:
                indegrees[son] -= 1
                if indegrees[son] == 0:
                    que.append(son)
        if numCourses != len(res):
            return []
        return res
~~~

> 思路2：DFS
>
> 1. 因为上课的顺序是有顺序的，所以说返回的结果`res`需要考虑顺序的正确性。
>    + 对于`207`中验证环的顺序，如果在进入递归时将`index`加入`res`，那么并不能保证顺序性，因为`index`小的课程号并不一定为必须先修的课程。
>    + 如果在离开时将`index`加入`res`，那么根据递归的特性，相当于先将后修的课程加入`res`，再加入前置课程`index`。这样得出的顺序和课程选修顺序是相反的。那么在返回`res`时，需要将`res`取反
> 2. 基于以上讨论，我们可以建立逆序表，在离开递归时将`index`加入`res`，这样可以省下将`res`取反的步骤
> 3. 判断环的方式和`207`一样，如果存在环直接返回`[]`

~~~python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = collections.defaultdict(list)
        for x, y in prerequisites:
            graph[x].append(y)
        status = [None] * numCourses
        res = []
        for i in range(numCourses):
            if not self.dfs(graph, status, res, i):
                return []
        return res

    def dfs(self, graph, status, res, index):
        if status[index] == 1:
            return False
        if status[index] == -1:
            return True
        status[index] = 1
        for son in graph[index]:
            if not self.dfs(graph, status, res, son):
                return False
        status[index] = -1
        res.append(index)
        return True
~~~

### 630.课程表 $\mathrm{III}$

题目链接：[力扣-630. 课程表 III](https://leetcode.cn/problems/course-schedule-iii)

> 思路：堆 + 排序
>
> 1. 对于上课来讲，肯定是`DDL`越早的课，越需要先被上完。基于这一点可以考虑通过`courses[i][1]`来进行排序，将`courses[i][1]`小的排在前面
> 2. 那么往后遍历时，肯定会遇到上课时间短，但是`DDL`又很大的`courses[i]`。
>    + 课时短的课程应该是要先被考虑的，如果前面课时长而`DDL`又小的课被上了，那么累计课时大于当前课时的`DDL`，这门课就上不成了
>    + 所以考虑到这点，我们应该允许反悔。即放弃课时最长的那门课，选课时较短的这门课。即用一个大顶堆维护已选课程

~~~python
class Heap:
    def __init__(self):
        self.count = 0
        self.nums = []
        self.build_heap()
    
    def build_heap(self):
        size = len(self.nums)
        for i in range(size):
            self.up(i)
        self.count = size

    def up(self, index):
        while index > 0 and (index - 1) // 2 >= 0:
            temp = (index - 1) // 2
            if self.nums[index][0] > self.nums[temp][0]:
                self.nums[index], self.nums[temp] = self.nums[temp], self.nums[index]
            index = temp

    def down(self, end):
        start = 0
        while 2 * start + 1 <= end:
            temp = 2 * start + 1
            if temp + 1 <= end and self.nums[temp + 1][0] > self.nums[temp][0]:
                temp += 1
            if self.nums[start][0] > self.nums[temp][0]:
                break
            self.nums[start], self.nums[temp] = self.nums[temp], self.nums[start]
            start = temp

    def push(self, val):
        if self.count < len(self.nums):
            self.nums[self.count] = val
        else:
            self.nums.append(val)
        self.up(self.count)
        self.count += 1

    def pop(self):
        if self.count ==  0:
            return None
        val = self.nums[0]
        # self.count -= 1
        if self.count > 1:
            self.nums[0] = self.nums[self.count - 1]
            if self.count > 2:
                self.down(self.count - 2)
        self.count -= 1
        return val

class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        courses = sorted(courses, key=lambda x: x[1])
        heap = Heap()
        study = 0
        count = 0
        for x, y in courses:
            if x <= y:
                if study + x <= y:
                    study += x
                    count += 1
                    heap.push([x, y])
                else:
                    if x < heap.nums[0][0] and study - heap.nums[0][0] + x <= y:
                        val = heap.pop()
                        heap.push([x, y])
                        study = study - val[0] + x
        return count
~~~

### 1462.课程表 $\mathrm{IV}$

题目链接：[力扣-1462.课程表 $\mathrm{IV}$](https://leetcode.cn/problems/course-schedule-iv)

> 思路1：DFS
>
> 1. 跟`207,210`思路一样，使用字典`graph`模拟图。因为题目说明了无环，那么不需要记录状态。因此不需要`status`
>
> 2. 以`queries[i][0]`为起点`start`，以`queries[i][1]`为终点`end`，遍历`graph`，并将遍历结果返回。使用`res`收集
>
> 3. 递归三部曲：
>
>    + 终止递归条件：`start == end`或者遍历到图的无子节点的位置，返回
>
>    + 参数和返回值：`DFS`参数看情况添加，返回值为布尔值
>
>    + 单层递归逻辑：
>
>      + 当`start == end`时，返回`True`
>      + 继续往下遍历`graph[start]`的子节点，直到`start == end`或者无子节点
>      + 若遍历完自己点都找不到`start == end`，那么返回`False`
>
>    + ~~~python
>      class Solution:
>          def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
>              graph = collections.defaultdict(list)
>              res = []
>              for x, y in prerequisites:
>                  graph[x].append(y)
>              for i, j in queries:
>                  res.append(self.dfs(i, j, graph))
>              return res
>                                                            
>          def dfs(self, start, end, graph):
>              if start == end:
>                  return True
>              for son in graph[start]:
>                  if self.dfs(son, end, graph):
>                      return True
>              return False
>      ~~~
>
> 4. 修正：上面的代码运行超时
>
>    + 分析原因，假设`queries`有`[3, 20], [1, 20]`两个查询选项，那么代码会在`graph`中重复遍历两次`3 -> 20`的路径。
>    + 因此我们需要将遍历过的路径记下来，下次遇到就直接返回结果。
>      + 考虑使用字典记录能否从`a -> b`，如果使用字典，那么键`a`对应的`value`为一个数组，在查询时需要遍历数组，还是耗时
>      + 在标记路径时，可以考虑使用二维数组，用坐标`(a, b)`表示是否联通
>    + 由于`DFS`是层层递归，因此在离开节点时，我们将坐标状态记录在`status`状态表中，防止重复遍历。
>      + 那么意味着我们需要在这一层就要将以`index`开始，到后序的所有子节点的路径都要存储到二维数组`path`中
>      + 因此在子节点递归返回后，遍历节点`0 -> numCourses - 1`，确认`path[index][0 -> numCourses - 1]`的状态。而`index`的子节点肯定是包含在`0 -> numCourses - 1`中的，因此遍历了`0 -> numCourses - 1`就相当于确认了所有`index`子路径的状态。在递归返回时，`index`子路径的状态已经是被确定了，因此`index`到子节点的状态也肯定能被确定
>    + 在经过`DFS`后，所有状态都被确定，因此直接遍历`queries`查询`queries[i][0], queries[i][1]`对应的状态即可

~~~python
class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        graph = collections.defaultdict(list)
        res = []
        path = [[False] * numCourses for _ in range(numCourses)]
        status = [False] * numCourses
        for x, y in prerequisites:
            graph[x].append(y)
        for i in range(numCourses):
            self.dfs(i, graph, path, status, numCourses)
        for i, j in queries:
            res.append(path[i][j])
        return res

    def dfs(self, index, graph, path, status, numCourses):
        if status[index]:
            return True
        for son in graph[index]:
            path[index][son] = True
            self.dfs(son, graph, path, status, numCourses)
            for i in range(numCourses):
                path[index][i] = path[index][i] or path[son][i]  # 注意和BFS的区别，DFS自底向上，因此递推关系为 index -> son -> i
        status[index] = True
~~~

> 思路2：BFS
>
> 1. 使用字典模拟图`graph`，然后使用数组`indegrees`记录每个节点的入度。
> 2. 将入度为零的节点存入一个队列`que`，使用`while`循环出队列。
> 3. 在出列时，遍历出列节点的子节点，并使用一个二维数组`path`记录出列节点`pre`和子节点`son`的链接关系
>    + 此时`path[pre][son]`之间的链接关系已被确定。那么是`pre`的前驱节点的，也肯定是`son`的前驱节点
>    + 那么有`path[i][son] = path[i][son] or path[i][pre]`
> 4. 若`son`的入度为零，那么将`son`入队列
> 5. 遍历`queries`，将查询结果返回

~~~python
class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        graph = collections.defaultdict(list)
        res = []
        path = [[False] * numCourses for _ in range(numCourses)]
        indegrees = [0] * numCourses
        for x, y in prerequisites:
            graph[x].append(y)
            indegrees[y] += 1
        que = collections.deque()
        for i in range(numCourses):
            if indegrees[i] == 0:
                que.append(i)
        while que:
            pre = que.pop()
            for son in graph[pre]:
                path[pre][son] = True
                for i in range(numCourses):
                    path[i][son] = path[i][son] or path[i][pre]  # 注意和DFS的区别，BFS从上到下，因此递推关系为 i -> pre -> son
                indegrees[son] -= 1
                if indegrees[son] == 0:
                    que.append(son)
        for i, j in queries:
            res.append(path[i][j])
        return res
~~~

## 208.前缀树

题目链接：[力扣-208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree)

> 1. 因为单词只包含小写字母，那么可以用一个长度为`26`的数组模拟`26`个字母。
> 2. 在`index`位置存放一个`Trie`对象，然后把指针指向这个空对象，以便下一个字母来时，给其赋值（跟创建链表一个思路）
> 3. 在查询时，按照遍历链表的方式遍历前缀树。现在思考一个问题，什么时候停止呢？
>    + 如果遇到`word`里面的字母在`Trie`中的数组不存在，那么返回`False`
>    + 如果`word`中每个字符都在`Trie`中有匹配，为了保证匹配的不是某个单词的前缀，所以需要使用一个标识符来确认单词添加结束。即`Trie`类应该包含一个标识符
> 4. 在确认是否是前缀时，和第`3`点流程一致，但是不需要确认标识符这一步

~~~python
class Trie:

    def __init__(self):
        self.tree = [None] * 26
        self.isEnd = False

    def insert(self, word: str) -> None:
        node = self
        for c in word:
            index = ord(c) - ord('a')
            if not node.tree[index]:
                node.tree[index] = Trie()
            node = node.tree[index]
        node.isEnd = True

    def search(self, word: str) -> bool:
        node = self
        for c in word:
            index = ord(c) - ord('a')
            if not node.tree[index]:
                return False
            node = node.tree[index]
        return True if node.isEnd else False

    def startsWith(self, prefix: str) -> bool:
        node = self
        for c in prefix:
            index = ord(c) - ord('a')
            if not node.tree[index]:
                return False
            node = node.tree[index]
        return True
~~~

## 221.最大正方形

题目链接：[力扣-221.最大正方形](https://leetcode.cn/problems/maximal-square)

> 思路：动态规划
>
> 1. 初始化状态：
>    + `dp[i][j]`表示以坐标`(i, j)`为右下角的矩阵的最大边长
>    + 由于`dp[i][j]`的左边，上边，即左上都可以作为矩阵的右下角。即`dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]`。
>      + 那么`dp[i][j]`往左最多能拓展到`min(dp[i][j - 1], dp[i - 1][j - 1])`处
>      + 同理`dp[i][j]`往上最多能拓展到`min(dp[i - 1][j], dp[i - 1][j - 1])`处
> 2. 状态转移方程：
>    + 根据`1`中的讨论，合并状态有：`dp[i][j] = min(dp[i][j - 1], dp[i - 1][j - 1], dp[i - 1][j])`
> 3. 初始化数组：
>    + 只要`i == 0` 或`j == 0`，那么`dp[i][j] = matrix[i][j]`
> 4. 运行顺序：先列后行

~~~python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        m, n = len(matrix), len(matrix[0])
        dp = [[0] * n for _ in range(m)]
        res = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    if j == 0 or i == 0:
                        dp[i][j] = 1
                    else:
                        w = min(dp[i][j - 1], dp[i - 1][j - 1])
                        h = min(dp[i - 1][j], dp[i - 1][j - 1])
                        edge = min(w, h) + 1
                        dp[i][j] = edge
                    res = max(dp[i][j] * dp[i][j], res)
        return res
~~~

## 226.翻转二叉树

> 思路1：递归
>
> 1. 进入递归时，交换左右子树
> 2. 离开递归时，返回根节点

~~~python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
~~~

> 思路2：非递归
>
> 1. 将非`None`节点入栈
> 2. 出栈并交换入栈节点的左右子树
> 3. 入栈非空的左右子节点
> 4. 重复`1,2,3`

~~~python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        que = [root]
        while que:
            pre = que.pop(0)
            pre.left, pre.right = pre.right, pre.left
            if pre.left:
                que.append(pre.left)
            if pre.right:
                que.append(pre.right)
        return root
~~~

## 234.回文链表

> 思路1：暴力法
>
> + 遍历到数组中，再确认是否是回文数组
>
> 思路2：递归
>
> 1. 使用一个全局变量`pre`，将`head`赋值给`pre`。
> 2. 递归三部曲：
>    + 终止条件：当`pre`为`None`时，终止递归
>    + 参数和返回值：
>      + 参数：前驱节点`pre`和节点`head`
>      + 返回值：返回`pre`和`head`的比较结果，类型为布尔型
>    + 单层递归逻辑：
>      + 在离开递归时比较`pre.val`和`head.val`的值，如果不相等返回`False`

~~~python
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        self.pre = head
        return self.tranvers(head)

    def tranvers(self, head):
        if not head:
            return True
        son = self.tranvers(head.next)
        if self.pre.val != head.val:
            return False
        self.pre = self.pre.next
        return son
~~~

## 236.二叉树的最近公共祖先

题目链接：[力扣-236.二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)

> 思路：递归
>
> 1. 递归三部曲：
>    + 终止条件：当`root`为空
>    + 参数和返回值：
>      + 参数：`p, q, root`节点
>      + 返回值：布尔类型的值，为`root`和`p, q`的比较结果
>    + 单层递归逻辑：
>      + 使用一个全局标量`self.res`来表示结果，并使用标识符`self.isTrue`来表示是否找到祖先节点，防止递归返回到父节点时，`self.res`的结果被修改。
>      + 当`root`为`None`时，和`p, q`肯定不相等。返回`False`
>      + 当，当前`root`等于`p, q`时
>        + 如果这时有`left`或者`right`为`True`，那么证明当前的`p | q`节点就是最近的祖先节点。更新`self.res`和标识符
>        + 如果`left`和`right`都为`False`，那么直接返回`True`，表示找到了一个前驱节点
>      + 当`left`和`right`都为`True`时，那么证明当前节点为最近的祖先节点，更新`self.res`和标识符
>      + 返回是否寻找到目标节点的布尔值，即`left or right`

~~~python 
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        self.ans = None
        self.isTrue = False
        self.tranverse(root, p, q)
        return self.ans

    def tranverse(self, root, p, q):
        if not root:
            return False
        left = self.tranverse(root.left, p, q)
        right = self.tranverse(root.right, p, q)
        if root == p or root == q:
            if left or right:
                self.ans = root
                self.isTrue = True
            return True
        if left and right and not self.isTrue:
            self.isTrue = True
            self.ans = root
        return left or right
~~~

> 优化：
>
> 1. 在寻找`p, q`节点时，在进入递归时就可以判断是否寻找到`p, q`，这样不用继续向下遍历。因为这时候假如只找到一个节点`p | q`就不继续向下递归的话，证明找到的这个节点就是最近的祖先节点。
> 2. 判断是否更新`self.ans`的标识符`self.isTrue`其实可以不需要，因为只有最近的公共祖先节点才会同时满足`left == right == True`

~~~python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        self.ans = None
        self.tranverse(root, p, q)
        return self.ans

    def tranverse(self, root, p, q):
        if not root:
            return False
        if root == p or root == q:
            self.ans = root
            return True
        left = self.tranverse(root.left, p, q)
        right = self.tranverse(root.right, p, q)
        if left and right:
            self.ans = root
        return left or right
~~~

## 238. 除自身以外数组的乘积

题目链接：[力扣-238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

> 思路1：左右收集乘积
>
> 1. 题目要求不能使用除法，那么使用双指针，分别求除自己意外，左边和右边的连乘
> 2. 最后将两个连乘数组对应位置上的数值乘起来，返回结果

~~~python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        size = len(nums)
        left = [0] * size
        right = [0] * size
        left[0] = 1
        right[size - 1] = 1
        for i in range(1, size):
            left[i] = left[i - 1] * nums[i - 1]
            right[size - i - 1] = right[size - i] * nums[size - i]
        for i in range(size):
            left[i] = left[i] * right[i]
        return left
~~~

> 优化：使用了额外空间`left`和`right`，可以考虑在空间上优化
>
> 1. 使用数组`ans`收集除`nums[i]`之外，左边的乘积。
> 2. 使用临时变量`temp`，重新遍历`nums[i]`，收集右边的乘积
>    + 不能按照`ans[i] = nums[i + 1] * ans[i + 1]`的方式更新`ans`。因为`ans[i]`表示除`nums[i]`之外，左边的乘积。如果这样更新`ans`会将乘过的数字重新再乘一次
> 3. 在遍历的同时，将`temp`与`nums[i]`相乘

~~~python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        size = len(nums)
        ans = [1] * size
        for i in range(1, size):
            ans[i] = ans[i - 1] * nums[i - 1]
        temp = 1
        for i in range(size - 2, -1, -1):
            temp = temp * nums[i + 1]
            ans[i] = ans[i] * temp
        return ans
~~~

## 239.滑动窗口最大值

题目链接：[力扣-239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

> 思路：单调递减栈
>
> 1. 题目所求的为滑动窗口中的最大值，那么我们只需要将窗口中小于当前值的所有值去掉就行，不影响结果
> 2. 因为是滑动窗口，因此左右边界是变化的。因此为了判断是否出栈左边界的元素，存入栈中为序号而非具体值
> 3. 使用一个变量`left`来表示窗口的左边界，当栈头元素等于`left`时，表示下一个窗口来到时，这个栈头需要出栈了。而且因为`left`的约束，可以确定栈中的元素一定是在窗口中的

~~~python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        size = len(nums)
        res = []
        que = collections.deque()
        k  = k - 1
        left = 0
        for i in range(size):
            while que and nums[que[-1]] <= nums[i]:
                que.pop()
            que.append(i)
            if i < k:
                continue
            res.append(nums[que[0]])
            if que[0] == left:
                que.popleft()
            left += 1
        return res
~~~

## 240.搜索二维矩阵 $\mathrm{II}$

题目链接：[力扣-240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

> 思路：二分
>
> 1. 纵向和横向都是递增序列，那么肯定考虑二分法。
> 2. 如果每行第一个元素都大于`target`，那么后序每个元素都大于`target`，返回`False`。如果每行最后一个元素小于`target`，那么一整行元素小于`target`，这行`continue`
> 3. 定义一个全局变量`right`，因为`matrix[i][right]`大于`target`的话，`matrix[i][right]`对应的列和行后面的元素肯定是大于`target`的，因此后序二分也可以直接收缩右边界`right`

~~~python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m, n = len(matrix), len(matrix[0])
        right = n
        for i in range(m):
            if matrix[i][-1] < target:
                continue
            if matrix[i][0] > target:
                return False
            left = 0
            while left <= right:
                mid = left + (right - left) // 2
                if matrix[i][mid] == target:
                    return True
                elif matrix[i][mid] > target:
                    right = mid - 1
                else:
                    left = mid + 1
        return False
~~~

## 279.完全平方数

题目链接：[力扣-279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

> 思路：动态规划
>
> 1. 初始化状态：
>    + `dp[i]`表示数字`i`由平方数组成的最小个数
>    + 那么问题转换成完全背包问题
> 2. 状态转移方程：
>    + `dp[i] = min{dp[i - 1][j], dp[i][j - val] + 1}`
> 3. 数组初始化：
>    + 当`i == 0`时，那么`0`可以由`0`个平方数组成。因此`dp[0] = 0`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [10001] * (n + 1)
        dp[0] = 0
        val = 1
        sqr = 1
        while val <= n:
            for i in range(1, n + 1):
                if i < val:
                    dp[i] = dp[i]
                else:
                    dp[i] = min(dp[i], dp[i - val] + 1)
            sqr += 1
            val = sqr * sqr
        return dp[-1]
~~~

> 优化：
>
> 1. 在完全背包问题中，要选取第`i`个物品的条件是$j >= w_i$。因此对这道题来讲，`i`小于`val`时，`dp[i]`的状态只能由`dp[i - 1]`决定
> 2. 由`1`可知，`i`的遍历范围为`val -> n + 1`，且判断`i`是否大于`val`的步骤也可以省去

~~~python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [10001] * (n + 1)
        dp[0] = 0
        val = 1
        sqr = 1
        while val <= n:
            for i in range(val, n + 1):
                dp[i] = min(dp[i], dp[i - val] + 1)
            sqr += 1
            val = sqr * sqr
        return dp[-1]
~~~

## 283.移动零

题目链接：[力扣-283. 移动零](https://leetcode.cn/problems/move-zeroes/)

> 思路：双指针
>
> 1. 使用`index`记录第一个`0`的位置，每遇到一个非`0`元素就交换，并将`index`的值加`1`

~~~python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        index1 = 0
        size = len(nums)
        for i in range(size):
            if nums[i] != 0:
                if nums[index1] == 0:
                    nums[i], nums[index1] = nums[index1], nums[i]
                    index1 += 1
            else:
                index1 = i if nums[index1] != 0 else index1
~~~

> 优化：可以去掉多余步骤
>
> 1. 在原本的思路是需要判断，当遇到`0`时，是否更新`index1`的值的。但其实这部分可以省略
> 2. 让`index1`随着非`0`元素一起自增，当遇到`0`元素时，`index1`自然会留在原地不更新。但是指针`i`是一直自增的

~~~python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        index1 = 0
        size = len(nums)
        for i in range(size):
            if nums[i] != 0:
                nums[i], nums[index1] = nums[index1], nums[i]
                index1 += 1
~~~

## 287.寻找重复数

题目链接：[力扣-287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

> 思路一：兑子游戏，多数棋子肯定留在最后
>
> + 错误点在于，如果棋子占比数小于一半，那么其实跟多数棋子不相等的棋子都是敌人。所以留下的不一定是多数棋子
>
> 思路2：环形链表
>
> 1. 数组是可以抽象成一个链表的，即以`i`为前节点`nums[i]`为后节点，同理可知`nums[nums[i]]`为`nums[i]`的后一个节点
>
> 2. 抽象成链表后，重复数相当于一个环，那么可以使用环形链表找入环节点的思想。
>
>    + 思考为什么存在环？
>
>      - `case1:`起点从 `nums[0]`开始，进入自环 `nums[i]=i `此时必定有某个下标 `j` 满足 `nums[j]=i` 重复数字 `nums[i]` ，因此进入自环，只能是重复数字的自环。
>
>      - `case2`: 看一下路线：`nums[0]-->nums[nums[0]]-->nums[nums[nums[0]]]-->.......`
>        - 以上路线可以一直进行下去，如果没有环，那么就意味着 `nums` 数组是无限长的，显然不可能
>        - 因为 `case1` ，所以也不可能进入自环，除非是重复数字的自环
>
>    + 为什么入环点就是重复数字？
>
>      + 因为只有入环点才会入度大于等于`2`，而只有重复数的入度才会大于等于`2`

~~~python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow = 0
        fast = nums[0]
        while slow != fast:
            slow = nums[slow]
            fast = nums[nums[fast]]
        fast = nums[fast]
        slow = 0
        while fast != slow:
            fast = nums[fast]
            slow = nums[slow]
        return slow
~~~

> 思路2：二分查找
>
> 1. 因为数组`nums`中的数都在区间`1 -> n`，因此比`nums[i]`小的数都是可知的。
> 2. 那么我们可以二分查找`1 -> n`，求出`mid`。然后计数小于等于`mid`的数，记为`count`
> 3. 如果`count`比`mid`大，那么表明重复数一定在`left -> mid`中间，因为整数小于等于`mid`的数字就只有`mid`个。那么更新`right = mid - 1`
> 4. 反之更新`left`，最后一定是逼近重复数的

~~~python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        size = len(nums)
        left = 0
        right = size - 1
        while left <= right:
            mid = left + (right - left) // 2
            count = 0
            for num in nums:
                if num <= mid:
                    count += 1
            if count > mid:
                right = mid - 1
            else:
                left = mid + 1
        return left
~~~

## 297.二叉树的序列化与反序列化

> 思路1：BFS
>
> 1. 序列化（`serialize`）
>    + 使用`BFS`的方式遍历树，但是需要注意的是，对于不为`None`的节点，在`temp`队列中需要加上两个`None`节点
>    + 按照题意，在`BFS`完成后，需要将`arr`收集的尾部无效空节点去除
> 2. 反序列化（`deserialize`）
>    + 将输入`data`分裂成数组`arr`
>    + 使用一个队列`que2`初始化父节点，`que1`记录`que2`中父节点的子节点，哪些节点加入`que1`中由`arr[start, end]`决定
>      + `start`：每次都更新为`end`
>      + `end`：因为按照题意，节点不为空的父节点，即使其子节点为`None`也必须要有两个子节点。因此`end = 2 * count`，其中`count`为不为空的父节点的个数
>      + 遍历`que2`，使用`index`记录`que1`中元素的位置，每给`que2`中的父节点确认一个子节点`index`就自加一，因为需要通过`index`定位子节点位置，所以不能直接加二。若父节点为空，则直接加二。
>      + 将子节点入列`temp`
>      + 更新`start, end`
>    + 将`que2`更新为`temp`，重复上述过程

~~~python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ''
        que = collections.deque()
        que.append(root)
        arr = []
        while que:
            temp = collections.deque()
            for node in que:
                if node:
                    arr.append(node.val)
                else:
                    arr.append('null')
                if node:
                    temp.append(node.left)
                    temp.append(node.right)
            que = temp
        size = len(arr)
        end = 0
        for i in range(size - 1, -1, -1):
            if arr[i] != 'null':
                end = i
                break
        arr = arr[:end + 1]
        res = ','.join([str(x) for x in arr])
        return res

    def deserialize(self, data):
        """Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """
        if not data:
            return []
        arr = data.split(sep=',')
        root = TreeNode(int(arr[0]))
        son = 2
        start = 1
        end = start + son
        que1 = collections.deque(arr[start:end])
        que2 = collections.deque()
        que2.append(root)
        ele = len(arr)
        while que2:
            temp = collections.deque()
            size = len(que2)
            size1 = len(que1)
            index = 0
            count = 0
            for i in range(size):
                if que2[i]:
                    if index < size1 and que1[index] != 'null':
                        que2[i].left = TreeNode(int(que1[index]))
                        temp.append(que2[i].left)
                        count += 2
                    index += 1
                    if index < size1 and que1[index] != 'null':
                        que2[i].right = TreeNode(int(que1[index]))
                        temp.append(que2[i].right)
                        count += 2
                    index += 1
                else:
                    index += 2
            que2 = temp
            a = end
            end = count + end if count + end <= ele else ele
            start = a
            que1 = collections.deque(arr[start:end])
        return root
~~~

> 优化：上面的代码过于复杂，很多冗余代码
>
> 1. 对于序列化（`serialize`）:
>    + `if node`判断了两次，代码可以合并
>    + 使用`start, end`截取太麻烦，直接`pop()`
> 2. 对于非序列化（`deserialize`）
>    + 因为只空节点只能是子节点，所以在构造时只需要将非空节点入列`que`
>    + 使用`index`记录`arr`数组的位置，若`arr[index] != null`，那么构造左右节点。每构造一个节点`index`都需要加一
>      + 值得注意的是，即使`arr[index] == null`不构造节点，`index`的值也要加一。因为代表当前正在构造子节点的节点，其有个子节点为空。
>      + 因为空节点只能是子节点，因此只要非空节点在`que`中遍历完毕，那么有空子节点的父节点也会使得`index`自加，所以`index`一定会自加到正确的位置

~~~python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ''
        que = collections.deque()
        que.append(root)
        arr = []
        while que:
            temp = collections.deque()
            for node in que:
                if node:
                    arr.append(node.val)
                    temp.append(node.left)
                    temp.append(node.right)
                else:
                    arr.append('null')
            que = temp
        while arr[-1] == 'null':
            arr.pop()
        res = ','.join([str(x) for x in arr])
        return res

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        :type data: str
        :rtype: TreeNode
        """
        if not data:
            return []
        arr = data.split(sep=',')
        root = TreeNode(int(arr[0]))
        que = collections.deque([root])
        size = len(arr)
        index = 1
        while que:
            temp = collections.deque()
            for node in que:
                if index < size and arr[index] != 'null':
                    node.left = TreeNode(int(arr[index]))
                    temp.append(node.left)
                index += 1
                if index < size and arr[index] != 'null':
                    node.right = TreeNode(int(arr[index]))
                    temp.append(node.right)
                index += 1
            que = temp
        return root
~~~

## 300.最长递增子序列

> 思路一：动态规划
>
> 1. 初始化动态：
>    + `dp[i]`表示包含数字`nums[i]`在内的最大连续子序列
>    + 那么遍历`0 -> i`位置的`dp`，找出`nums[i] > nums[j]`的所有子序列个数的最大值
> 2. 状态转移方程：
>    + `dp[i] = max(dp[0] -> dp[i - 1]) + 1`
> 3. 初始化状态：
>    + `dp[0] = 1`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        size = len(nums)
        dp = [0] * size
        dp[0] = 1
        for i in range(1, len(nums)):
            for j in range(i + 1):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j])
            dp[i] += 1
        return max(dp)
~~~

> 思路二：二分
>
> 1. 记录一个单调递增的数组`cap`，表示遍历到`i`处时，最长的子序列，`cap`中每一个数字都表示，长度为`k ( 1 =< k <= res)` 的子序列的最后一位数字的最小值。`res`记录最长子序列的长度
> 2. 因为`cap`有序，那么可以在`cap`中使用二分法找到第一个大于`nums[i]`的数字，使用`nums[i]`替换掉它
>    + 如果`nums[i] > cap[res - 1]`，那么直接令`cap[res] = nums[i]`，并将`res`自加一
>    + 之所以要替换第一个大于`nums[i]`的数原因有两点
>      + 一是替换后并不会影响最大子序列的长度
>      + 二是使得子序列的最后一位尽可能的小，因为最后一位越小，和后序到来的数字组成更长序列的概率就越大。
> 3. 因为是寻找第一个大于`nums[i]`的值，因此二分结束后，将`cap[left] = nums[i]`即可
>    + 二分法有一个特殊情况，即当有`nums[i] == cap[mid]`时，这时候表示`cap`中的序列最后一位最小值不需要更新，因此直接将`mid`赋值给`left`，直接`break`

~~~python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        size = len(nums)
        cap = [0] * size
        cap[0] = nums[0]
        res = 1
        for i in range(1, size):
            if nums[i] > cap[res - 1]:
                cap[res] = nums[i]
                res += 1
                continue
            left = 0
            right = res - 1
            while left <= right:
                mid = left + (right - left) // 2
                if nums[i] < cap[mid]:
                    right = mid - 1
                elif nums[i] > cap[mid]:
                    left = mid + 1
                else:
                    left = mid
                    break
            cap[left] = nums[i]
        return res
~~~

## 301.删除无效的括号

题目链接：[力扣-301. 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/)

> 思路一：`DFS`
>
> 1. 题目要求删除最小的括号数，那么我们需要统计删除左右括号的数目
>    + 使用`left`记录需要删除的左括号数字，使用`right`记录需要删除的右括号的数字
>    + 遍历字符串`s`，遇到左括号`left`加`1`，遇到右括号`left`减`1`。如果遇到右括号时候，如果`left`等于`0`，那么证明遇到了多余的右括号，`right`加一
>      + 特殊情况：字符串`s = )(`。这时`left = 0`，那么最终遍历结果为`left = 1`，`right = 1`。表示两个括号都需要删除，符合题意
> 2. 接着根据给定的字符串，逐个尝试删除每个括号字符，接着递归的处理剩余的字符。
>    + 怎么理解递归删除？
>      + 每层递归都尝试删除`start -> size`的字符`s[i]`，那么从树的层面上看，就是一个笛卡尔积。即尝试删除每种组合
> 3. 递归处理三部曲：
>    + 终止条件：
>      + 当`left`和`right`都为`0`时，证明需要删除的括号已经删除完了，那么停止迭代
>    + 参数和返回值：
>      + 参数：`DFS`需要什么加什么参数
>      + 返回值：因为使用`res`收集删除括号后，有效的字符串。因此不需要返回值
>    + 单层递归逻辑：
>      + 在终止递归时，判断此时剩余的字符串`s`是否满足有效括号的条件。如果满足，那么将`s`添加进`res`。并终止递归
>      + 遍历从`s[start]`开始的字符串`s[start:]`，判断`s[i]  start =< i < size` 为左括号还是右括号，将`s[i]`删除。然后进入下一层递归。（结合笛卡尔积理解）
>        + 所谓删除，直接是将传入下一层的`s = s[:i] + s[i + 1:]`，这样相当于删除`s[i]`
>        + `start`更新为`i`，这里用到了剪枝操作。因为`start`之前的括号，在当前轮次之前的轮次已经被删除掉了。比如从`i = 3`开始递归删除括号，在之后的轮次中删除`i = 0`的括号。但其实以`i = 0`开始递归删除括号的第三个轮次，也会删除`i = 3`的括号。因此为了防止重复递归，在下个轮次中进行剪枝
>        + 当字符串中出现连续相同的括号时，无论删除哪个括号都会得到相同的结果，因此可以继续剪枝。即在以`s[start]`做递归删除后，与`s[start]`紧挨相同的括号都可以直接跳过。注意这里的跳过是指的单层遍历的时候跳过，并不是指的下个轮次不能删除。
>        + 判断当前要被删除的括号为左还是为右，为左则将`left`减一，为右则将`right`减一。然后进入下一轮递归
>    + 判断是否为有效括号组成的字符串：
>      + 使用`count`计数左括号，并遍历删除无效括号后的`s`
>      + 如果遇到左括号，那么`count`加一。遇到右括号，`count`减一。
>      + 如果遇到右括号时，`count`等于`0`，那么证明遇到了多出来的右括号，直接返回`False`
>      + 删除无效括号后的`s`遍历完成后，`return True if count == 0 else False`

~~~python
class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        left = 0
        right = 0
        for c in s:
            if c == '(':
                left += 1
            else:
                if c == ')':
                    if left == 0:
                        right += 1
                    else:
                        left -= 1
        res = set()
        self.dfs(s, 0, res, left, right)
        return res

    def dfs(self,s, start, res, left, right):
        if right == 0 and left == 0:
            if self.is_invalid(s):
                res.add(s)
            return
        size = len(s)
        for i in range(start, size):
            if i > start and s[i] == s[i - 1]:
                continue
            if left > 0 and s[i] == '(':
                self.dfs(s[:i] + s[i + 1:], i, res, left - 1, right)
            if right > 0 and s[i] == ')':
                self.dfs(s[:i] + s[i + 1:], i, res, left, right - 1)

    def is_invalid(self, s):
        count = 0
        for c in s:
            if c =='(':
                count += 1
            if c == ')':
                if count == 0:
                    return False
                count -= 1
        return count == 0
~~~

> 优化思路：
>
> 1. 如果还需要删除的括号数大于剩余未被遍历过的字符子串，即`left + right > size - start + 1`，那么证明继续向下遍历也得不到结果，终止递归
> 2. ~~每当`left == 0 and right == 0`时，都要检查`s`的合法性，这样效率太低。~~
>    + ~~使用变量`count`计数左括号的个数，遇到左括号加一，遇到右括号减一。终止递归时，只需要判断`count`是否为`0`就可以判断是否加入`res`~~
>      + ~~因为单层遍历删除`s[i]`，所以想要统计删除后的`s`还剩下多少左右括号，在更新`count`时需要在循环体的末尾统计。因为相较于`i`，当从`i + 1`开始向下递归时，`s[i]`是保留在删除后的子串`s`中的~~
>      + ~~如果出现了`count == 0`且遇到了右括号的情况，那么证明右括号删除过多，直接终止递归~~
>    + 如果使用`count`计数，那么只能计算已经遍历过的字符串。那么假如遍历过的字符串为`()(`，最后一个字符为`)`，这时`count = 1`那么`res`不会添加`()()`。这样只要合法的`s`包含最后一个字符，那么都不会加入到`res`中。
>    + 所以说使用`count`并不能追踪`s`是合法字符串，但是能追踪字符串`s`的非法性。只要遍历过的字符串出现当`count == 0`时，碰到了右括号，那么提前终止递归（剪枝）

~~~python
class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        left = 0
        right = 0
        for c in s:
            if c == '(':
                left += 1
            else:
                if c == ')':
                    if left == 0:
                        right += 1
                    else:
                        left -= 1
        res = set()
        self.dfs(s, 0, res, left, right, 0, 0)
        return res

    def dfs(self,s, start, res, left, right, left_count, right_count):
        size = len(s)
        if right + left> size - start + 1:
            return
        if right == 0 and left == 0:
            if self.is_invalid(s):
                res.add(s)
            return
        for i in range(start, size):
            if i > start and s[i] == s[i - 1]:
                if s[i] == '(':
                    left_count += 1
                if s[i] == ')':
                    right_count += 1
                if right_count > left_count:
                    return
                continue
            if left > 0 and s[i] == '(':
                self.dfs(s[:i] + s[i + 1:], i, res, left - 1, right, left_count, right_count)
            if right > 0 and s[i] == ')':
                self.dfs(s[:i] + s[i + 1:], i, res, left, right - 1, left_count, right_count)
            if s[i] == '(':
                left_count += 1
            if s[i] == ')':
                right_count += 1
            if right_count > left_count:
                return

    def is_invalid(self, s):
        count = 0
        for c in s:
            if c == '(':
                count += 1
            else:
                if c == ')':
                    if count == 0:
                        return False
                    count -= 1
        return count == 0
~~~

> 思路二：`BFS`
>
> 1. 根据思路一，删除括号关键点在于删除每种可能的组合。
>    + 那么其实可以遍历字符串`s`，然后删除字符`s[i]`，再将每个删除后的新字符串收集起来
>    + 判断删除后的新字符串是否合法，合法则收集起来。不合法继续遍历新字符串，然后删除字符
> 2. 根据`1`中的分析，删除字符可能出现重复的字符串，因此需要使用`set()`记录遍历过的字符串，防止重复遍历
> 3. 因为题目要求删除最少的字符，使得字符串合法。而每次遍历，新字符串都只删除一个字符，因此只要找到合法的新字符串，那么就不需要继续删除了。那么设定一个状态`is_delete`，判断是否需要继续向下删除
> 4. 如果`s[i] == s[i - 1]`，那么重复，直接跳过

~~~python
from collections import deque

class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        que = collections.deque()
        res = []
        trace = set()
        que.append(s)
        trace.add(s)
        is_delete = True
        while que:
            s_new = que.popleft()
            if self.is_invalid(s_new):
                res.append(s_new)
                is_delete = False
            if is_delete:
                size = len(s_new)
                for i in range(size):
                    if i > 0 and s_new[i] == s_new[i - 1] or s_new[i] not in ('(', ')'):
                        continue
                    s_next = s_new[:i] + s_new[i + 1:]
                    if s_next not in trace:
                        trace.add(s_next)
                        que.append(s_next)
        return res

    def is_invalid(self, s):
        count = 0
        for c in s:
            if c =='(':
                count += 1
            else:
                if c == ')':
                    if count == 0:
                        return False
                    count -= 1
        return count == 0
~~~

## 312.戳气球

题目链接：[力扣-312. 戳气球](https://leetcode.cn/problems/burst-balloons/)

> 思路：动态规划
>
> 1. 初始化状态
>    + 将整个数组分解成多个小区间，求小区间能获得硬币的最大值。那么合并区间后的大区间就是最大值
>    + 假设有小区间`(m, n)`，那么令`k`将区间分成`(m, k)`和`(k, n)`两部分。`k`指的是区间中最后一个被戳爆的气球
>      + 因为两个区间都有`k`，这样会产生重复计算，因此定义所有区间都为开区间。
>      + 因为`k`是最后一个被戳爆的气球，因此根据题意，戳爆`k`时，区间`(m, n)`的最大值为`(m, k) + nums[m] * nums[k] * nums[n] + (k, n)`
>      + 因此，遍历`k, m + 1 -> n - 1`，就能找到最佳分割点，使得`(m, n)`区间能得到的硬币最大
>    + 因为区间是由小到大逐渐扩散的，因此大区间的状态肯定能由小区间转移过来
>    + 为了轻松处理边界条件，即在数组头和数组尾时，能表示出开区间。在数组头和数组尾分别添加数字`1`，这样在不影响结果的情况下，不用考虑复杂的边界条件
>    + 令`dp[i][j]`表示开区间`(i, j)`之间能获取硬币最大值
> 2. 状态转移方程
>    + `dp[i][j] = max(dp[i][j], dp[i][k] + nums[i] * nums[k] * nums[j] + dp[k][j])`
> 3. 初始化`dp`数组
>    + 区间`(i, j)`小于`3`的都为`0`，因为至少长度为`3`，**开区间**才能有气球被戳爆
> 4. 运行顺序
>    + 先确定区间长度
>    + 再确定开始位置和结束位置
>    + 遍历`k`

~~~python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1]
        size = len(nums)
        dp = [[0] * size for _ in range(size)]
        for length in range(2, size):
            for i in range(size - length):
                j = i + length
                a = 0
                for k in range(i + 1, j):
                    # dp[i][j] = max(dp[i][j], dp[i][k] + nums[i] * nums[k] * nums[j] + dp[k][j])
                    # 这里不使用max的原因是，在比较大小的情况下，max会多出函数调用的时间。
                    # 且这里对dp[i][j]进行了多次赋值操作，也是蛮大的时间开销。经过测试，这道题不使用max函数运行时间比使用max函数少了一半
                    m = dp[i][k] + nums[i] * nums[k] * nums[j] + dp[k][j]
                    if m > a:
                        a = m
                dp[i][j] = a
        return dp[0][-1]
~~~

## 322.零钱兑换

题目链接：[力扣-312. 戳气球](https://leetcode.cn/problems/burst-balloons/)

> 思路：典型的背包问题，动态规划
>
> 1. 初始化状态：
>    + `dp[i]`表示总额为`j`需要最少的硬币个数
> 2. 状态转移方程：
>    + `dp[i] = max(dp[i], dp[i - coin])`
> 3. 初始化数组：
>    + 因为是需要满背包状态，因此当背包容量`j = 0`时，只有硬币个数都取`0`才有合法值
>    + `dp[0] = 0`
> 4. 运行顺序：
>    + 从左到右

~~~python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [amount + 1] * (amount + 1)
        dp[0] = 0
        for coin in coins:
            for j in range(coin, amount + 1):
                # dp[j] = min(dp[j - coin] + 1, dp[j])
                if dp[j] > dp[j - coin] + 1:
                    dp[j] = dp[j - coin] + 1
        return dp[-1] if dp[-1] != amount + 1 else -1
~~~

## 338.比特位计数

题目链接：[力扣-338. 比特位计数](https://leetcode.cn/problems/counting-bits/)

> 思路：动态规划
>
> 1. 初始化状态：
>    + `dp[i]`表示数字`i`有多少个`1`比特位
>    + 比特位左移一位，数字增大两倍。因此`dp[i]`的状态可由`dp[i >> 1]`决定
> 2. 状态转移方程：
>    + `dp[i] = dp[i >> 1] if i & 1 == 0 else dp[i >> 1] + 1`
> 3. 状态数组初始化：
>    + dp[0] = 0
> 4. 运行顺序：
>    + 从左到右

~~~ python
class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            # div = i % 2
            # pre = i // 2
            # dp[i] = dp[pre] if div == 0 else dp[pre] + 1
            dp[i] = dp[i >> 1] if i & 1 == 0 else dp[i >> 1] + 1
        return dp
~~~

## 347.前K个高频元素

> 思路一：排序 + 字典
>
> 1. 使用字典统计数组中各元素的个数，然后根据个数倒序排列
> 2. 取`topK`
> 3. 优化：使用堆，只需要排序`k`个元素，减少排序时间

~~~python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        dic = collections.defaultdict(int)
        for num in nums:
            dic[num] += 1
        count = list(dic.items())
        count.sort(key=lambda x:x[1], reverse=True)
        res = []
        index = 0
        while index < k:
            res.append(count[index][0])
            index += 1
        return res
~~~

## 394.字符串解码

题目链接：[力扣-394. 字符串解码](https://leetcode.cn/problems/decode-string/)

> 思路：栈
>
> 1. 遍历字符串`s`，将字符入栈
> 2. 当遇到字符`]`时，证明一个完整的需要被扩大倍数的子字符串入栈完成。开始出栈
>    + 判断出栈字符是否为字母，将所有字母按顺序组合在一起
>    + 判断出栈字符是否为数字，将所有数字按顺序组合在一起
>      + 比较数字组成的字符串时，是按照字典序比较的，比如`'3' > '21'`
>    + 将字符串赋值`num`次，然后将复制好的新字符串入栈，等待下一次复制
>      + 不用担心直接入栈会影响字符串拼接的顺序
>      + 当入栈的字符串不需要复制时，证明栈中已经没有数字和括号，栈为空。那么直接入栈没问题
>      + 当入栈的字符需要复制时，证明栈中还有数字和左括号，直接入栈也没问题
> 3. 最后拼接栈中剩余的字符，返回结果

~~~python
class Solution:
    def decodeString(self, s: str) -> str:
        que = collections.deque()
        for c in s:
            if c == ']':
                temp = []
                while que:
                    val = que.pop()
                    if val >= '0' and val <= '9':
                        num = val
                        while que and que[-1] >= '0' and que[-1] < '9':
                            num = que.pop() + num
                        num = int(num)
                        temp_str = ''
                        for i in range(len(temp) - 1, -1, -1):
                            temp_str += temp[i]
                        temp_str = num * temp_str
                        que.append(temp_str)
                        break
                    else:
                        if val != '[':
                            temp.append(val)
            else:
                que.append(c)
        res = ''
        while que:
            res = res + que.popleft()
        return res
~~~

## 399.除法求值

题目链接：[力扣-399. 除法求值](https://leetcode.cn/problems/evaluate-division/)

> 思路：`DFS`
>
> 1. 使用字典模拟加权有向图`graph`，使用状态字典`status`记录状态
> 2. 遍历查询集`queries`，以分子为开头，分母为结尾进行`dfs`查询
> 3. 递归三部曲：
>    + 终止条件
>      + 分子等于分母，证明从开始查询的分子到分母有一条有效路径，终止递归，收集结果到`res`
>      + 如果发现当前节点出现在状态字典中，那么终止递归
>    + 参数和返回值
>      + 参数：需要什么参数就加什么参数
>      + 返回值：返回当前路径是否搜索到结果的布尔值
>    + 单层遍历逻辑
>      + 当搜索到结果或者当前节点出现在状态字典中时，返回布尔值
>      + 将当前节点添加进状态字典，表示已经搜索过
>      + 遍历当前节点的子节点，将当前节点与子节点之间的权值累乘起来，然后进入下一层递归
>      + 递归返回时，如果找到正确搜索结果，终止递归，返回`True`。若没找到，先将累乘结果除以当前边的权值（回溯），接着遍历剩余子节点
>      + 子节点遍历结束也没有搜索到正确结果，返回`False`
> 4. 根据`dfs`的返回结果，如果没有搜索到查询问题对应的等式成立，那么`res.append(-1.0)`

~~~python
class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        graph = collections.defaultdict(dict)
        index = 0
        for x, y in equations:
            graph[x][y] = values[index]
            graph[y][x] = 1 / values[index]
            index += 1
        res = []
        for x, y in queries:
            status = {}
            if x not in graph or y not in graph:
                res.append(-1.0)
            elif x == y:
                res.append(1.0)
            else:
                if not self.dfs(res, x, y, graph, 1, status):
                    res.append(-1)
        return res

    def dfs(self, res, x, y, graph, val, status):
        if x == y:
            res.append(val)
            return True
        if x in status:
            return False
        status[x] = 1
        node = graph[x]
        for next, weight in node.items():
            val = val * weight
            if self.dfs(res, next, y, graph, val, status):
                return True
            val = val / weight
        return False
~~~

## 406.根据身高重建队列

题目链接：[力扣-406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height)

> 思路：排序 + 冒泡
>
> 1. 个子高的人是不会把个子矮的人看在眼里的，因此先把高个子的排在前面。这样从后往前看都是比自己高的人
> 2. 遍历排序好的数组，假如`people[i][1] < i`，那证明当前身高的人前边比`people[i]`高的人太多了，因此`people[i]`需要前移
> 3. 假如排序好的`people`中`people[i][0] == people[j][0], people[i][1] > people[j][1], i < j`，那么按照遍历顺序，`people[i]`会先前移到`index = people[i][1]`的位置上去。但是当遍历到`j`时，`people[j]`肯定是会冒泡到`people`前面的，因为`people[i][1] > people[j][1]`，这样会导致`people[i]`前面的个数大于`people[i][1]`。因此为了避免这种情况出现，需要把数组的第二个元素正序排列，这样前面人数少的不会影响后面人数多的

~~~Python
import random
# leetcode submit region begin(Prohibit modification and deletion)
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        self.quick_sort(people, 0, len(people) - 1)
        for i, (height, count) in enumerate(people):
            if count < i:
                while i != count:
                    people[i], people[i - 1] = people[i - 1], people[i]
                    i -= 1
        return people

    def quick_sort(self, nums, left, right):
        if left >= right:
            return
        L, R = left, right
        index = random.randint(left, right)
        nums[index], nums[left] = nums[left], nums[index]
        provit = nums[left]
        while L < R:
            while L < R and (nums[R][0] < provit[0] or nums[R][0] == provit[0] and nums[R][1] >= provit[1]):
                R -= 1
            if L < R:
                nums[L] = nums[R]
            while L < R and (nums[L][0] > provit[0] or nums[L][0] == provit[0] and nums[L][1] <= provit[1]):
                L += 1
            if L < R:
                nums[R] = nums[L]
            if L == R:
                nums[L] = provit
        self.quick_sort(nums, left, L - 1)
        self.quick_sort(nums, R + 1, right)
~~~

## 416.分隔等和子集

题目链接：[力扣-416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

> 思路1：`DFS`
>
> 1. 判断和为奇数还是偶数，为奇数直接返回`False`
>
> 2. 将和取一半，使用`DFS`组合问题寻找`target`
>
> 3. 运行超时，查看运行结果如下
>
>    + ```markdown
>      # total_testcases:143
>      # total_correct:36
>      ```

~~~python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        total = sum(nums)
        if total & 1 == 1:
            return False
        half = total >> 1
        return self.dfs(half, nums, 0, 0, len(nums))

    def dfs(self, target, nums, start_index, add, size):
        if target < add:
            return False
        if target == add:
            return True
        for i in range(start_index, size):
            add += nums[i]
            if self.dfs(target, nums, i + 1, add, size):
                return True
            add -= nums[i]
        return False
~~~

> 优化1：
>
> 1. 使用局部变量，省去`add -= nums[i]`这一步
> 2. 当`target`和`start_index`相等时，证明后序的排列组合已经没必要了，都是重复计算。因此可以添加一个带记忆的递归遇到后直接返回`False`
>    + 因为已经遍历过的节点肯定没有找到合适的组合，因此肯定是`False`
> 3. 将数组降序排列，优先使用大的数字去排列组合。则遇到正确组合的几率会变大
> 4. 当`target < nums[i]`时，直接跳过，减少递归调用

~~~python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        total = sum(nums)
        if total & 1 == 1:
            return False
        half = total >> 1
        memo = {}
        nums.sort(reverse=True)
        return self.dfs(half, nums, 0, len(nums), memo)

    def dfs(self, target, nums, start_index, size, memo):
        if (target, start_index) in memo:
            return False
        if target == 0:
            return True
        for i in range(start_index, size):
            # add += nums[i]
            if target < nums[i]:
                continue
            if self.dfs(target - nums[i], nums, i + 1, size, memo):
                return True
            # add -= nums[i]
        memo[(target, start_index)] = 1
        return False
~~~

> 思路2：典型的`01`问题，因此考虑使用`DP`
>
> 1. 初始化状态：
>    + `dp[i]`表示数组`nums`中有能够和为`half`的有效组合
> 2. 状态转移方程：
>    + `dp[i] = dp[i] or dp[i - nums[j]]`
> 3. 初始化状态数组：
>    + 对于`i = 0`，什么都不取时，一定有一个有效解
>    + `dp[0] = True`
> 4. 运行顺序：先列后行

~~~python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        total = sum(nums)
        if total & 1 == 1:
            return False
        half = total >> 1
        dp = [False] * (half + 1)
        dp[0] = True
        for i in range(len(nums)):
            for j in range(half, nums[i] - 1, -1):
                dp[j] = dp[j] or dp[j - nums[i]]
        return dp[-1]
~~~

## 437.路径总和 III

题目链接：[力扣-437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

> 思路：前缀和 + 前序遍历
>
> 1. 使用变量`total`记录路径总和，因为`total`只会影响下一层的值，所以向下遍历时只会从父节点到子节点累加值。
> 2. 以累加值`total`为`key`，`value`为从父节点到子节点和为`total`的个数。
>    + 那么`value`表示从父节点到当前节点累加值为`total`有`value`条路径。
> 3. 每前序遍历到一个节点，就将`total`与`target`做差，并在字典`dic`中查找是否有`total - target`的`key`。若存在则表示有`dic[total - target]`条路径到当前节点的和为`target`
>    + 因为需要查询`dic[total - target]`，当`total == target`时，应该有`dic[0]`。所以初始化字典`dic[0] = 1`
> 4. 当前节点的左右节点被遍历完成时，证明这条路径已经被搜索完毕，那么在`dic`中的`total`也应该被减一，表示这条路径被废弃。以免影响其他层级的路径搜索

~~~python
class Solution:
    res = 0
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        dic = collections.defaultdict(int)
        dic[0] = 1
        self.dfs(root, targetSum, 0, dic)
        return self.res

    def dfs(self, root, target, total, dic):
        if not root:
            return
        total += root.val
        if total - target in dic:
            self.res += dic[total - target]
        dic[total] += 1
        self.dfs(root.left, target, total, dic)
        self.dfs(root.right, target, total, dic)
        dic[total] -= 1
~~~

## 438.找到字符串中所有字母异位词

题目链接：[力扣-438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

> 思路：滑动窗口
>
> 1. 根据题目意思是寻找异位词，异位词则长度必须和`p`相等
> 2. 根据`1`，长度必须相等则证明遇到不属于`p`的字符时，`dic_p`和`match`必须被清空，且更新`left`为下一个遍历的字符的索引
> 3. 当字符属于`p`时，统计遇到的字符`s[i]`的数量。
>    + 如果`dic_s[s[i]] == dic_p[s[i]]`，那么表示完成一个字符的匹配`match += 1`
>    + 如果`dic_s[s[i]] > dic_p[s[i]]`，那么记录在`dic_s`中的字符跟原字符串无法匹配。这时需要清除`dic_s`中的字符，直到`dic_s[s[i]] == dic_p[s[i]]`。
>      + 如果清除的过程中有`dic_s[s[j]] == dic_p[s[j]]`，` s[j]`被清除后有`dic_s[s[j]] < dic_p[s[j]]`，则`match -= 1`
> 4. 当`dic_s`与`dic_P`完全匹配时，将`left`加入`res`
>    + 在`dic_s`中移除`s[left]`
>    + `left += 1`，`match -= 1`

~~~python
import collections
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        dic_p = collections.Counter(p)
        dic_s = collections.defaultdict(int)
        left = 0
        match = 0
        match_size = len(dic_p)
        res = []
        for i in range(len(s)):
            if s[i] not in dic_p:
                dic_s.clear()
                match = 0
                left = i + 1
            else:
                dic_s[s[i]] += 1
                if dic_s[s[i]] == dic_p[s[i]]:
                    match += 1
                    if match == match_size:
                        res.append(left)
                        dic_s[s[left]] -= 1
                        left += 1
                        match -= 1
                elif dic_s[s[i]] > dic_p[s[i]]:
                    while dic_s[s[i]] > dic_p[s[i]]:
                        if dic_s[s[left]] == dic_p[s[left]]:
                            match -= 1
                        dic_s[s[left]] -= 1
                        left += 1
                else:
                    pass
        return res
~~~

## 448.找到所有数组中消失的数字

题目链接：[力扣-448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)

> 思路：在进阶中，要求不使用额外空间，且时间复杂度为 $O(n)$。
>
> 1. 当`nums[i]`的值与`i + 1`不匹配时，将数组`nums[i]`放到`nums`数组中索引坐标为`nums[i] - 1`的位置上
> 2. 有两种情况不需要置换：
>    + `nums[i]`的值与`i + 1`匹配
>    + 当`nums[i] == nums[nums[i] - 1]`，即出现了重复数，`nums[nums[i] - 1]`位置上已经有匹配的值
>    + 虽然不需要置换，但是索引需要自加以便确认下一个数字是否需要置换位置
> 3. 置换后，当前位置新的`nums[i]`不一定值为`i + 1`，因此遍历的索引不能自加，需要等待下一轮置换

~~~python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        i = 0
        while i < len(nums):
            index = nums[i] - 1
            if nums[i] == i + 1 or nums[index] == nums[i]:
                i += 1
                continue
            nums[i], nums[index] = nums[index], nums[i]
        res = []
        for j in range(len(nums)):
            if nums[j] != j + 1:
                res.append(j + 1)
        return res
~~~

## 461.汉明距离

题目链接：[力扣-461. 汉明距离](https://leetcode.cn/problems/hamming-distance/)

> 思路：位运算
>
> 1. 异或求出由两个数字不同位置的二进制组成的数字`z`
> 2. 求`z`有多少个位为`1`

~~~python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        z = x ^ y
        res = 0
        while z:
            z &= z - 1  # 将 z 的最低位的 1 置为 0
            res += 1
        return res
~~~

## 538.把二叉搜索树转换为累加树

题目链接：[力扣-538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

> 思路：中序遍历
>
> 1. 因为从右子树开始累加，那么调整中序遍历顺序为右左中
> 2. 使用一个全局变量记录累加和，在中序遍历时修改树的值

~~~python
class Solution:
    total = 0
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        self.convertBST(root.right)
        self.total += root.val
        root.val = self.total
        self.convertBST(root.left)
        return root
~~~

## 543.二叉树的直径

题目链接：[力扣-543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

> 思路：后序遍历
>
> 1. 使用遍历`left`和`right`分别记录左右子树的最大深度
> 2. 使用全局变量`ans`与`left + right`作比较，取较大值
> 3. 返回`max(left, right) + 1`

~~~python
class Solution:
    ans = 0
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.traverse(root)
        return self.ans

    def traverse(self, root):
        if not root:
            return 0
        left = self.traverse(root.left)
        right = self.traverse(root.right)
        self.ans = max(self.ans, left + right)
        return max(left, right) + 1
~~~

## 560.合为K的子数组

题目链接：[力扣-560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

> 思路：前缀和 + 字典
>
> 将数组看成一个单向二叉树，具体思路参考`437`题
>
> + 这里主要讲为什么要在`res`更新后，再更新`dic[add]`。我们寻找的是之前是否有符合答案的子数组，如果在更新`res`之前更新`dic`，那么会将当前的前缀和带入。即假设`add - k == add`，这样会多统计一次区间`i -> i`，而`i -> i`只有一个数字，显然是不符合题意的。
> + 比如`nums = [1], k = 0`，如果先`dic[1] += 1`，那么在统计`add - k = 1 - 0 = 1`时，会将`dic[1] = 1`统计进去。而当`nums = [1], k = 0`时，是不存在满足题意的子区间的

~~~python
import collections
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        dic = collections.defaultdict(int)
        dic[0] = 1
        add = 0
        res = 0
        for i, num in enumerate(nums):
            add += num
            key = add - k
            if dic[key]:
                res += dic[key]
            dic[add] += 1
        return res
~~~

## 581.最短无序连续子数组

题目链接：[力扣-581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)

> 思路一：排序
>
> 1. 将数组正序排序，然后比对无序数组和有序数组中，左边和右边数值不一样的位置，记为`left, right`
> 2. 返回答案`right - left + 1`

~~~python
class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        new = sorted(nums)
        right = len(nums) - 1
        left = 0
        left_continue = True
        right_continue = True
        for i, num in enumerate(nums):
            if num != new[i] and left_continue:
                left = i
                left_continue = False
            if nums[right] != new[right] and right_continue:
                right_continue = False
            if not left_continue and not right_continue:
                break
            if right_continue:
                right -= 1
        return right - left + 1
~~~

> 思路二：单调栈
>
> 1. 根据单调递增栈的性质，栈中存储的是单调递增的数值索引。如果排序正常，那么栈中的索引会从小到大正常排序。如果出现非正常排序，那么非正常排序的索引必定会全部出栈。因此只需要记录出栈的最小索引即为左边界
> 2. 同样的道理，逆序遍历数组，设置一个单调递减栈，最后出栈的为右边界

~~~python
class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        up = []
        down = []
        size = len(nums)
        left = size
        right = -1
        for i in range(size):
            while up and nums[up[-1]] > nums[i]:
                index = up.pop()
                left = min(left, index)
            up.append(i)
        for i in range(size - 1, -1, -1):
            while down and nums[down[-1]] < nums[i]:
                index = down.pop()
                right = max(right, index)
            down.append(i)
        return right - left + 1 if right > left else 0
~~~

> 思路三：双变量记录最大值和最小值
>
> 1. 要想数组有序，只需要数字按照大小待在该待的地方。
> 2. 从正序开始遍历，维护一个最大值`val_max`，那么在遇到`nums[i] > val_max`之前的所有小于`val_max`的数字都是错序需要重新排序的。那么我们可以在遍历的同时，更新`val_max`值。同时遇到小于`val_max`的`nums[i]`，将`right`更新为`i`，因为`val_max`的位置至少为`i`
> 3. 同`2`，可以逆序遍历，维护一个最小值`val_min`和`left`

~~~python
class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        size = len(nums)
        val_max = float('-inf')
        val_min = float('inf')
        left = size
        right = -1
        for i in range(size):
            if nums[i] < val_max:
                right = i
            else:
                val_max = nums[i]
            index = size - 1 - i
            if nums[index] > val_min:
                left = index
            else:
                val_min = nums[index]
        return right - left + 1 if right > left else 0
~~~

## 617.合并二叉树

题目链接：[力扣-617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

> 思路：递归 + 前序遍历

~~~python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1 or not root2:
            return root1 if root1 else root2
        val = root1.val + root2.val
        root1.val = val
        root1.left = self.mergeTrees(root1.left, root2.left)
        root1.right = self.mergeTrees(root1.right, root2.right)
        return root1
~~~

## 621.任务调度器

题目链接：[力扣-621. 任务调度器](https://leetcode.cn/problems/task-scheduler/)

> 思路：极大矩阵
>
> 1. 按照任务数最多的那类任务`val_max`，与间隔天数加一建立矩阵`matrix`，那么有`matrix = val_max * (n + 1)`
>    + 因为需要间隔`n`天才能执行相同的任务`A`，而任务`A`也需要占据矩阵的一个位置，因此列数为`n + 1`
> 2. 统计与`val_max`相等的任务的种类个数，记为`count`，那么矩阵的`count`列是肯定要被填满的。
> 3. 因为执行任务需要间隔`n`天的关系，所以无论矩阵`matrix`的后`n + 1 - count`列是否填入任务，都必须有个空格占位。所以我们只需要关注矩阵`matrix`的最后一行的执行情况。
>    + 统计任务列表`tasks`的大小，记为`size`。如果`size > matrix - (n + 1) + count`，那么表示任务数已经超过了完成任务所必需的方格数`matrix - (n + 1) + count`，那么直接返回`size`
>    + 如果`size < matrix - (n + 1) + count`，那么证明必需的方格数已经能装下所有任务（即后`n + 1 - count`行中的空格完全满足除任务数与`val_max`相等的其他任务的位置需求），直接返回` matrix - (n + 1) + count`

~~~python
import collections
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        val_max = 0
        dic = collections.defaultdict(int)
        size = len(tasks)
        for task in tasks:
            dic[task] += 1
            val_max = max(val_max, dic[task])
        count = 0
        for key, val in dic.items():
            if val == val_max:
                count += 1
        matrix = val_max * (n + 1)
        time = matrix - (n + 1) + count
        return size if size >= time else time
~~~

## 647.回文子串

题目链接：[力扣-647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

> 思路一：遍历
>
> 1. 先考虑单个中心的子串是否为回文字符串，因为按照题意字符串相同但是位置不同的子串也算是不同的回文子串。
>    + 每判定一个子串为回文子串则令回文子串个数`count += 1`
> 2. 再考虑双中心的子串是否为回文子串，`count`增加方式和`1`相同
> 3. 注意每个中心点（单个、双个）也算是回文子串

~~~python
class Solution:
    def countSubstrings(self, s: str) -> int:
        count = 0
        size = len(s)
        for i in range(size):
            count += 1
            left = i - 1
            right = i + 1
            while left > -1 and right < size and s[left] == s[right]:
                count += 1
                left -= 1
                right += 1
            if i < size - 1 and s[i] == s[i + 1]:
                count += 1
                left = i - 1
                right = i + 2
                while left > -1 and right < size and s[left] == s[right]:
                    count += 1
                    left -= 1
                    right += 1
        return count
~~~

> 思路二：动态规划
>
> 1. 初始化状态：`dp[i][j]`表示字符串`s`位置从`i -> j`是否为回文字符串
>    + 子问题一：要想`s[i][j]`合法，那么必须有`i <= j`，因此矩阵只需要遍历上三角区域
>    + 子问题二：当`i == j`时，单个字符`s[i]`也为回文字符串
>    + 子问题二：当`j - i == 1`时，若`s[i] == s[j]`，则`s[i][j]`也为回文字符串，那么`dp[i][j]`也为`True`
> 2. 状态转移方程：
>    + `dp[i][j] = (dp[i + 1][j - 1] or j - 1 == i) and s[i] == s[j]`
> 3. 初始化状态数组：
>    + 当`i == j`时，`dp[i][j] == True`
> 4. 运行顺序：
>    + 因为`dp[i][j]`的状态与未来`dp[i + 1][*]`的状态有关，因此行需要倒序遍历

~~~python
class Solution:
    def countSubstrings(self, s: str) -> int:
        size = len(s)
        dp = [[False] * size for _ in range(size)]
        res = 0
        for i in range(size - 1, -1, -1):
            for j in range(i, size):
                if i == j:
                    dp[i][j] = True
                    res += 1
                else:
                    dp[i][j] = (dp[i + 1][j - 1] or j - i == 1) and s[i] == s[j]
                    if dp[i][j]:
                        res += 1
        return res
~~~

## 739.每日温度

题目链接：[力扣-739. 每日温度](https://leetcode.cn/problems/daily-temperatures)

> 思路：单调递减栈
>
> 1. 维护一个单调递减栈`stack`，栈中存储数字的索引`index`
> 2. 设置一个大小为`size`的`res`数组，初始化值全部为零
> 3. 根据最小栈性质，当遇到大于自己的数字时，出栈。同时根据出栈的`index`更新`res[index] = i - index`

~~~python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        stack = []
        size = len(temperatures)
        res = [0] * size
        for i in range(size):
            while stack and temperatures[stack[-1]] < temperatures[i]:
                index = stack.pop()
                res[index] = i - index
            stack.append(i)
        return res
~~~





---



[^1]: `pre`和`res`都是在`class`中定义，使用`self.pre`和`self.res`调用
[^2]: 这里值得注意的是，需要将`pre`的左子节点断开，再将`pre`指向右子节点。这里断开左子节点是上一层`root`的左子节点，因为`self.pre`保存的是上一层`root`的值。有两个意思：一是`pre`必须为单链表，不能有左子节点，二是如果`pre`继续存在左子节点，那么在递归返回遍历`right`时，会因为`root`存在错误的左子节点，造成重复遍历。
[^3]: 因为在下一轮递归的时候，`root`的右子树会被改变，相当于让`root`的右子树直接被自己的左子树覆盖，所以需要在这一层保存正确的地址，确认遍历的是正确的树结构。之所以能保证正确，是因为`root`左右子树是在下一层才会被修改，而当前层`root`的左右子树是正确的地址，所以`left`和`right`其实是在被修改前就拿到了正确的未被修改的地址的（领先`self.pre`修改`root`就拿到了正确地址）
[^4]: 前驱节点指的二叉树遍历（前序、中序、后序）中，挨着根节点的那个节点。
